<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>产品-确定功能的价值</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第六章 功能：细化与打包》的内容摘要。</p><h2 id="功能评估"><a href="#功能评估" class="headerlink" title="功能评估"></a>功能评估</h2><p>在动手之前，应该先对功能进行评估。功能的评估，主要从价值，成本，功能定位三个角度进行考量。参考一个性价比公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 价值最好分为6个等级（1，2，3，4，5，无限高） 成本最好按照 人/天 为单位</span><br><span class="line">性价比 = 价值/成本</span><br></pre></td></tr></table></figure><p>从理论上讲，性价比高的功能优先级也就高，应该先做。不过还应该考虑功能的定位，如果是基础功能，例如支付宝的支付功能，不管代价多大都要做了。</p><h2 id="功能的价值判断"><a href="#功能的价值判断" class="headerlink" title="功能的价值判断"></a>功能的价值判断</h2><p>从三个角度来判断功能的价值，分别是广度，频度，强度。</p><ul><li>广度：潜在用户数 * 单用户价值 可以用来判断功能对应的市场容量及广度。<ul><li>例如打车软件，潜在用户可能是几亿人的打车需求，因为用户使用基数大，所以价值高。</li><li>例如私人银行业务，虽然潜在用户比较少，但每个潜在用户都会有几个亿的存款，因为单用户价值高，所以价值高。</li></ul></li><li>频度：用户使用功能的频率 * 每次使用的转化率。<ul><li>例如外卖软件，用户可能一天要用好几次，每次可以从中转化几元钱，因为用户使用频度大，所以价值高。</li><li>例如结婚软件，用户可能一辈子用一次，但每次可以从中转化几万甚至是几十万，因为使用转化率大，所以价值高。</li></ul></li><li>强度：强度可以理解为用户刚需。可以从不可替代性，紧急程度，持久程度这几方面来看功能的强度。<ul><li>例如，当前功能是否可以被其他功能间接替代。</li><li>例如当前功能是否十分紧急，可能是政府要求等。</li><li>例如当前功能做出来之后是否可以长久投入使用，广告页需求不能持久投入使用。</li></ul></li></ul><h2 id="功能的实现成本"><a href="#功能的实现成本" class="headerlink" title="功能的实现成本"></a>功能的实现成本</h2><p>确定功能之后，粗粒度的评估出完成该功能需要花费的人力成本为多少，以 人/天 为单位。</p><h2 id="功能的定位"><a href="#功能的定位" class="headerlink" title="功能的定位"></a>功能的定位</h2><p>确定一个功能的定位，同样是非常重要的。帮助我们在评估功能的时候，了解该功能的重要程度。</p><ul><li>基础功能：基础功能是每个软件的核心功能，是必不可少的功能。例如支付宝的支付功能，淘宝的购物功能等。</li><li>亮点功能：亮点功能是提升用户忠诚度和口碑传播的功能。一个没有亮点的产品，用户也许偶尔会用，但不会建立正向感情连接，更不会主动帮我们传播。算是应用吸引客户的加分项。例如Chrome的404页面，iPhone5s的指纹识别</li><li>期望功能：期望功能是部分用户期望实现的功能。这类功能属于有则更好的类型，锦上添花。例如网易云音乐的音乐闹钟。</li><li>反向功能：反向功能是出现了会让用户讨厌但是又有利可图的功能。例如，软件广告，迅雷非会员限速功能等。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在确定功能时，首先应该确定功能定位；然后从广度，频度和强度三个方面进行评估功能的价值；最后确定开发成本。最后根据性价比公式，把功能的性价比算出来。然后参考性价比来实现优先实现简单且重要的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>人人都是产品经理 第二版</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Google I/O&#39; 2018 摘要</title>
      <link href="/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/"/>
      <url>/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是了解下未来的趋势，开阔眼界。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>今年大会的重点之一，感觉这方面是未来的大势所趋。降低生产力成本，改善生活。</p><ul><li><p>Google为了推广TensorFlow，作出了很多努力。在社区上积极帮助开发者解决机器学习遇到的各种问题，希望将TensorFlow推广到各个领域。</p></li><li><p>介绍了TensorFlow应用于医学的案例，希望通过机器学习为更多人提供医疗支持。举例在糖尿病眼球病变检测专业，已经做到了专家级的准确率。</p></li><li><p>介绍TensorFlow高层API，帮助开发者快速高效的搭建和训练模型。</p></li><li><p>TensorFlow支持Swift和JavaScript语言。JavaScript支持浏览器和Node环境。希望将TensorFlow和更多的开发体系相融合。</p></li><li><p>移动端的TensorFlow Lite方案，TensorFlow在移动设备上运行机器学习的终端解决方案，具备低延迟，runtime和小体积的特点。通过利用移动端硬件，提升解析速度。</p></li></ul><h3 id="闲鱼TensorFlow-Lite的应用："><a href="#闲鱼TensorFlow-Lite的应用：" class="headerlink" title="闲鱼TensorFlow Lite的应用："></a>闲鱼TensorFlow Lite的应用：</h3><ul><li><p>从节省人工成本角度：做了视频封面的抽取功能，做到自动提取视频预览页</p></li><li><p>从缓解服务端计算压力角度：做了视频指纹，去除重复上传的视频</p></li><li><p>从交互智能化角度：做了AI版房租信息发布页面，提供了用户操作的AI交互方式</p></li></ul><h3 id="端侧AI优势"><a href="#端侧AI优势" class="headerlink" title="端侧AI优势"></a>端侧AI优势</h3><ul><li><p>无网络延时</p></li><li><p>更高稳定性</p></li><li><p>数据隐私性</p></li><li><p>响应实时性</p></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>因为Flutter介绍，找不到视频，所以摘录了闲鱼的总结</p><ul><li><p>Flutter 与 原生混合开发的支持方式</p></li><li><p>如何在混合开发时，更好的利用hot reload机制</p></li><li><p>Flutter和原生组件的组合使用可行性介绍</p></li><li><p>Flutter 渲染原理层介绍<br><img src="/image/flutter_draw.png" alt="Flutter渲染原理图"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Flutter相关：<a href="https://yq.aliyun.com/articles/643698" target="_blank" rel="noopener">https://yq.aliyun.com/articles/643698</a></p><p>AI视频：<a href="https://live.iqiyi.com/s/19rqqzqp9v.html" target="_blank" rel="noopener">https://live.iqiyi.com/s/19rqqzqp9v.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 方法设计</title>
      <link href="/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="检验参数的有效性"><a href="#检验参数的有效性" class="headerlink" title="检验参数的有效性"></a>检验参数的有效性</h2><ul><li><p>应该在方法开头就检验参数的有效性，及时报出参数错误。</p><blockquote><p>传递无效参数给方法，这个方法在执行之前先对参数进行检验，那么他很快就会失败，并且清楚地呈现出适当的异常。如果这个方法没有检查他的参数，就有可能发生以下几种情景。该方法可能在处理过程中失败，并且产生令人费解的异常。更糟糕的是，该方法可以正常方法，但是会悄悄地计算出错误结果。最糟糕的是，该方法可以正常返回，但是却使得某个对象处于被破坏的状态，将来在某个不确定的时候，在某个不相关的点上会引发错误。</p></blockquote></li><li><p>public方法的参数校验直接抛出异常，包内方法则使用assert断言校验参数。</p><blockquote><p>对于未被导出方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。因此，非公有的方法通常应该使用断言来检查它们的参数。</p></blockquote></li></ul><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><ul><li><p>方法的入参和出参都需要考虑保护性拷贝。防止外部方法对其进行破坏性操作。这里的外部方法是指使用类的第三方方法。保护性拷贝不是必须的，但是每次在代码的时候，都应该考虑到这一步操作。尤其是写底层库的时候。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 入参的保护性拷贝</span><br><span class="line">public newClass(List&lt;String&gt; args)&#123;</span><br><span class="line">this.list = new ArrayList&lt;String&gt;(args);</span><br><span class="line">&#125;</span><br><span class="line">// 出参的保护性拷贝</span><br><span class="line">public getList()&#123;</span><br><span class="line">return new ArrayList&lt;String&gt;(this.list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><ul><li><p>方法名称很重要，在设计方法名时，应该始终遵守标准的命名习惯。</p><blockquote><p>尽量让自己的方法名看起来像一句话一样。在定好自己的方法名之后，最后写伪代码调用自己的方法，验证方法的可读性。设计底层库时很重要。</p></blockquote></li><li><p>避免过长的方法参数列表。</p><blockquote><p>方法的参数最好不超过4个。如果方法参数真的很长，可以考虑Build模式，让使用者优雅的设值，或者考虑外观类，给复杂的实现方法套一层简单的壳。</p></blockquote></li><li><p>boolean类型参数最好用枚举替代。</p><blockquote><p>这是boolean类型参数的小小建议。如果要在参数中使用boolean类型，最好用枚举类型进行替代。首先枚举更具有可读性，其次枚举更利于以后的扩展。</p></blockquote></li></ul><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><ul><li><p>Java语言要调用哪个重载方法是在编译时做出决定的。这一点不符合Java语言的运行时特性。一般情况下，我们认为覆盖操作比较符合Java标准的运行时特性。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 重载了classify方法</span><br><span class="line">public class CollectionClassifier &#123;</span><br><span class="line">public static String classify(Set&lt;?&gt; s) &#123;</span><br><span class="line">return &quot;Set&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public static String classify(List&lt;?&gt; lst) &#123;</span><br><span class="line">return &quot;List&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public static String classify(Collection&lt;?&gt; c) &#123;</span><br><span class="line">return &quot;Unknown Collection&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Collection&lt;?&gt;[] collections = &#123; new HashSet&lt;String&gt;(),</span><br><span class="line">new ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">new HashMap&lt;String, String&gt;().values() &#125;;</span><br><span class="line">for (Collection&lt;?&gt; c : collections)</span><br><span class="line">System.out.println(classify(c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 预期是打印出Set，List，Unknown Collection。但是实际上是打印出Unknown Collection，</span><br><span class="line">// Unknown Collection，Unknown Collection。因为重载是根据编译时决定要调用的是哪个方法。</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于重载容易引起编程时的想法和运行结果不一致。所以，在使用重载编写设计API的时候，应该尽量避免使用。防止API使用者引起误会。如果重载方法的参数的类型有继承关系，例如parse(String content)和parse(Object content)，最好用方法名区分开，paeseString(String content)和parseObject(Object content)。<strong>总之，方法参数数目相同的方法，应该尽量避免重载。</strong></p></blockquote></li></ul><h2 id="返回零长度的集合，而不是null"><a href="#返回零长度的集合，而不是null" class="headerlink" title="返回零长度的集合，而不是null"></a>返回零长度的集合，而不是null</h2><ul><li><p>方法返回集合时，如果集合内容为空，则返回一个空的集合对象，而不是null。</p><blockquote><p>因为对于返回null而不是零长度集合的方法来说，每次调用该方法时都需要判断下返回对象是都为null，从而防止NullPointerException，对于方法使用者很不友好。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>建站初衷</title>
      <link href="/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/"/>
      <url>/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>工作角色逐渐从客户端开发者转变为独立开发者。之前读大学的时候，还有写博客的习惯，后来慢慢转变为做笔记，最近变成了只看书不做笔记了。感觉在学习过程中，缺乏了深度思考的过程。于是，打算搭建个人博客，逼着自己做些深度思考的事情吧。将博客产出作为学习的考核标准。贵在坚持，持之以恒~</p><blockquote><p>博客地址: <a href="https://blog.daiyibo.cn">https://blog.daiyibo.cn</a></p></blockquote><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>Hexo搭建，算是比较简单了。在安装好git开发环境和node开发环境的情况下。需要做的事情如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 安装Hexo</span><br><span class="line"></span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">// 新建博客目录</span><br><span class="line"></span><br><span class="line">mkdir blog</span><br><span class="line"></span><br><span class="line">// 初始化Hexo模板</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">// 启动4000端口，运行博客，主要是本地测试用</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新建博客，下面命令会新建一个XXX.md的文件</span><br><span class="line"></span><br><span class="line">hexo new XXX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
