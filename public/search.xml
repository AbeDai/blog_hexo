<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>前端-JS中原型的理解</title>
      <link href="/2018/11/10/%E5%89%8D%E7%AB%AF-JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/11/10/%E5%89%8D%E7%AB%AF-JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="prototype与-proto-的区别"><a href="#prototype与-proto-的区别" class="headerlink" title="prototype与__proto__的区别"></a>prototype与__proto__的区别</h1><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ol><li>所有对象都具有__proto__属性。在JS中，一切皆对象。方法（Function）是对象，方法的原型(Function.prototype)也是对象，因此它们都有__proto__属性。</li><li>方法(Function)是一个特殊的对象，它除了有__proto__属性之外，还有自己特有的prototype属性。prototype属性指向一个所有实例共享的原型对象。原型对象中有一个constructor属性，指回到原函数。</li><li>对象的__proto__属性指向该对象的构造函数的prototype属性，这保证了对象能够访问构造函数的prototype属性中定义的属性和方法。</li></ol><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><p><img src="/image/js_prototype.jpg" alt="原型链图"></p><ol><li>构造函数（Foo()）<ul><li>构造函数的Foo.prototype属性指向了原型对象，在原型对象里有共有方法，所有构造函数声明的实例（f1，f2）都可以共享这些共用方法。</li><li>构造函数也是对象，也有__proto__属性。指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。</li></ul></li><li>原型对象（Foo.prototype）<ul><li>原型对象Foo.prototype保存着实例共享的方法，还有属性constructor指回构造函数。</li></ul></li><li>实例（f1，f2）<ul><li>f1，f2是Foo的两个实例，这两个对象有属性__proto__，指向构造函数的原型对象，这样就可以访问原型对象的所有方法啦。</li></ul></li></ol><p><strong>总结</strong></p><ol><li>对象有属性__proto__，指向该对象的构造函数的原型对象。</li><li>方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。</li></ol><h1 id="new操作到底做了什么？"><a href="#new操作到底做了什么？" class="headerlink" title="new操作到底做了什么？"></a>new操作到底做了什么？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Base();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上等价于</span></span><br><span class="line"><span class="comment">// 我们创建了一个空对象obj</span></span><br><span class="line"><span class="keyword">let</span> obj  = &#123;&#125;; </span><br><span class="line"><span class="comment">// 我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象</span></span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"><span class="comment">// 我们将Base函数对象的this指针替换成obj，并调用Base方法对obj进行初始化</span></span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h1 id="为啥constructor指向会错乱"><a href="#为啥constructor指向会错乱" class="headerlink" title="为啥constructor指向会错乱?"></a>为啥constructor指向会错乱?</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> F();</span><br><span class="line">F.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor)<span class="comment">//F</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor)<span class="comment">//Object</span></span><br></pre></td></tr></table></figure><p>首先你要明白，F.prototype 是对一个实例对象的引用，这个实例对象在你创建函数 F( ) 的时候同时被生成，如果我们给这个对象起个名字叫做 A，那么我们可以简单的理解为：A 是一个被存储在内存中的一个实例对象，而 F.prototype 是指向 A 的一个指针。</p><p>同时，A 对象内也有一个指针 constructor ，它指向了函数 F()。</p><p>那么当你第一次使用 new F( ) 时，生成了一个新对象 a ，p1 是对象 a 的一个引用（即p是指向a的一个指针），而 a 的 __proto__ 属性在此时也已经被指向为 A。</p><p>即目前，指向对象实例 A 的指针有两个，分别是 a.__proto__ 和 F.prototype。</p><p>之后你对 F.prototype 进行赋值时，实际上改变了 F.prototype 的指向，试他指向了另一个个实例对象{}，我们管这个实例对象叫 B 好了，对于这个实例对象 B，它的 constructor 的属性指向了 Object。</p><p>请注意，此时 a 的 __proto__ 的指向并没有改变，仍是指向了实例对象A。</p><p>那么当你第二次调用 new F( ) 的时候，实际上生成了另一个新的实例对象 b, b 的 __proto__ 属性指向的是B。</p><p>所以在 p1.constructor 的背后其实是相当于:<br>p1 -&gt; a, a.__proto__ -&gt; A, A.constructor -&gt; F( )</p><p>而在 p2.constructor 的背后则为：<br>p2 -&gt; b, b.__proto__ -&gt; B, B.constructor -&gt; Object( )</p><p><img src="/image/js_construct.png" alt="Construct指向图"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/q/1010000006918070" target="_blank" rel="noopener">https://segmentfault.com/q/1010000006918070</a></li><li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-对于《Socket心跳包》的思考</title>
      <link href="/2018/11/04/%E7%BD%91%E7%BB%9C-%E5%AF%B9%E4%BA%8E%E3%80%8ASocket%E5%BF%83%E8%B7%B3%E5%8C%85%E3%80%8B%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/11/04/%E7%BD%91%E7%BB%9C-%E5%AF%B9%E4%BA%8E%E3%80%8ASocket%E5%BF%83%E8%B7%B3%E5%8C%85%E3%80%8B%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要Socket心跳包"><a href="#为什么需要Socket心跳包" class="headerlink" title="为什么需要Socket心跳包"></a>为什么需要Socket心跳包</h2><p>实现方式上，TCP keepalive 和Socket心跳包机制类似。TCP keepalive 机制通过，在进行TCP连接时，发送keepalive数据包，来判断当前TCP连接是否仍然有效。问题来了，既然已经有了TCP keepalive，为什么还需要Socket心跳机制呢？</p><p>个人认为，需要Socket心跳机制的原因如下：</p><ol><li>真实网路环境中，TCP keepalive消息，可能会被中继设备和路由设备终结。</li><li>自己实现Socket心跳机制，处理断线重连的灵活性更高。</li><li>TCP keepalive本身是OSI模型中的传输层处理逻辑，由操作系统负责探查，即便服务进程死锁或阻塞，操作系统也会如常处理TCP keepalive消息，因此TCP keepalive的目标是保证传输层的网路通畅。而Socket心跳机制，是OSI模型中的应用层处理逻辑，由服务程序负责探查，不但能保证应用程序存活，网络通畅，更重要的是能够保证应用程序仍在正常工作。</li></ol><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><ul><li>单工：只允许甲方向乙方传送信息，而乙方不能向甲方传送，例如汽车的单行道。</li><li>全双工：允许数据在两个方向上同时进行传送操作，例如汽车的双行道。</li><li>半双工：允许数据在两个方向上进行传送操作，但是两端不能同时传送。例如一条窄窄的马路，同时只能有一辆车通过，当目前有两辆车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开。</li></ul><h2 id="WebSocket是什么？"><a href="#WebSocket是什么？" class="headerlink" title="WebSocket是什么？"></a>WebSocket是什么？</h2><p>中文翻译</p><ul><li><a href="https://www.jianshu.com/p/867274a5e054" target="_blank" rel="noopener">https://www.jianshu.com/p/867274a5e054</a></li><li><a href="https://www.jianshu.com/p/fc09b0899141" target="_blank" rel="noopener">https://www.jianshu.com/p/fc09b0899141</a></li></ul><p>英文原文</p><ul><li><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455</a></li></ul><h2 id="OkHttp3中WebSocket心跳设计"><a href="#OkHttp3中WebSocket心跳设计" class="headerlink" title="OkHttp3中WebSocket心跳设计"></a>OkHttp3中WebSocket心跳设计</h2><p>OkHttp3在3.5版本之后，对WebSocket进行了支持。</p><p>OkHttp3:3.5~3.10</p><ul><li>没有做心跳失效操作，手机端只负责发送ping操作，不管pong是否有收到。</li></ul><p>OkHttp3:3.11.0~之后</p><ul><li>做了简单的心跳失效操作，当发送第二次ping时，第一次ping的服务端pong还没有得到回应，则说明心跳失效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-大搜车的注解收集器</title>
      <link href="/2018/10/30/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2018/10/30/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是对编译时注解展开讨论。Android端对自定义注解的应用程度远没有达到Java Web端的那种程度，而且市面上也没有一个专注于抽象编译时注解底层技术的库。</p><p>在真实开发场景中，如果想要实现一个利用编译时注解的功能，往往需要花大量精力来处理APT这块的繁琐逻辑。例如，遍历所有注解相关类然后生成一定规律的代码。这些繁琐操作阻碍了大家使用注解的热情。设想一下，如果使用编译时注解只需要增加一两行代码，那你会不会更愿意使用注解呢？</p><p>所以，我们在想是否能够对编译时注解做进一步的抽象，帮助开发者将重点放在具体的功能实现上，而不是处理编译时注解的繁琐操作上？</p><h1 id="Nara的诞生"><a href="#Nara的诞生" class="headerlink" title="Nara的诞生"></a>Nara的诞生</h1><p>在动手之前，需要先弄清楚大家利用注解都做了哪些事情。清楚注解的使用场景，能帮助我们抽象出一个更好用的注解框架。于是，我们调研了Android端上常用的注解框架，看看他们利用注解都做了什么事情？</p><ul><li><p>ButterKnife：例如@BindViews，ButterKnife在编译期，利用@BindView将控件ID和类属性建立对应关系。然后在页面启动时，根据控件ID通过findViewById方法将控件赋值到类属性上。</p></li><li><p>EventBus：通过@Subscribe对普通方法进行标记。然后，EventBus在编译期通过@Subscribe将这些方法收集起来，作为EventBus的订阅方法。</p></li><li><p>Retrofit：通过反射方式处理注解，不再本文范畴。</p></li></ul><p>编译时注解的主要用途在于，收集注解并通过注解信息生成一些有规律的代码。</p><p>而这些有规律的代码，一般都是可以通过其他方式来间接实现的。比如说，ButterKnife的属性赋值可以通过反射来实现，EventBus的方法收集可以直接换个写法。所以，如果要对编译时注解做进一步抽象，我们认为可以从注解收集方面入手。由此，Nara注解收集器诞生了。</p><h2 id="API的设计"><a href="#API的设计" class="headerlink" title="API的设计"></a>API的设计</h2><p>对于底层库而言，设计一套好用的API是很重要的。从库的使用者角度看，希望注解收集器能够帮助我们实现哪些功能呢？</p><ul><li>注解的作用范围：通过分析市面上编译时注解的使用场景，发现对注解的应用主要在于类，方法和属性上。</li><li>自定义注解：作为注解抽象库，如果无法支持自定义注解，那对可扩展性简直就是致命的打击。所以需要提供自定义注解功能。</li><li>注解收集：注解收集作为核心功能，必须要提供一套好用的收集操作。我们考虑用链式Builder来完成注解收集功能。</li></ul><p>最终设计的API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解API</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE, ElementType.METHOD, ElementType.FIELD)</span><br><span class="line"><span class="meta">@ShadowBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解的使用API</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationClass</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">AnnotationMethod</span><span class="params">(<span class="keyword">int</span> p1, String p2, AnnotationClass p3, T p4)</span></span>&#123;</span><br><span class="line">    Log.e(<span class="string">"souche"</span>, <span class="string">"test2("</span> + <span class="string">"p1("</span> + p1 + <span class="string">"),p2("</span> + p2 + <span class="string">"),p3("</span> + p3 + <span class="string">"),p4("</span> + p4 + <span class="string">"));"</span>);</span><br><span class="line">    <span class="keyword">return</span> p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 成员属性</span></span><br><span class="line"><span class="keyword">public</span> List&lt;AnnotationClass&gt; annotationField;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集注解的使用API，以Class的收集举例</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">List&lt;ClassDesc&gt; listClass = Nara</span><br><span class="line">                .findClass(CustomAnnotation.class) <span class="comment">// 查找类，参数为其所在注解</span></span><br><span class="line">                .withExtends(Activity.class) <span class="comment">// 筛选条件：查找的类，需要继承Activity类</span></span><br><span class="line">                .withAnnotations(Collect.class) <span class="comment">// 筛选条件：查找的类，需要被@Collect注解</span></span><br><span class="line">                .filter(<span class="keyword">new</span> AnnotationFilter&lt;ClassDesc&gt;() &#123; <span class="comment">// 自定义筛选条件：return true 表示过滤掉当前类</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(ClassDesc obj)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .list(); <span class="comment">// 返回符合条件的类集合</span></span><br></pre></td></tr></table></figure><h1 id="实现的痛点"><a href="#实现的痛点" class="headerlink" title="实现的痛点"></a>实现的痛点</h1><p>一个优秀的底层库，应该将复杂实现隐藏起来，并且做到实现对于上层使用者透明。下面简单分享下实现Nara时，遇到的几个技术痛点。</p><h3 id="对泛型的支持"><a href="#对泛型的支持" class="headerlink" title="对泛型的支持"></a>对泛型的支持</h3><p>在收集注解信息时，会遇到方法参数或者属性中带有泛型信息的情况。为了收集这些泛型信息，我们利用了Gson实现的TypeToken泛型Type转化工具。将TypeToken的相关代码拷贝到了Nara内部。Gson获取Type的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">new</span> TypeToken&lt;clazz&gt;() &#123;&#125;.getType();</span><br></pre></td></tr></table></figure><h2 id="被注解对象的包级作用域问题"><a href="#被注解对象的包级作用域问题" class="headerlink" title="被注解对象的包级作用域问题"></a>被注解对象的包级作用域问题</h2><p>Nara注解收集是支持包级作用域的信息收集的。这里就存在一个问题，包作用域的类，方法和属性是不允许跨包访问的。那么，如何在不同包下获取包级作用域下的信息呢？我们采取的方式是利用编译时注解生成被注解类的同包名下的类，然后将包级作用域的信息用public的形式暴露出来。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 例如包级作用域的属性</span></span><br><span class="line"><span class="keyword">package</span> com.example.souche.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span></span><br><span class="line">String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将People.name的get和set方法的作用域暴露出来</span></span><br><span class="line"><span class="comment">// 我们在编译时，生成了public作用域的get和set方法</span></span><br><span class="line"><span class="keyword">package</span> com.example.souche.annotation;</span><br><span class="line"><span class="comment">/** This class is generated by SouChe Annotation Collection, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerCollection</span>$<span class="title">AdaptableClass1540292058755_29</span> </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">com</span>.<span class="title">souche</span>.<span class="title">android</span>.<span class="title">annotation</span>.<span class="title">core</span>.<span class="title">FieldDesc</span>.<span class="title">BeanMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object... params)</span></span>&#123; </span><br><span class="line">                <span class="keyword">if</span> (params.length != <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"set argument format error!"</span>);</span><br><span class="line">                com.example.souche.annotation.People.name = (java.lang.String)params[<span class="number">0</span>];</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object... params)</span></span>&#123; </span><br><span class="line">                <span class="keyword">if</span> (params.length != <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"get argument format error!"</span>);</span><br><span class="line">                <span class="keyword">return</span> com.example.souche.annotation.People.name;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件化下的编译时注解问题"><a href="#组件化下的编译时注解问题" class="headerlink" title="组件化下的编译时注解问题"></a>组件化下的编译时注解问题</h2><p>我们团队是采用的是模块化的开发形式，模块将代码将aar包上传到maven仓库，主工程再通过gradle来依赖模块aar包。这样就会存在一个问题，由于编译时注解的作用范围是源码级别的，所以无法对aar包中的注解进行收集。</p><p>我们的解决思路是，如果模块需要使用Nara注解收集器，在模块打包时，就将Nara相关代码打进aar包，然后在主工程打包时，通过gradle插件扫描整个app的字节码，找到Nara相关代码，将这些代码整合起来，生成一个Nara初始化主类。总体打包流程如下：</p><p><img src="/image/nara_compile_flowchat.png" alt="编译流程图"></p><h1 id="框架愿景"><a href="#框架愿景" class="headerlink" title="框架愿景"></a>框架愿景</h1><p>Nara是对编译时注解的上层抽象，我们希望通过Nara来降低编译时注解的开发成本。让使用者把精力放在逻辑实现上，而不是在注解信息收集上。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-OSI 七层通讯</title>
      <link href="/2018/10/11/%E7%BD%91%E7%BB%9C-OSI-%E4%B8%83%E5%B1%82%E9%80%9A%E8%AE%AF/"/>
      <url>/2018/10/11/%E7%BD%91%E7%BB%9C-OSI-%E4%B8%83%E5%B1%82%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<style>table th:nth-of-type(1) {    width: 100px;}</style><h2 id="OSI七层通讯"><a href="#OSI七层通讯" class="headerlink" title="OSI七层通讯"></a>OSI七层通讯</h2><table><thead><tr><th>通讯层</th><th>作用说明</th></tr></thead><tbody><tr><td>应用层</td><td>它的作用fancybox是为应用程序提供服务并规定应用程序中通讯相关的细节。是最贴近应用开发人员的网络层。常见的协议有 HTTP，FTP，TELNET、SMTP 等。</td></tr><tr><td>表示层</td><td>它的作用是将应用层处理的信息从主机特有的格式转换为网络标准传输格式</td></tr><tr><td>会话层</td><td>它的作用是确定建立和断开网络的时机，并管理网络连接</td></tr><tr><td>传输层</td><td>它的作用是建立网络连接，创建逻辑上的通信连接，从逻辑上将数据发送到目标对象</td></tr><tr><td>网络层</td><td>它的作用是将数据传输到目标地址，重点在于寻找目标地址。可能需要通过多个路由器连接才能到达目标地址。</td></tr><tr><td>数据链路层</td><td>它的作用是物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。</td></tr><tr><td>物理层</td><td>它的作用是将0、1比特流（0、1序列）与电信号和光信号进行转化。实现物理层面上的数据传输。</td></tr></tbody></table><h2 id="网络设备对应的OSI通讯层"><a href="#网络设备对应的OSI通讯层" class="headerlink" title="网络设备对应的OSI通讯层"></a>网络设备对应的OSI通讯层</h2><ul><li><p>物理层：中继器<br><img src="/image/network_中继器.png" alt="网络设备图"></p></li><li><p>数据链路层：网桥<br><img src="/image/network_网桥.png" alt="网络设备图"></p></li><li><p>网络层：路由器<br><img src="/image/network_路由器.png" alt="网络设备图"></p></li><li><p>上层应用：网关<br><img src="/image/network_网关.png" alt="网络设备图"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 同步</title>
      <link href="/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><p>当多线程共享可变数据时，每个读或者写数据的线程都必须执行同步。同步方式可以是加锁，也可以是volatile。如果没有同步，就无法确保一个线程所做的修改可以被另一个线程获知。</p><h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><ul><li>在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。过度的帮助类进行同步操作，会带来性能上的损耗</li><li><p>为了避免不可控性，千万不要在同步区域中调用外来方法。要把同步操作的控制权牢牢抓在自己手中</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet set, Object element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&gt; observers</span><br><span class="line">                        = <span class="keyword">new</span> ArrayList&lt;SetObserver&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误通知示范：</span></span><br><span class="line">    <span class="comment">// 如果在SetObserver的added()方法中调用复杂的addObserver()方法，</span></span><br><span class="line">    <span class="comment">// 会导致ConcurrentModificationException异常，相当于外部调用方法</span></span><br><span class="line">    <span class="comment">// 来影响同步代码块中的操作逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SetObserver observer : observers)</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确通知示范：</span></span><br><span class="line">    <span class="comment">// 将外来调用方法放到同步块外面，同步块中只做极少的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        List&lt;SetObserver&gt; tempObservers;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            tempObservers = <span class="keyword">new</span> ArrayList(observers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SetObserver observer : tempObservers)</span><br><span class="line">            observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加数据步骤省略</span></span><br><span class="line">        <span class="comment">// 通知所有观察者对象</span></span><br><span class="line">        <span class="keyword">if</span> (added)</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="executor和task优先于线程"><a href="#executor和task优先于线程" class="headerlink" title="executor和task优先于线程"></a>executor和task优先于线程</h2><p>Executor Framework提供了灵活的任务执行工具，支持各种类型的线程池。引导开发者将线程工作拆分成了独立任务单元(Runnable)。因此，推荐开发者使用Executor解决问题，而不是自己创建线程。</p><h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><ul><li>大多数域应该正常地进行初始化，而不是延迟初始化。延迟初始化会带来同步问题，产生不必要的错误</li><li><p>某些场景必须要使用延迟初始化，有如下建议：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于静态作用域，建议使用Class Holder初始化模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于实例域，则建议使用双重检查模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function">FieldValue <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">    field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于可以接受重复初始化的实例域，则考虑使用单重检测模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><p>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移殖的。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 异常</title>
      <link href="/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="只针对异常情况才使用异常"><a href="#只针对异常情况才使用异常" class="headerlink" title="只针对异常情况才使用异常"></a>只针对异常情况才使用异常</h2><p>控制正常流程时不应该使用异常，只有当程序发生异常时才应该抛出Exception。Exception就是来描述程序发生异常的，不要职责不清地让异常来处理非异常的事情。例如下面的for-each循环，不应该用异常来控制循环，而应该用状态测试来控制循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范，通过异常来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.next()的NoSuchElementException来判断循环是否结束</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line">    <span class="comment">// 终止循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示范，通过状态测试方法来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.hasNext()方法来判断循环是否结束</span></span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"><a href="#对于可恢复的情况使用受检异常，对于编程错误使用运行时异常" class="headerlink" title="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"></a>对于可恢复的情况使用受检异常，对于编程错误使用运行时异常</h2><ul><li>受检异常：如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。例如文件操作后，文件流的关闭操作。</li><li>非受检异常：如果程序抛出未受检异常或者错误，往往就属于不可恢复的情形，继续执行下去有害无益。例如List.get()的数据越界操作。</li></ul><h2 id="避免不必要地使用受检异常"><a href="#避免不必要地使用受检异常" class="headerlink" title="避免不必要地使用受检异常"></a>避免不必要地使用受检异常</h2><p>当方法存在受检异常时，会给API调用者增加使用成本，例如每次调用该方法时，都要加try-catch代码块。应当少用受检异常。</p><p>使用受检异常的原则</p><ul><li>正确地使用API并不能阻止这种异常条件的产生。参考文件操作，无法保证文件操作不会抛出异常。</li><li>产生异常后，API调用者可以立即采用有效操作。参考文件操作，文件操作抛出异常后，马上关闭文件，然后执行文件处理失败逻辑。</li></ul><h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><p>利用Java提供的标准异常，相当于站在了巨人的肩膀上。可以使你的API更加易于学习，易于使用，更加可读。</p><h2 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h2><p>方法抛出的异常，应该与当前方法有联系。上层实现应该捕获下层异常，同时抛出符合上层语义的异常。例如集合中的异常处理示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将NoSuchElementException改为IndexOutOfBoundException</span></span><br><span class="line"><span class="comment">// 使方法抛出的异常更符合语义，提高了代码的可读性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">ListIterator&lt;E&gt; i = listIterator(index);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.next();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundException(<span class="string">"Index:"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常中包含能捕获失败的信息"><a href="#异常中包含能捕获失败的信息" class="headerlink" title="异常中包含能捕获失败的信息"></a>异常中包含能捕获失败的信息</h2><p>异常面向的用户是开发者，异常信息的内容，应该提供异常堆栈信息，异常信息描述的详细内容等。因为异常面向开发者，所以描述信息最好为英文。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 通用程序设计</title>
      <link href="/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><p>将局部变量的作用域最小化，使代码减少出错，更加可读。</p><ul><li><p>降低出错的可能性</p><blockquote><p>如果变量在它的目标使用区域之前或者之后被意外地使用的话，会产生意想不到的错误。示例如下：</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">Iterator&lt;Element&gt; i = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator();</span><br><span class="line"><span class="comment">// BUG，误将i2写成了i，导致不必要的错误</span></span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomethingElse(i2.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供作用域的最小范围，可以避免此类错误的发生</span></span><br><span class="line">;</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c2.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomethingElse(i.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强可读性</p><blockquote><p>将变量放在使用之前声明，会分散读者注意力。等到用到该变量的时候，读者可能已经记不起该变量的类型和初始值了。</p></blockquote></li></ul><h2 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h2><p>能用for-each循环实现功能的情况下，尽量使用for-each循环。</p><ul><li>for-each循环内部帮你维护了迭代器，降低了自己维护迭代器产生错误的风险。</li><li>for-each循环让代码变得尽量简洁，提高代码可读性。</li></ul><h2 id="如果需要精确的数值，请避免使用float和double"><a href="#如果需要精确的数值，请避免使用float和double" class="headerlink" title="如果需要精确的数值，请避免使用float和double"></a>如果需要精确的数值，请避免使用float和double</h2><ul><li>float和double类型，并没有提供完全精确的结果。所以不应该被用于需要精确结果的场合。尤其不适合用于货币计算，最好用int，long或BigDecimal代替。</li></ul><h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><p>能用基本类型就尽量使用基本类型。装箱基本类型存在以下缺点：</p><ul><li>两个装箱基本类型，存在相同的数值，却只想不同的内存对象。进行比较时，需要调用equil，同时还需考虑NullPointException异常。提高了使用的成本，加大了在开发中出错的风险。</li><li>基本类型比装箱基本类型更节省内存空间，在进行运算操作时也更节省运行时间。装箱基本类型可能会存在频繁的装箱和拆箱。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-规划与迭代</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第八章 成长：规划与迭代》的内容摘要。</p><p>规划是战略布局，是定方向，做正确的事；迭代是战术实施，是定走法，正确地做事。规划的重点在于想，迭代的重点在于动手实现。</p><ul><li>规划，是以自我为中心，以公司为中心的，是生产驱动的。</li><li>迭代，是需求驱动的，是对用户反馈的不断响应，需要根据市场信息的变化一步步的调整。</li></ul><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>由于互联网处于快速变化的大环境中，因此会存在规划更不上变化的情况。最好只做两个规划，最长规划和最短规划。最短规划指最近1个月到3个月，最多6个月的时间段里，要做什么，其实更像是一个项目计划。长计划是这个产品的终极目标，比如3到5年，甚至10年以后会是什么样子，要思考那个时候我们能处于产业链的什么位置。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代的重点在于实现，建议使用敏捷开发的方式，敏捷开发有一下几个关键点。</p><ul><li>沟通，团队之间要进行快速沟通，建立相互信任相互认可的团队氛围。</li><li>简单，做最简单的事，实现想要的目的。</li><li>反馈，拥抱变化，用包容的心态去面对多方反馈，来自同事，用户等。</li><li>勇气，不怕犯错，用于尝试新事物，用于创新。</li><li>谦逊，承认自己的片面性，虚心接受来自多方的建议，善于借助多方的优势。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-确定功能的价值</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第六章 功能：细化与打包》的内容摘要。</p><h2 id="功能评估"><a href="#功能评估" class="headerlink" title="功能评估"></a>功能评估</h2><p>在动手之前，应该先对功能进行评估。功能的评估，主要从价值，成本，功能定位三个角度进行考量。参考一个性价比公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 价值最好分为6个等级（1，2，3，4，5，无限高） 成本最好按照 人/天 为单位</span></span><br><span class="line">性价比 = 价值/成本</span><br></pre></td></tr></table></figure><p>从理论上讲，性价比高的功能优先级也就高，应该先做。不过还应该考虑功能的定位，如果是基础功能，例如支付宝的支付功能，不管代价多大都要做了。</p><h2 id="功能的价值判断"><a href="#功能的价值判断" class="headerlink" title="功能的价值判断"></a>功能的价值判断</h2><p>从三个角度来判断功能的价值，分别是广度，频度，强度。</p><ul><li>广度：潜在用户数 * 单用户价值 可以用来判断功能对应的市场容量及广度。<ul><li>例如打车软件，潜在用户可能是几亿人的打车需求，因为用户使用基数大，所以价值高。</li><li>例如私人银行业务，虽然潜在用户比较少，但每个潜在用户都会有几个亿的存款，因为单用户价值高，所以价值高。</li></ul></li><li>频度：用户使用功能的频率 * 每次使用的转化率。<ul><li>例如外卖软件，用户可能一天要用好几次，每次可以从中转化几元钱，因为用户使用频度大，所以价值高。</li><li>例如结婚软件，用户可能一辈子用一次，但每次可以从中转化几万甚至是几十万，因为使用转化率大，所以价值高。</li></ul></li><li>强度：强度可以理解为用户刚需。可以从不可替代性，紧急程度，持久程度这几方面来看功能的强度。<ul><li>例如，当前功能是否可以被其他功能间接替代。</li><li>例如当前功能是否十分紧急，可能是政府要求等。</li><li>例如当前功能做出来之后是否可以长久投入使用，广告页需求不能持久投入使用。</li></ul></li></ul><h2 id="功能的实现成本"><a href="#功能的实现成本" class="headerlink" title="功能的实现成本"></a>功能的实现成本</h2><p>确定功能之后，粗粒度的评估出完成该功能需要花费的人力成本为多少，以 人/天 为单位。</p><h2 id="功能的定位"><a href="#功能的定位" class="headerlink" title="功能的定位"></a>功能的定位</h2><p>确定一个功能的定位，同样是非常重要的。帮助我们在评估功能的时候，了解该功能的重要程度。</p><ul><li>基础功能：基础功能是每个软件的核心功能，是必不可少的功能。例如支付宝的支付功能，淘宝的购物功能等。</li><li>亮点功能：亮点功能是提升用户忠诚度和口碑传播的功能。一个没有亮点的产品，用户也许偶尔会用，但不会建立正向感情连接，更不会主动帮我们传播。算是应用吸引客户的加分项。例如Chrome的404页面，iPhone5s的指纹识别</li><li>期望功能：期望功能是部分用户期望实现的功能。这类功能属于有则更好的类型，锦上添花。例如网易云音乐的音乐闹钟。</li><li>反向功能：反向功能是出现了会让用户讨厌但是又有利可图的功能。例如，软件广告，迅雷非会员限速功能等。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在确定功能时，首先应该确定功能定位；然后从广度，频度和强度三个方面进行评估功能的价值；最后确定开发成本。最后根据性价比公式，把功能的性价比算出来。然后参考性价比来实现优先实现简单且重要的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>人人都是产品经理 第二版</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Google I/O&#39; 2018 摘要</title>
      <link href="/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/"/>
      <url>/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是了解下未来的趋势，开阔眼界。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>今年大会的重点之一，感觉这方面是未来的大势所趋。降低生产力成本，改善生活。</p><ul><li><p>Google为了推广TensorFlow，作出了很多努力。在社区上积极帮助开发者解决机器学习遇到的各种问题，希望将TensorFlow推广到各个领域。</p></li><li><p>介绍了TensorFlow应用于医学的案例，希望通过机器学习为更多人提供医疗支持。举例在糖尿病眼球病变检测专业，已经做到了专家级的准确率。</p></li><li><p>介绍TensorFlow高层API，帮助开发者快速高效的搭建和训练模型。</p></li><li><p>TensorFlow支持Swift和JavaScript语言。JavaScript支持浏览器和Node环境。希望将TensorFlow和更多的开发体系相融合。</p></li><li><p>移动端的TensorFlow Lite方案，TensorFlow在移动设备上运行机器学习的终端解决方案，具备低延迟，runtime和小体积的特点。通过利用移动端硬件，提升解析速度。</p></li></ul><h3 id="闲鱼TensorFlow-Lite的应用："><a href="#闲鱼TensorFlow-Lite的应用：" class="headerlink" title="闲鱼TensorFlow Lite的应用："></a>闲鱼TensorFlow Lite的应用：</h3><ul><li><p>从节省人工成本角度：做了视频封面的抽取功能，做到自动提取视频预览页</p></li><li><p>从缓解服务端计算压力角度：做了视频指纹，去除重复上传的视频</p></li><li><p>从交互智能化角度：做了AI版房租信息发布页面，提供了用户操作的AI交互方式</p></li></ul><h3 id="端侧AI优势"><a href="#端侧AI优势" class="headerlink" title="端侧AI优势"></a>端侧AI优势</h3><ul><li><p>无网络延时</p></li><li><p>更高稳定性</p></li><li><p>数据隐私性</p></li><li><p>响应实时性</p></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>因为Flutter介绍，找不到视频，所以摘录了闲鱼的总结</p><ul><li><p>Flutter 与 原生混合开发的支持方式</p></li><li><p>如何在混合开发时，更好的利用hot reload机制</p></li><li><p>Flutter和原生组件的组合使用可行性介绍</p></li><li><p>Flutter 渲染原理层介绍<br><img src="/image/flutter_draw.png" alt="Flutter渲染原理图"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Flutter相关：<a href="https://yq.aliyun.com/articles/643698" target="_blank" rel="noopener">https://yq.aliyun.com/articles/643698</a></p><p>AI视频：<a href="https://live.iqiyi.com/s/19rqqzqp9v.html" target="_blank" rel="noopener">https://live.iqiyi.com/s/19rqqzqp9v.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 方法设计</title>
      <link href="/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="检验参数的有效性"><a href="#检验参数的有效性" class="headerlink" title="检验参数的有效性"></a>检验参数的有效性</h2><ul><li><p>应该在方法开头就检验参数的有效性，及时报出参数错误。</p><blockquote><p>传递无效参数给方法，这个方法在执行之前先对参数进行检验，那么他很快就会失败，并且清楚地呈现出适当的异常。如果这个方法没有检查他的参数，就有可能发生以下几种情景。该方法可能在处理过程中失败，并且产生令人费解的异常。更糟糕的是，该方法可以正常方法，但是会悄悄地计算出错误结果。最糟糕的是，该方法可以正常返回，但是却使得某个对象处于被破坏的状态，将来在某个不确定的时候，在某个不相关的点上会引发错误。</p></blockquote></li><li><p>public方法的参数校验直接抛出异常，包内方法则使用assert断言校验参数。</p><blockquote><p>对于未被导出方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。因此，非公有的方法通常应该使用断言来检查它们的参数。</p></blockquote></li></ul><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><ul><li><p>方法的入参和出参都需要考虑保护性拷贝。防止外部方法对其进行破坏性操作。这里的外部方法是指使用类的第三方方法。保护性拷贝不是必须的，但是每次在代码的时候，都应该考虑到这一步操作。尤其是写底层库的时候。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">newClass</span><span class="params">(List&lt;String&gt; args)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;String&gt;(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><ul><li><p>方法名称很重要，在设计方法名时，应该始终遵守标准的命名习惯。</p><blockquote><p>尽量让自己的方法名看起来像一句话一样。在定好自己的方法名之后，最后写伪代码调用自己的方法，验证方法的可读性。设计底层库时很重要。</p></blockquote></li><li><p>避免过长的方法参数列表。</p><blockquote><p>方法的参数最好不超过4个。如果方法参数真的很长，可以考虑Build模式，让使用者优雅的设值，或者考虑外观类，给复杂的实现方法套一层简单的壳。</p></blockquote></li><li><p>boolean类型参数最好用枚举替代。</p><blockquote><p>这是boolean类型参数的小小建议。如果要在参数中使用boolean类型，最好用枚举类型进行替代。首先枚举更具有可读性，其次枚举更利于以后的扩展。</p></blockquote></li></ul><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><ul><li><p>Java语言要调用哪个重载方法是在编译时做出决定的。这一点不符合Java语言的运行时特性。一般情况下，我们认为覆盖操作比较符合Java标准的运行时特性。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载了classify方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection&lt;?&gt;[] collections = &#123; <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, String&gt;().values() &#125;;</span><br><span class="line"><span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</span><br><span class="line">System.out.println(classify(c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期是打印出Set，List，Unknown Collection。但是实际上是打印出Unknown Collection，</span></span><br><span class="line"><span class="comment">// Unknown Collection，Unknown Collection。因为重载是根据编译时决定要调用的是哪个方法。</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于重载容易引起编程时的想法和运行结果不一致。所以，在使用重载编写设计API的时候，应该尽量避免使用。防止API使用者引起误会。如果重载方法的参数的类型有继承关系，例如parse(String content)和parse(Object content)，最好用方法名区分开，paeseString(String content)和parseObject(Object content)。<strong>总之，方法参数数目相同的方法，应该尽量避免重载。</strong></p></blockquote></li></ul><h2 id="返回零长度的集合，而不是null"><a href="#返回零长度的集合，而不是null" class="headerlink" title="返回零长度的集合，而不是null"></a>返回零长度的集合，而不是null</h2><ul><li><p>方法返回集合时，如果集合内容为空，则返回一个空的集合对象，而不是null。</p><blockquote><p>因为对于返回null而不是零长度集合的方法来说，每次调用该方法时都需要判断下返回对象是都为null，从而防止NullPointerException，对于方法使用者很不友好。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>建站初衷</title>
      <link href="/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/"/>
      <url>/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>工作角色逐渐从客户端开发者转变为独立开发者。之前读大学的时候，还有写博客的习惯，后来慢慢转变为做笔记，最近变成了只看书不做笔记了。感觉在学习过程中，缺乏了深度思考的过程。于是，打算搭建个人博客，逼着自己做些深度思考的事情吧。将博客产出作为学习的考核标准。贵在坚持，持之以恒~</p><blockquote><p>博客地址: <a href="https://blog.daiyibo.cn">https://blog.daiyibo.cn</a></p></blockquote><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>Hexo搭建，算是比较简单了。在安装好git开发环境和node开发环境的情况下。需要做的事情如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 安装Hexo</span><br><span class="line"></span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">// 新建博客目录</span><br><span class="line"></span><br><span class="line">mkdir blog</span><br><span class="line"></span><br><span class="line">// 初始化Hexo模板</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">// 启动4000端口，运行博客，主要是本地测试用</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新建博客，下面命令会新建一个XXX.md的文件</span><br><span class="line"></span><br><span class="line">hexo new XXX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
