<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>前端-CSS样式表声明</title>
      <link href="/2020/01/30/%E5%89%8D%E7%AB%AF-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%A3%B0%E6%98%8E/"/>
      <url>/2020/01/30/%E5%89%8D%E7%AB%AF-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><img src="/image/css_shenmin.gif"></p><ul><li>选择器：用于标识需改变样式的 HTML 元素</li><li>样式属性：key和value用冒号分开，总体标识一个样式属性。分号用来隔离多个样式属性。</li></ul><h4 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">--</span> 如果值为若干单词，则要给值加引号 <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-family</span>: <span class="string">"sans serif"</span>;&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">--</span> 多个样式属性之间，用 分号 隔离 <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">font-family</span>: arial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">--</span> 逗号表示同个属性的多个可能取值；它是顺序取值，前一个不存在就选择后一个，描述同一属性。 <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>:Arial,Verdana,Geneva,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样式表声明"><a href="#样式表声明" class="headerlink" title="样式表声明"></a>样式表声明</h2><h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">// 在头部引用外部样式表的引用</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">// css</span><br><span class="line">// mystyle.css 文件内容如下</span><br><span class="line">hr &#123;color: sienna;&#125;</span><br><span class="line">p &#123;margin-left: 20px;&#125;</span><br><span class="line">body &#123;background-image: url("images/back40.gif");&#125;</span><br></pre></td></tr></table></figure><h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p>当单个文档需要特殊的样式时，需要使用内部样式表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">hr</span> &#123;<span class="attribute">color</span>: sienna;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"images/back40.gif"</span>);&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="内联样式表"><a href="#内联样式表" class="headerlink" title="内联样式表"></a>内联样式表</h4><p>当样式仅需要在一个元素上应用一次时，需要使用内联样式表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red; margin-left: 20px"</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端-CSS选择器全解</title>
      <link href="/2020/01/30/%E5%89%8D%E7%AB%AF-CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%85%A8%E8%A7%A3/"/>
      <url>/2020/01/30/%E5%89%8D%E7%AB%AF-CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>选择器是CSS中很重要的概念。用于描述当前CSS样式作用于哪些HTML标签。</p><h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><p>元素选择器可以为特定的HTML元素指定特定的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line">html &#123;color:red;&#125;</span><br><span class="line">h1 &#123;color:blue;&#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个段落是红色的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这个标题是蓝色的<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><blockquote><p>参考：<a href="https://www.w3school.com.cn/css/css_selector_class.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css/css_selector_class.asp</a></p></blockquote><p>类选择器可以为标有特定 class 的 HTML 元素制定特有的样式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line"><span class="selector-class">.green</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br><span class="line">.green strong &#123; color: blue; &#125; // 与派生选择器结合使用</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;p class="green"&gt;这个段落是红色。&lt;/p&gt;</span><br><span class="line">&lt;p class="green"&gt;这个段落是绿色。&lt;strong&gt;strong标签内容为蓝色。&lt;/strong&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>类选择器可以结合元素选择器来使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line">* &#123; <span class="attribute">color</span>:red &#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.green</span> &#123; <span class="attribute">color</span>:green &#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;p&gt;这个段落是红色的&lt;/p&gt;</span><br><span class="line">&lt;h1&gt;这个段落是绿色的，为类选择器和元素选择器结合使用的结果&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>多类选择器表示多个类选择器和多个HTML元素之间的关系：</p><pre><code>- HTML元素通过空格来隔离多个类名：`&lt;p class=&quot;important warning&quot;&gt;`- 类选择器通过点号来表示类名全部符合的要求：`.important.warning {background:silver;}`</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line"><span class="selector-class">.warning</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br><span class="line"><span class="selector-class">.important</span> &#123;<span class="attribute">color</span>:yellow;&#125;</span><br><span class="line"><span class="selector-class">.important</span><span class="selector-class">.warning</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;p class="important"&gt;这个段落是黄色的&lt;/p&gt;</span><br><span class="line">&lt;p class="warning"&gt;这个段落是绿色的&lt;/p&gt;</span><br><span class="line">&lt;p class="important warning"&gt;这个段落是红色的&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line">#red &#123; color: red; &#125;</span><br><span class="line">#green &#123; color: green; &#125;</span><br><span class="line">#green strong &#123; color: blue; &#125; // 与派生选择器结合使用</span><br><span class="line">  </span><br><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span>这个段落是红色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"green"</span>&gt;</span>这个段落是绿色。<span class="tag">&lt;<span class="name">strong</span>&gt;</span>strong标签内容为蓝色。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><blockquote><p>参考：<a href="https://www.w3school.com.cn/css/css_selector_attribute.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css/css_selector_attribute.asp</a></p></blockquote><p>属性选择器可以对带有指定属性的 HTML 元素设置样式。而不仅限于 class 和 id 属性。</p><table><thead><tr><th>选择器</th><th>描述</th></tr></thead><tbody><tr><td>[attribute]</td><td>用于选取带有指定属性的元素。</td></tr><tr><td>[attribute=value]</td><td>用于选取带有指定属性和值的元素。</td></tr><tr><td>[attribute~=value]</td><td>用于选取属性值中包含指定词汇的元素。</td></tr><tr><td>[attribute¦=value]</td><td>用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。</td></tr><tr><td>[attribute^=value]</td><td>匹配属性值以指定值开头的每个元素。</td></tr><tr><td>[attribute$=value]</td><td>匹配属性值以指定值结尾的每个元素。</td></tr><tr><td>[attribute*=value]</td><td>匹配属性值中包含指定值的每个元素。</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line"><span class="selector-attr">[title]</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;p title="test"&gt;这个段落是红色，因为符合属性选择器的作用条件。&lt;/p&gt;</span><br><span class="line">&lt;p &gt;这个段落为默认颜色。&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>属性选择器可以结合元素选择器来使用。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 对只有 href 属性的锚（a 元素）应用样式</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><p>多个属性进行选择，只需将属性选择器链接在一起即可。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-attr">[title]</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><blockquote><p>参考：<a href="https://www.w3school.com.cn/css/css_pseudo_classes.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css/css_pseudo_classes.asp</a></p></blockquote><p>伪类为不存在的类，用于向某些选择器添加特殊的效果，是一种动态表现形式。</p><p><img src="/image/css_weilei.png" alt=""></p><table><thead><tr><th>伪类</th><th>描述</th></tr></thead><tbody><tr><td>:active</td><td>向被激活的元素添加样式。</td></tr><tr><td>:focus</td><td>向拥有键盘输入焦点的元素添加样式。</td></tr><tr><td>:hover</td><td>当鼠标悬浮在元素上方时，向元素添加样式。</td></tr><tr><td>:link</td><td>向未被访问的链接添加样式。</td></tr><tr><td>:visited</td><td>向已被访问的链接添加样式。</td></tr><tr><td>:first-child</td><td>向元素的第一个子元素添加样式。</td></tr><tr><td>:lang</td><td>向带有指定 lang 属性的元素添加样式。</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: <span class="number">#FF0000</span>&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: <span class="number">#00FF00</span>&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: <span class="number">#0000FF</span>&#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;a href="/index.html" target="_blank"&gt;这是一个链接。&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><blockquote><p>参考：<a href="https://www.w3school.com.cn/css/css_pseudo_elements.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css/css_pseudo_elements.asp</a></p></blockquote><p>伪元素为不存在的元素，用于向某些选择器设置特殊效果，是一种灵活的表现形式。</p><p><img src="/image/css_weiyuansu.png" alt=""></p><table><thead><tr><th>伪元素</th><th>描述</th></tr></thead><tbody><tr><td>:first-letter</td><td>向文本的第一个字母添加特殊样式。</td></tr><tr><td>:first-line</td><td>向文本的首行添加特殊样式。</td></tr><tr><td>:before</td><td>在元素之前添加内容。</td></tr><tr><td>:after</td><td>在元素之后添加内容。</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;p&gt;This is a paragraph in an article。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><p>通配符选择器用 * 来适配所有元素，将CSS样式应用于所有HTML元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器的组合方式"><a href="#选择器的组合方式" class="headerlink" title="选择器的组合方式"></a>选择器的组合方式</h2><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><blockquote><p>参考：<a href="https://www.w3school.com.cn/css/css_selector_descendant.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css/css_selector_descendant.asp</a></p></blockquote><p>后代选择器可以定位某元素后代的元素。后代选择器有一个易被忽视的方面，即两个元素之间的层次间隔可以是无限的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>:black;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:blue;&#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;p&gt;这个段落为黑色&lt;/p&gt;</span><br><span class="line">&lt;h1&gt;这个表示为黑色，&lt;em&gt;我是红色&lt;/em&gt;&lt;/h1&gt;</span><br><span class="line">&lt;p class="parent"&gt;这个表示为黑色，&lt;em&gt;我是蓝色&lt;/em&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><blockquote><p>参考：<a href="https://www.w3school.com.cn/css/css_selector_child.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css/css_selector_child.asp</a></p></blockquote><p>子元素选择器可以定位某元素的子元素。与后代选择器不同的是，层次间隔不是无限的，不作用于子元素，不作用于孙元素。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// css</span><br><span class="line"><span class="selector-tag">h1</span> &gt; <span class="selector-tag">strong</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line">// html</span><br><span class="line">&lt;h1&gt;黑色&lt;strong&gt;红色&lt;/strong&gt;&lt;strong&gt;红色&lt;/strong&gt;黑色&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;黑色&lt;em&gt;黑色&lt;strong&gt;黑色&lt;/strong&gt;&lt;/em&gt;黑色&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h4><blockquote><p>参考：<a href="https://www.w3school.com.cn/css/css_selector_adjacent_sibling.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css/css_selector_adjacent_sibling.asp</a></p></blockquote><p>相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素</span><br><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">p</span> &#123;<span class="attribute">margin-top</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器特性"><a href="#选择器特性" class="headerlink" title="选择器特性"></a>选择器特性</h2><h4 id="选择器分组"><a href="#选择器分组" class="headerlink" title="选择器分组"></a>选择器分组</h4><p>对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">--</span> 所有标题元素都设置为绿色 <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>选择器分组语法，作用于所有类型的选择器：元素选择器、id选择器、类选择器、属性选择器。</p></blockquote><h4 id="选择器继承"><a href="#选择器继承" class="headerlink" title="选择器继承"></a>选择器继承</h4><p>子元素从父元素继承属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">--</span> <span class="selector-tag">body</span>元素将使用<span class="selector-tag">Verdana</span>字体。通过<span class="selector-tag">CSS</span>继承，子元素将继承最高级元素所拥有的属性 <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">--</span> 子元素诸如<span class="selector-tag">p</span>、<span class="selector-tag">td</span>、<span class="selector-tag">ul</span>、<span class="selector-tag">ol</span>、<span class="selector-tag">ul</span>、<span class="selector-tag">li</span>、<span class="selector-tag">dl</span>、<span class="selector-tag">dt</span>、<span class="selector-tag">dd</span>，不需要另外的规则，都应该显示<span class="selector-tag">Verdana</span>字体 <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Verdana, sans-serif;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><ul><li>CSS 优先规则1： 最近的祖先样式比其他祖先样式优先级高。</li><li>CSS 优先规则2：”直接样式”比”祖先样式”优先级高。</li><li>CSS 优先规则3：优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器<ul><li>ID 选择器， 如 <code>#id{}</code></li><li>类选择器， 如 <code>.class{}</code></li><li>属性选择器， 如 <code>a[href=&quot;segmentfault.com&quot;]{}</code></li><li>伪类选择器， 如 <code>:hover{}</code></li><li>伪元素选择器， 如 <code>::before{}</code></li><li>标签选择器， 如 <code>span{}</code></li><li>通配选择器， 如 <code>*{}</code></li></ul></li><li>CSS 优先规则4：当一个标签同时被多个选择符选中，我们便需要确定这些选择符的优先级。我们用如下规则进行确定。计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断。</li><li>CSS 优先规则5：属性后插有 !important 的属性拥有最高优先级。如：<code>p {background: red !important;}</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>年度总结-2019</title>
      <link href="/2020/01/24/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-2019/"/>
      <url>/2020/01/24/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-2019/</url>
      
        <content type="html"><![CDATA[<h2 id="今年到底干了啥？"><a href="#今年到底干了啥？" class="headerlink" title="今年到底干了啥？"></a>今年到底干了啥？</h2><ul><li>职业发展<ul><li>工作<ul><li>搜车之星</li><li>Pakun：工程辅助系统</li><li>Mista：H5通用容器框架</li><li>移山：架构升级项目</li></ul></li><li>搜车渡劫<ul><li>分清工作、生活的边界，好好生活，好好成长，好好工作。</li></ul></li></ul></li><li>财务状况<ul><li>没有买房，原来买房的态度比较激进，现在不盲目了，理性对待、理性摇号；</li></ul></li><li>休闲娱乐<ul><li>日本旅行【5天】：体验了日本的文化氛围；</li><li>云南旅行【4天】：玉龙雪山和蓝月湖还是挺壮观的自然风光；</li><li>宁波旅行【1天】：自驾游排头兵，诺丁汉的草坪舒服的；</li><li>上海旅行【1天】：上海读书馆一日游，百分号的拿铁很润；</li><li>良渚旅行【1天】：逛了一圈晓书馆，找到了最适合自己的旅游方式 - code everwhere；</li><li>五月天-人生无限公司【1天】：我不怕千万人阻挡、只怕自己投降；我和我最后的倔强、握紧双手绝对不放；下一站是不是天堂、就算失望 不能绝望；</li></ul></li><li>个人成长<ul><li>技术<ul><li>Android知识系统梳理，补全所有Android常用知识点，并对Gradle构建体系、Android底层系统架构有深入研究，达到了Android高级+的水平。</li><li>Node后端技术学习，并实践产出 Pakun服务，达到了Node中级水平；</li><li>Vue前端技术学习，并实践产出 TrompeLesprit 站点，达到了Vue入门级水平；</li><li>宣讲、画图以及PPT：做架构，蛮能提升自己的宣讲能力的，PPT技巧又算是入门了；</li></ul></li><li>书籍<ul><li>枪炮、细菌与钢铁：跳出技术人的思维角度，看看人类历史，了解社会的起源。对于 冠状病毒，也有了宏观的见解；</li><li>黑客与画家：程序员和画家类似，是实践性工作，需要大量的练习来提高自己的技艺；</li><li>干法：对工作有了新的认知，重新热爱上了软件开发这个职业；</li><li>时间的秩序：量子力学角度讲解时间，活在当下，体验生活，感受生活；</li><li>漫画中国史：蛮有意思的历史小品，漫画不错；</li><li>硅谷增长黑客实战笔记：如何精细化软件运营，了解了运营的工作内容；</li><li>咖啡咖啡处处开：懂得咖啡的品种，制作流程，以及各类咖啡的制作方式，最近喝咖啡有点上瘾；</li><li>心法：尽人事，待天命；做人一定要有信仰；活着是为了成就更好的自己；</li><li>阿米巴经营：没有团队，就别看什么管理书籍了，纸上谈兵一点儿都不使用；</li><li>架构漫谈，对架构有了更深刻的理解，但目前还处于预实践阶段，需要大量的架构实践来印证自己的想法。实践万岁，回归业务；</li><li>OKR工作法：制定有挑战的目标，分阶段逐步完成；</li><li>智能时代：大数据和智能革命重新定义未来；</li><li>人生-路遥：人间最贵是真情；</li></ul></li><li>自我管理<ul><li>疯狂高中计划：坚持5个月，每天早上6点起床看书。缺点是目标制定严格，前期太过用力，导致后期跟进发力；</li><li>星级计划：疯狂高中计划的升级版，更加柔和了，目标完成质量也没有下降，希望能够找到更加舒服的打怪升级方式；</li></ul></li></ul></li><li>身体健康<ul><li>羽毛球【每周】：运动量应该换一个度量单位，时间来度量缺乏可控标准；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>读书笔记-枪炮、病菌与钢铁：人类社会的命运</title>
      <link href="/2020/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9E%AA%E7%82%AE%E3%80%81%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%EF%BC%9A%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90/"/>
      <url>/2020/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9E%AA%E7%82%AE%E3%80%81%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%EF%BC%9A%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90/</url>
      
        <content type="html"><![CDATA[<p><img width="300" src="/image/qiangpao.jpg" style="margin: 0 auto;"></p><h2 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h2><p>本书宏观地讲解了人类社会的发展史。人类以非洲为源点，扩展到全世界各个地区。世界的历史就是一部征服史，征服成功的三要素是枪炮、病菌与钢铁。想了解我们的世界是如何变成今天的世界么，那看下这本书吧。</p><p>本书带来的一些启发性的思考：</p><ul><li>让人跳出技术人的思维角度，看看人类历史，了解社会的起源。</li><li>让人跳出现代社会的上下文，从上帝视角来游览整个世界的发展进程，看看世界，了解世界。</li><li>了解病菌的起源，原来人类已经和病菌抗争了数万年。现在的冠状病毒其实就是人类历史上的千千万万病菌中的一个而已。</li><li>让我们能够更加珍惜生活，珍惜时光。</li></ul><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>在人类社会发展史上，中国对整个亚洲的印象是非常巨大的。我们长期占据了主导地位。身为中国人的骄傲！</p><p>地理位置影响农作物的发展与传播。农业生产粮食，有了充足的粮食之后，能过上定居生活，能养殖牲畜，能展手工艺人，产生复杂的社会关系体系。逐渐与狩猎民族拉开差距。</p><h2 id="金句摘录"><a href="#金句摘录" class="headerlink" title="金句摘录"></a>金句摘录</h2><ul><li><p>动植物的驯化意味着人类的粮食越来越多，因而也就意味着人口越来越稠密。因此而带来的粮食剩余和（在某些地区）利用畜力运输剩余粮食，成了定居的、行政上集中统一的、社会等级分明的、经济上复杂的、技术上富有革新精神的社会的发展的先决条件。因此，能否利用驯化的动植物，最终说明了为什么帝国、知书识字和钢铁武器在欧亚大陆最早发展起来，而在其他大陆则发展较晚，或根本没有发展起来。</p></li><li><p>每个大陆上最早一批的农民是不可能有意识地去选择农业的，因为他们没有看到过他们的附近有任何别的农民。然而，粮食生产一旦在某个大陆的某个部分出现，邻近的狩猎采集族群就能看到粮食生产的结果，从而作出有意识的决定。在某些情况下，这些狩猎采集族群几乎是全盘接受了邻近的粮食生产制度；在另一些情况下，他们只选择其中的某些成分；在还有一些情况下，他们则是完全拒绝粮食生产，而继续做以狩猎采集为生的人。</p></li><li><p>各大陆民族长期历史之间的显著差异，不是源自这些民族本身的天生差异，而是源自他们环境的差异。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>读书笔记-黑客与画家</title>
      <link href="/2020/01/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"/>
      <url>/2020/01/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><ul><li>编程是一门技术活，作为手艺人，需要将他融入我们的血液里。花上长年累月的时间，将各种编程技法成为身体记忆。刻意学习，让软件设计融入我们的血液中。</li><li>每种语言都有他的特点，需要尝试新的编程语言，扩充自己的知识面。</li></ul><h2 id="金句摘录"><a href="#金句摘录" class="headerlink" title="金句摘录"></a>金句摘录</h2><ul><li><p><strong>为什么书呆子不受欢迎</strong>：小孩子的自身价值观还没有完全形成。团结起来去欺负其他人，是一些弱者来权衡自我价值的表现。</p></li><li><p><strong>黑客与画家</strong>：黑客，是软件设计师，制作软件，并产生社会价值。工程师，是技工，职责是将产品经理的构想翻译成代码。黑客，不像是科学家，而是像画家。从实践中学习总结成长，通过阅读别人的源代码，临摹代码来提高技术水平。编写程序，就像绘画。一开始先打个草稿，然后在不断优化。在编程中，也不存在先设计一个完美的架构，再进行编码开发。架构，是在不断优化的。过早优化，和过早设计一样是危险的事。</p></li><li><p><strong>另一条路</strong>：桌面软件需要发版，动态性上来讲，远远没有互联网软件的优势明显。前端开发有很大的优势。将复杂计算放到后台执行，前端制作展示，在5G时代会更加的普及。当我们做一个方案规划时，最好将大体方向确定下来之后，就开始动手构思开发，而不是把它放到我们的计划中，或者需要规划出一套完美的方案之后再动手。因为构思这个东西有一个特点，那就是他会导致更多的构思。如果将一个构思束之高阁，不仅会延迟他的实现，还以为这延迟所有实现过程中激发的构思。</p></li><li><p><strong>如何创造财富</strong>：这个世界的财富，不是恒定不变的，而是可以不断创造的。亨利福特发明了汽车，你可以购买拖拉机来代替牛马来犁地。社会因为拖拉机的发明，变得更加富有了。</p></li><li><p><strong>编程语言解析</strong>：如果你长期使用某种语言，你就会慢慢按照这种语言的思维模式进行思考。所以，后来当你遇到其他任何一种有重大差异的语言，即使那种语言本身并没有任何不对的地方，你也会觉得它极其难用。缺乏经验的程序员对于各种语言优缺点的判断经常被这种心态误导。可能因为想炫耀自己见多识广，某些黑客会告诉你所有高级语言基本相似。“你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。”这当然是一派胡言。各种语言简直是天差地别。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>读书笔记-干法</title>
      <link href="/2020/01/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B2%E6%B3%95/"/>
      <url>/2020/01/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B9%B2%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>看完稻盛和夫的干法，感觉他以身作则诠释了“奉献一生”。并沉迷于此。</p><ul><li>热爱工作，你会得到工作上的回报，从而你会更加热爱工作，形成一个正向的激励循环。</li><li>人们渴望通过修行，磨练自己的人格，成为更好的自己。那为什么不通过工作来磨练自己呢？毕竟，我们一生将投入大量的时间来工作。</li><li>除了热爱工作，我们别无他法。因为热爱工作能带来个人高速成长，能提高自己的个人竞争力。而不热爱工作，我们将逐渐被社会淘汰。</li><li>有时候坚持的力量是巨大的。从一点一滴做起，坚持不懈，就能达成远大的目标。</li></ul><h2 id="金句摘录"><a href="#金句摘录" class="headerlink" title="金句摘录"></a>金句摘录</h2><ul><li><p>工作就是提升心智，磨练人格的修行，这样说并不过分。凡是功成名就的人毫无例外的都是不懈努力，历尽艰辛，埋头于自己的事业，才取得了巨大成就。通过艰苦卓越的努力，在成就伟大功绩的同时，他们也造就了自己完美的人格。</p></li><li><p>不管是顺境也好，逆境也好，不管自己处在任何境遇，都要抱着积极的心态朝前看，任何时候都要拼命工作，持续努力，这才是最重要的。</p></li><li><p>全神贯注于自己的工作，只要做到这一点，就可以磨练自己的灵魂，铸就美好的心灵。有了美好的心灵，就会很自然的去想好事，做好事，为社会为、为他人着想，并落实在行动中，你的命运就一定会向好的方向转变。</p></li><li><p>应该迷恋工作、热爱工作、拥抱工作。人就是这样，对于自己喜欢的事情，再辛苦也无怨言，也能忍受。而只要忍受艰苦、不懈努力，任何事情就都能成功。喜欢自己的工作–仅仅这一条就能决定人的一生，我想这么说一点也不过分。要想拥有一个充实的人生，你只有两种选择：一种是“从事自己喜欢的工作”，另一种则是“让自己喜欢上工作”。一个人能够看上自己喜欢的工作的概率，恐怕不足千分之一、万分之一。而且，即使进了自己所期望的公司，要能分配到自己所期望的职位、从事自己所期望的工作，这样幸运的机会几乎没有。</p></li><li><p>“热爱工作”、“把工作当乐趣”，话虽这么说，但做起来，就像僧人艰苦修行一样，并非易事。所以，若只是当苦行僧，一味强调吃苦耐劳而没有快乐，那也很难持之以恒。我的经验是，当研究工作进展顺利时，就要直率的表达出快乐；当研究成果受到别人的夸奖时，就要诚挚地表示感谢。继而将这种喜悦和感动当做精神食粮，然后继续投入艰苦工作。抓住机会，奖励和犒劳自己。</p></li><li><p>专心致志于一行一业，不耐烦，不焦躁，埋头苦干，不屈服于任何困难，坚持不懈。只要你坚持这样做，就能造就优秀的人格，而且会让你的人生开出美丽的鲜花，结出丰硕的果实。</p></li><li><p>加倍努力，辛苦钻研，一直拼命的工作。正是在这样的过程中，他们塑造了自己高尚的人格。不像豹子那样行动迅猛，而是像牛一样，只是笨拙的，愚直的，坚持的专注于一行一业。这样不断努力的结果，让他们不仅提升的能力，而且磨炼了人格，造就了高尚美好的人生。</p></li><li><p>看起来平凡不起眼的工作，却能坚韧不拔地去做，坚持不懈的去做，这种“持续的力量”才是事业成功，最重要的基石，才体现了人生的价值，才是真正的能力。</p></li><li><p>纵使是自不量力的梦想，是看似高不可攀的目标，还是要在胸中牢牢立下这个目标，并坚持不懈地在同仁面前展示这个目标。这一点非常重要。纵使是自不量力的梦想，是看似高不可攀的目标，还是要在胸中牢牢立下这个目标，并坚持不懈地在同仁面前展示这个目标。因为人本来就具备使梦想成真的巨大潜力。</p></li><li><p>遭遇失败和苦难的时候，不应牢骚满腹，不要怨天尤人，而是要忍受考验，坚持努力，一点点积累小小的，然而是确凿的成功，最后将逆境转化为顺境。在成功和幸运的时候，要不骄不躁，抱着真诚的感谢之心，仍继续坚持努力，使成功得以长期持续。</p></li><li><p>苦难不会没完没了，当然幸运也不会永远持续。得意时不忘形，失意时不消沉，每天每日勤奋工作，这比什么都重要。</p></li><li><p>自创业起经过了约20年，针对持续高成长、高收益的京瓷公司，同时针对我这个掌舵人，许多媒体的朋友都提出了这样的疑问：“你到底为了什么还要如此拼命地工作？”不仅是媒体，连亲戚朋友们也追问我：“你在短短20年间创建了如此优秀的企业，销售额已经达到几千亿日元，利润已经达到几百亿日元，从利润额来看，即使在日本的电器厂商中也已经名列前茅。已经取得了如此卓越的成就，你到现在仍然废寝忘食、拼命工作，让自己稍微轻松一点不好吗？你这么干的目的究竟是什么？”还有人说得更难听，他们讽刺说：“已经赚了几百个亿，还不知满足，真是一个贪得无厌的人！”然而，我工作的目的既不是为了我自己的利益，也不是为了京瓷公司的利益。记得当时，对媒体、对熟人和朋友，我说了这么一段话：“驱使我想要提升公司业绩的原动力只有一个，就是希望员工们在未来的日子里，永远生活安定、永远幸福。为了打好这个基础，就要提升销售额、确保利润。”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端-Vue组件生命周期</title>
      <link href="/2020/01/01/%E5%89%8D%E7%AB%AF-Vue%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/01/01/%E5%89%8D%E7%AB%AF-Vue%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p><img width="900" src="/image/vue_lifecycle.png"></p><h2 id="组件实例化期"><a href="#组件实例化期" class="headerlink" title="组件实例化期"></a>组件实例化期</h2><p><strong>组件创建前后</strong></p><ul><li>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</li><li>create：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</li></ul><p><strong>组件挂载前后</strong></p><ul><li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。$el 属性已经可见，但还是原来的 DOM，并非是新创建的。</li><li>mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li></ul><h2 id="组件存在期"><a href="#组件存在期" class="headerlink" title="组件存在期"></a>组件存在期</h2><p><strong>组件数据更新前后</strong></p><ul><li>beforeUpdate：数据更新时，虚拟 DOM 变化之前调用，这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li><li>updated：数据更新和虚拟 DOM 变化之后调用。</li></ul><h2 id="销毁期"><a href="#销毁期" class="headerlink" title="销毁期"></a>销毁期</h2><p><strong>组件销毁前后</strong></p><ul><li>beforeDestroy：实例销毁之前调用，在这一步，实例仍然完全可用。一般在这里移除事件监听器、定时器等，避免内存泄漏。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cde19cee51d453a572aa307" target="_blank" rel="noopener">https://juejin.im/post/5cde19cee51d453a572aa307</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端-CSS布局那些事</title>
      <link href="/2020/01/01/%E5%89%8D%E7%AB%AF-CSS%E5%B8%83%E5%B1%80%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2020/01/01/%E5%89%8D%E7%AB%AF-CSS%E5%B8%83%E5%B1%80%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>文档流是文档中可显示对象在排列时所占用的位置。将窗体自上而下分成一行行显示，并在每行中按从左到右的顺序排放元素的效果，就是文档流直观的表现。</p><h2 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h2><ul><li>块级元素（block elements）：支持width、height、padding、border与margin，排列方式是垂直排列</li><li>行内元素（inline elements）：不width、height、padding、border与margin，排列方式是水平排列</li><li>行内块元素（inline-block elements）：内部表现类似block元素，支持block元素的width、height、padding、border与margin；而外部排列类似行内元素，即水平排列</li></ul><h2 id="display介绍"><a href="#display介绍" class="headerlink" title="display介绍"></a>display介绍</h2><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// html布局</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span>内容为block的展示方式<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">// css类型</span><br><span class="line">.block &#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用类型说明"><a href="#常用类型说明" class="headerlink" title="常用类型说明"></a>常用类型说明</h4><ul><li>none：此元素不会被显示。</li><li>block：此元素将显示为块级元素，此元素前后会带有换行符。</li><li>Inline：默认。此元素会被显示为内联元素，元素前后没有换行符。</li><li>inline-block：行内块元素。（CSS2.1 新增的值）</li><li>Inherit：规定应该从父元素继承 display 属性的值</li></ul><p><a href="https://www.w3school.com.cn/cssref/pr_class_display.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/cssref/pr_class_display.asp</a></p><h2 id="position介绍"><a href="#position介绍" class="headerlink" title="position介绍"></a>position介绍</h2><h4 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// html布局</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span>位置为relative的排列方式<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">// css类型</span><br><span class="line">.relative &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用类型说明-1"><a href="#常用类型说明-1" class="headerlink" title="常用类型说明"></a>常用类型说明</h4><ul><li>absolute：生成绝对定位的元素，相对于第一个父元素进行定位。</li><li>relative：生成相对定位的元素，相对于其正常位置进行定位。</li><li>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。ps，此元素不在不被排列在文档流中。</li></ul><p><a href="https://www.w3school.com.cn/cssref/pr_class_position.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/cssref/pr_class_position.asp</a><br><a href="https://www.cnblogs.com/paulwhw/p/9199682.html" target="_blank" rel="noopener">https://www.cnblogs.com/paulwhw/p/9199682.html</a></p><h2 id="z-index介绍"><a href="#z-index介绍" class="headerlink" title="z-index介绍"></a>z-index介绍</h2><h4 id="举例说明-2"><a href="#举例说明-2" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// html布局</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"zindex"</span>&gt;</span>z坐标很高哦<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">// css类型</span><br><span class="line">.zindex &#123;</span><br><span class="line">    z-index: 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用类型说明-2"><a href="#常用类型说明-2" class="headerlink" title="常用类型说明"></a>常用类型说明</h4><ul><li>z-index：设置一个定位元素沿z轴的位置，数字越大，则离用户更近。支持负数。</li></ul><p><a href="https://www.w3school.com.cn/cssref/pr_pos_z-index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/cssref/pr_pos_z-index.asp</a></p><h2 id="Flex介绍"><a href="#Flex介绍" class="headerlink" title="Flex介绍"></a>Flex介绍</h2><p>Flex布局由flex容器（flex container）以及在容器中的flex元素（flex item）组成。整个Flex布局结构如下：<br><img width="600" src="/image/flex_概览.png"><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。项目默认沿主轴排列。</p><h4 id="举例说明-3"><a href="#举例说明-3" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// html布局</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span></span><br><span class="line">        flex-item</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// css类型</span><br><span class="line">.flex &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: row;</span><br><span class="line">    flex-wrap: nowrap;</span><br><span class="line">    justify-content: flex-start;</span><br><span class="line">    align-items: center;</span><br><span class="line">    align-content: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-item &#123;</span><br><span class="line">    order: 1;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    flex-basis: 40px;</span><br><span class="line">    align-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flex容器属性介绍"><a href="#flex容器属性介绍" class="headerlink" title="flex容器属性介绍"></a>flex容器属性介绍</h4><ul><li>flex-direction：主轴方向，决定元素的排列方向。<ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul></li><li>flex-wrap：如果一条轴线排不下，如何换行。<ul><li>nowrap（默认）：不换行。</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ul></li><li>justify-content：定义了项目在主轴上的对齐方式。<ul><li>flex-start（默认值）：左对齐。</li><li>flex-end：右对齐。</li><li>center： 居中。</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li>align-items：定义项目在交叉轴上如何对齐。<ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></li><li>align-content：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul></li></ul><h4 id="flex元素属性介绍"><a href="#flex元素属性介绍" class="headerlink" title="flex元素属性介绍"></a>flex元素属性介绍</h4><ul><li>order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。默认值为auto，即项目的本来大小。</li><li>align-self：允许单个元素有的对齐方式，覆盖align-items属性。默认继承父元素的align-items属性。</li></ul><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>读书笔记-时间的秩序</title>
      <link href="/2019/12/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%97%B6%E9%97%B4%E7%9A%84%E7%A7%A9%E5%BA%8F/"/>
      <url>/2019/12/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%97%B6%E9%97%B4%E7%9A%84%E7%A7%A9%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>这本书，主要讲解了时间的物理概念。从客观的角度讲解了时间这个度量单位。</p><h3 id="时间统一性的消失"><a href="#时间统一性的消失" class="headerlink" title="时间统一性的消失"></a>时间统一性的消失</h3><p>时间的流失，在山上要比平原要快快。引力可以对时间产生影响。地球存在一个巨大的引力场，能够对时间产生影响，让时间慢下来。因此，距离地球越近，时间越慢。将两块相同的表分别在高山和平原，过段时间发现两块表的时间产生了偏差，这就是引力带来的时间差变化。</p><p><img src="/image/time_order_1.png" alt=""></p><h3 id="时间与空间"><a href="#时间与空间" class="headerlink" title="时间与空间"></a>时间与空间</h3><p>时间、空间、电磁还有引力，这些场交织在一起的，相互影响。所以不存在独立的时间，时间是一个可变的衡量单位。就像速度一样可快可慢，时间也是有长有短的。</p><h3 id="方向的消失"><a href="#方向的消失" class="headerlink" title="方向的消失"></a>方向的消失</h3><p>“现在”与“过去”的定义，只是个幻觉。是我们根据自身经验做出的推断。时间的流失带来的，只是“熵”的增大，混乱程度的变大。</p><h3 id="当下的消失"><a href="#当下的消失" class="headerlink" title="当下的消失"></a>当下的消失</h3><p>引力会影响时间。高山的时间与平原的时间是有差异的。速度也会影响时间，运动物体的时间和静止物体的时间也是有差异的。因此，从物理角度上看，不存在完全相同的时间。因为人的感知敏捷度有限，一般认为在1/10秒内的时间差是无感知的。所以，在整个地球上，我们认为是大家处于同一时间。</p><h3 id="世界的运转"><a href="#世界的运转" class="headerlink" title="世界的运转"></a>世界的运转</h3><p>世界运转需要的不是能量而是低熵。能量都会把自己转化为热量，他会传递到冷的物体上。但，想要把它取回来，重新用来让植物生长，或驱动发动机，这样的免费方式是不存在的。<br>让世界运转的不是能量，而是低熵源。没有低熵，能量会稀释成相同的热量，世界会在热平衡态中睡去。<br>在地球附近，我们有着丰富的低熵源–太阳。太阳给我们送来炙热的光子，然后地球向黑暗的天空，发射冷的光子。输入的能量与输出的能量大致一致，在交往过程中，我们并没有得到能量。对于每一个到来的热光子，地球会发射十个冷光子，因为来自太阳的一个热光子与地球发射的十个冷光子，具有相同的能量。一个热光次比十个冷光子，具有更低的熵，因为一个热光子的数量比十个冷光子数量要少。因而，太阳对我们而言，是个丰富且持续不断低熵源。我们拥有充足的低熵可以使用，能够让动植物生长，让我们建造汽车与城市，以及思考和写书。</p><h3 id="感触"><a href="#感触" class="headerlink" title="感触"></a>感触</h3><p>时间是一个度量单位，可长可短。但我们在这世上能够感受生活的时间长度是一样的。好好感受生活吧。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>读书笔记-硅谷增长黑客实战笔记</title>
      <link href="/2019/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A1%85%E8%B0%B7%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A1%85%E8%B0%B7%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是增长黑客"><a href="#什么是增长黑客" class="headerlink" title="什么是增长黑客"></a>什么是增长黑客</h2><p><strong>增长黑客</strong>，指的是<strong>创业型团队在数据分析基础上，利用产品或技术手段来获取自发增长的运营手段</strong>。说通俗一点，一家初创公司或者大中型公司内部针对新产品线而诞生的创业型团队，以数据驱动营销，以市场指导产品，通过低成本的手段解决公司产品早期增长问题。</p><h2 id="增长转化节点"><a href="#增长转化节点" class="headerlink" title="增长转化节点"></a>增长转化节点</h2><p><img src="/image/zengzhang_2.png" alt=""></p><h2 id="增长实验流程"><a href="#增长实验流程" class="headerlink" title="增长实验流程"></a>增长实验流程</h2><p><img width="400" src="/image/zengzhang_1.png"></p><h2 id="什么是A-B测试"><a href="#什么是A-B测试" class="headerlink" title="什么是A/B测试"></a>什么是A/B测试</h2><p>当进行A/B测试时，通常会采用两个（或多个）组：A组和B组。第一个组是对照组，第二个组会改变其中一些因素。就以着陆页优化为例，A组会展示现有的着陆页，B组会展示一个内容或者内容作了某些修改的新着陆页。A/B测试的目的就是尝试了解新的布局是否在统计上显著地改变了转化率。</p><h2 id="增长计划书上的核心指标"><a href="#增长计划书上的核心指标" class="headerlink" title="增长计划书上的核心指标"></a>增长计划书上的核心指标</h2><h4 id="方向标：北极星指标"><a href="#方向标：北极星指标" class="headerlink" title="方向标：北极星指标"></a>方向标：北极星指标</h4><p>北极星指标就像北极星一样，高高闪耀在空中，指引着全公司所有人员向着同一个方向迈进。</p><h4 id="路线图：增长模型"><a href="#路线图：增长模型" class="headerlink" title="路线图：增长模型"></a>路线图：增长模型</h4><p>增长模型的精髓是将生意提炼和总结成一个数学公式，从而帮助你用全面、简单和结构化的方式去思考增长。</p><p><strong>社交平台增长模型</strong><br><img width="600" src="/image/zengzhang_3.png"></p><h4 id="仪表盘：关键指标看板"><a href="#仪表盘：关键指标看板" class="headerlink" title="仪表盘：关键指标看板"></a>仪表盘：关键指标看板</h4><p>关键行为漏斗：采用一个分级分步的方法，先定义出最重要的少数几个时间进行追踪。然后再做其次重要的事件。这样的好处是循序渐进，很快就可以得到最重要的数据。也能够看到用户在漏斗的每一步有多少流失。</p><p><strong>社交平关键指标看板</strong><br><img width="1200" src="/image/zengzhang_4.png"></p><h4 id="参考书：用户心理决策地图"><a href="#参考书：用户心理决策地图" class="headerlink" title="参考书：用户心理决策地图"></a>参考书：用户心理决策地图</h4><p><img width="700" src="/image/zengzhang_5.png"></p><h2 id="增长、产品、运营的区别和关系"><a href="#增长、产品、运营的区别和关系" class="headerlink" title="增长、产品、运营的区别和关系"></a>增长、产品、运营的区别和关系</h2><h4 id="增长和产品"><a href="#增长和产品" class="headerlink" title="增长和产品"></a>增长和产品</h4><p>产品是价值创造，而增长是在向更多的人传播价值。产品团队的目标是增加产品的价值，而增长团队则是帮助更多的用户能够最大限度的体验产品的现有价值，或者尽可能地去除妨碍用户体验价值的各种障碍。</p><h4 id="增长和营销"><a href="#增长和营销" class="headerlink" title="增长和营销"></a>增长和营销</h4><p>传统的营销更多地关注新用户的获取，而增长则着眼于AARRR的整个用户生命周期。营销团队一般无权过问产品规划图，也没有和程序员及产品设计师合作的经验和能力。而增长团队则打破了营销和产品之间的藩篱，他们有能力、有经验开发和优化产品内的增长机制。</p><p><img width="700" src="/image/zengzhang_6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>读书笔记-咖啡咖啡处处开</title>
      <link href="/2019/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%92%96%E5%95%A1%E5%92%96%E5%95%A1%E5%A4%84%E5%A4%84%E5%BC%80/"/>
      <url>/2019/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%92%96%E5%95%A1%E5%92%96%E5%95%A1%E5%A4%84%E5%A4%84%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<p><img src="/image/caffe_bg.jpg" alt=""></p><p>一直以来对咖啡还是蛮有兴趣的。乘着这段时间，工作不是很忙，补一下咖啡知识的短板。</p><h2 id="咖啡果：从种子到果实"><a href="#咖啡果：从种子到果实" class="headerlink" title="咖啡果：从种子到果实"></a>咖啡果：从种子到果实</h2><p>咖啡树是多年生植物，成年后每年都会结咖啡果，咖啡果里的种子就是我们所说的咖啡豆。咖啡豆经过脱胶、水洗和干燥之后，成为颜色发绿的咖啡生豆，可进一步用于烘焙，最终用来制作饮品。 </p><p>咖啡豆品种</p><ul><li>铁比卡</li><li>波旁</li><li>卡杜拉</li><li>新世界</li><li>卡杜阿伊</li><li>瑰夏</li><li>等等…</li></ul><h2 id="咖啡豆的处理过程"><a href="#咖啡豆的处理过程" class="headerlink" title="咖啡豆的处理过程"></a>咖啡豆的处理过程</h2><ul><li>日晒法：去除浮豆 -&gt; 日晒 -&gt; 去除外壳</li><li>水洗法：去除浮豆 -&gt; 去除果皮和果肉 -&gt; 发酵 -&gt; 水洗 -&gt; 干燥与去除内果皮和银皮</li><li>半水洗法：去除浮豆 -&gt; 去除果皮 -&gt; 去除果胶 -&gt; 干燥</li><li>蜜处理法：去除浮豆 -&gt; 去除果皮 -&gt; 干燥 -&gt; 去除果肉和银皮 </li></ul><h2 id="烘焙：醇香美味诞生的前奏"><a href="#烘焙：醇香美味诞生的前奏" class="headerlink" title="烘焙：醇香美味诞生的前奏"></a>烘焙：醇香美味诞生的前奏</h2><p><strong>咖啡豆在烘焙过程中的变化情况</strong></p><p><img src="/image/caffe_hongpei.png" alt=""></p><h2 id="咖啡品类"><a href="#咖啡品类" class="headerlink" title="咖啡品类"></a>咖啡品类</h2><p><img src="/image/coffe_type_1.jpg" alt=""><br><img src="/image/coffe_type_2.jpg" alt=""><br><img src="/image/coffe_type_3.jpg" alt=""><br><img src="/image/coffe_type_4.jpg" alt=""><br><img src="/image/coffe_type_5.jpg" alt=""><br><img src="/image/coffe_type_6.jpg" alt=""><br><img src="/image/coffe_type_7.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-Kotlin语法学习</title>
      <link href="/2019/10/29/Android-Kotlin%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/29/Android-Kotlin%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p><a href="https://www.kotlincn.net/docs/reference/classes.html" target="_blank" rel="noopener">文档</a></p></blockquote><h4 id="概念讲解"><a href="#概念讲解" class="headerlink" title="概念讲解"></a>概念讲解</h4><p>类可以有一个主构造函数以及一个或多个次构造函数。每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托</p><ul><li>主构造函数、次构造函数</li><li>初始化块</li><li>初始化顺序</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 声明类时，支持声明主构造函数</span><br><span class="line">class Person constructor(value1: String) &#123;</span><br><span class="line"></span><br><span class="line">    private var first = &quot;调用：1&quot;.also(::println)</span><br><span class="line"></span><br><span class="line">    // 初始化块</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;调用：2&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private var third = &quot;调用：3&quot;.also(::println)</span><br><span class="line"></span><br><span class="line">    // 次构造函数，需要间接实现主构造函数</span><br><span class="line">    constructor(value1: String, value2: String): this(value1) &#123;</span><br><span class="line">        println(&quot;调用：4&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p><a href="https://www.kotlincn.net/docs/reference/classes.html" target="_blank" rel="noopener">文档</a></p></blockquote><h4 id="概念讲解-1"><a href="#概念讲解-1" class="headerlink" title="概念讲解"></a>概念讲解</h4><ul><li>声明父类</li><li>实现构造方法</li><li>覆盖方法、属性：open、override</li><li>继承类的初始化顺序</li><li>调用父类方法</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// Animal</span><br><span class="line">open class Animal(open val age: Int) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;初始化调用：1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Person继承Animal，并实现主构造函数</span><br><span class="line">open class Person(open val name: String, override val age: Int) : Animal(age) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;初始化调用：2&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open fun run() &#123;</span><br><span class="line">        println(&quot;人会跑步&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Programmer</span><br><span class="line">interface Programmer &#123;</span><br><span class="line">    fun codding()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DaiYibo 继承Person，实现Programmer</span><br><span class="line">class DaiYibo : Person, Programmer &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var _skill: String;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;初始化调用：3&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 次构造函数，需主动实现父类构造函数</span><br><span class="line">    constructor(skill: String) : super(&quot;daiyibo&quot;, 18) &#123;</span><br><span class="line">        println(&quot;初始化调用：4&quot;)</span><br><span class="line">        this._skill = skill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 覆盖Person方法</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        // 调用父类方法</span><br><span class="line">        super.run()</span><br><span class="line">        println(&quot;daiyibo 跑的非常快&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现Programmer接口方法</span><br><span class="line">    override fun codding() &#123;</span><br><span class="line"></span><br><span class="line">        println(&quot;daiyibo 会敲代码【$_skill】&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p><a href="https://www.kotlincn.net/docs/reference/interfaces.html" target="_blank" rel="noopener">文档</a></p></blockquote><h4 id="概念讲解-2"><a href="#概念讲解-2" class="headerlink" title="概念讲解"></a>概念讲解</h4><ul><li>声明接口</li><li>实现接口</li><li>声明接口属性</li><li>接口方法调用</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line"></span><br><span class="line">    // 抽象属性</span><br><span class="line">    val prop: Int</span><br><span class="line"></span><br><span class="line">    // 提供访问器的实现</span><br><span class="line">    val propertyWithImplementation: String</span><br><span class="line">        get() = &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">    // 提供方法foo的默认实现</span><br><span class="line">    fun foo() &#123;</span><br><span class="line">        print(&quot;A&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明bar抽象方法</span><br><span class="line">    fun bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;</span><br><span class="line"></span><br><span class="line">    // 提供方法foo的默认实现</span><br><span class="line">    fun foo() &#123;</span><br><span class="line">        print(&quot;B&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提供方法bar的默认实现</span><br><span class="line">    fun bar() &#123;</span><br><span class="line">        print(&quot;bar&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造方法中声明变量</span><br><span class="line">class C(override val prop: Int) : A &#123;</span><br><span class="line">    override fun bar() &#123;</span><br><span class="line">        print(&quot;bar&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D : A, B &#123;</span><br><span class="line"></span><br><span class="line">    // 初始化A接口中的抽象属性</span><br><span class="line">    override val prop: Int = 0</span><br><span class="line"></span><br><span class="line">    override fun foo() &#123;</span><br><span class="line">        // 指明调用A接口中的方法</span><br><span class="line">        super&lt;A&gt;.foo()</span><br><span class="line">        // 指明调用B接口中的方法</span><br><span class="line">        super&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun bar() &#123;</span><br><span class="line">        // 只有B接口实现此方法，因此不需要指明</span><br><span class="line">        super.bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><blockquote><p><a href="https://www.kotlincn.net/docs/reference/properties.html" target="_blank" rel="noopener">文档</a></p></blockquote><h4 id="概念讲解-3"><a href="#概念讲解-3" class="headerlink" title="概念讲解"></a>概念讲解</h4><ul><li>private：意味着只在这个类内部（包含其所有成员）可见；</li><li>protected：和 private一样 + 在子类中可见。</li><li>internal：能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；</li><li>public：能见到类声明的任何客户端都可见其 public 成员。</li></ul><blockquote><p>模块<br>可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：<br>一个 IntelliJ IDEA 模块；<br>一个 Maven 项目；</p></blockquote><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private fun printPrivate() &#123;</span><br><span class="line">        print(&quot;private&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fun printPublic() &#123;</span><br><span class="line">        print(&quot;public&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    internal fun printInternal() &#123;</span><br><span class="line">        print(&quot;internal&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性与字段"><a href="#属性与字段" class="headerlink" title="属性与字段"></a>属性与字段</h2><blockquote><p><a href="https://www.kotlincn.net/docs/reference/properties.html" target="_blank" rel="noopener">文档</a></p></blockquote><h4 id="完整语法"><a href="#完整语法" class="headerlink" title="完整语法"></a>完整语法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>|<span class="keyword">val</span> [<span class="keyword">lateinit</span>] &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><h4 id="字段意义"><a href="#字段意义" class="headerlink" title="字段意义"></a>字段意义</h4><ul><li>val：声明只读关键字</li><li>var：声明可变关键字</li><li>lateinit：延迟初始化，不能作用于基本类型</li><li>set：声明设值器</li><li>get：声明获值器</li><li>field：幕后字段，只在getter、setter方法中使用，表示当前属性</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name: String = <span class="string">"daiyibo"</span></span><br><span class="line">            <span class="keyword">set</span>(value) &#123;</span><br><span class="line">                field = <span class="string">"<span class="variable">$value</span>..."</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"...<span class="variable">$field</span>"</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">18</span></span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> next: Person</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h2><blockquote><p><a href="https://www.kotlincn.net/docs/reference/properties.html" target="_blank" rel="noopener">文档</a></p></blockquote><h4 id="字段意义-1"><a href="#字段意义-1" class="headerlink" title="字段意义"></a>字段意义</h4><ul><li>可空类型与非空类型</li><li>在条件中检测 null</li><li>安全的调用</li><li>Elvis 操作符</li><li>!! 操作符</li><li>安全的类型转换</li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-AndroidX升级指南</title>
      <link href="/2019/10/14/Android-AndroidX%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/"/>
      <url>/2019/10/14/Android-AndroidX%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="AndroidX-介绍"><a href="#AndroidX-介绍" class="headerlink" title="AndroidX 介绍"></a>AndroidX 介绍</h2><p>AndroidX 是 Android 团队用于在 Jetpack 中开发、测试、打包和发布库以及对其进行版本控制的开源项目。</p><p>AndroidX 对原始 Android <a href="https://developer.android.com/topic/libraries/support-library/index" target="_blank" rel="noopener">支持库</a> 进行了重大改进。与支持库一样，AndroidX 与 Android 操作系统分开提供，并与各个 Android 版本向后兼容。AndroidX 完全取代了支持库，不仅提供同等的功能，而且提供了新的库。此外，AndroidX 还包括以下功能：</p><ul><li>AndroidX 中的所有软件包都使用一致的命名空间，以字符串 androidx 开头。支持库软件包已映射到对应的 androidx.* 软件包。</li><li>与支持库不同，AndroidX 软件包会单独维护和更新。androidx 软件包使用严格的 <a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义版本控制</a> ，从版本 1.0.0 开始。您可以单独更新项目中的 AndroidX 库。</li><li>所有新支持库的开发工作都将在 AndroidX 库中进行。</li></ul><h2 id="如何在老项目中使用AndroidX"><a href="#如何在老项目中使用AndroidX" class="headerlink" title="如何在老项目中使用AndroidX"></a>如何在老项目中使用AndroidX</h2><ul><li><p>首先将所有主工程中依赖的support lib都改成androidX。并将相关引用代码，手动改为androidX的引用。</p></li><li><p>其次，修改当前项目的 gradle.properties文件，添加useAndroidX与enableJetifier字段。</p><blockquote><p>android.useAndroidX=true：表示当前项目启用 AndroidX。<br>android.enableJetifier=true：表示将依赖包也迁移到AndroidX。如果取值为false，表示不迁移依赖包到AndroidX。</p></blockquote>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前项目 gradle.properties</span></span><br><span class="line">android.useAndroidX=<span class="literal">true</span></span><br><span class="line">android.enableJetifier=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h2><p>在gradle 3.2.1以上构建工具中，提供了enableJetifier字段，用于矫正support lib的引入方式。简单分析gradle构建过程，看看enableJetifier是怎么来矫正引入的。</p><h4 id="插入构建任务"><a href="#插入构建任务" class="headerlink" title="插入构建任务"></a>插入构建任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VariantManager.kt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DependencyHandler dependencies = project.getDependencies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (!globalScope.getProjectOptions().get(BooleanOption.USE_ANDROID_X)</span><br><span class="line">                &amp;&amp; globalScope.getProjectOptions().get(BooleanOption.ENABLE_JETIFIER)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"AndroidX must be enabled when Jetifier is enabled. To resolve, set "</span></span><br><span class="line">                            + BooleanOption.USE_ANDROID_X.getPropertyName()</span><br><span class="line">                            + <span class="string">"=true in your gradle.properties file."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖关系替换</span></span><br><span class="line">        <span class="keyword">if</span> (globalScope.getProjectOptions().get(BooleanOption.ENABLE_JETIFIER)) &#123;</span><br><span class="line">            JetifyTransform.replaceOldSupportLibraries(project);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册矫正器 </span></span><br><span class="line">        dependencies.registerTransform(</span><br><span class="line">                transform -&gt; &#123;</span><br><span class="line">                    transform.getFrom().attribute(ARTIFACT_FORMAT, AAR.getType());</span><br><span class="line">                    transform.getTo().attribute(ARTIFACT_FORMAT, TYPE_PROCESSED_AAR);</span><br><span class="line">                    transform.artifactTransform(</span><br><span class="line">                            globalScope.getProjectOptions().get(BooleanOption.ENABLE_JETIFIER)</span><br><span class="line">                                    ? JetifyTransform.class</span><br><span class="line">                                    : IdentityTransform.class);</span><br><span class="line">                &#125;);</span><br><span class="line">        dependencies.registerTransform(</span><br><span class="line">                transform -&gt; &#123;</span><br><span class="line">                    transform.getFrom().attribute(ARTIFACT_FORMAT, JAR.getType());</span><br><span class="line">                    transform.getTo().attribute(ARTIFACT_FORMAT, PROCESSED_JAR.getType());</span><br><span class="line">                    transform.artifactTransform(</span><br><span class="line">                            globalScope.getProjectOptions().get(BooleanOption.ENABLE_JETIFIER)</span><br><span class="line">                                    ? JetifyTransform.class</span><br><span class="line">                                    : IdentityTransform.class);</span><br><span class="line">                &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建任务执行逻辑"><a href="#构建任务执行逻辑" class="headerlink" title="构建任务执行逻辑"></a>构建任务执行逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JetifyTransform.kt</span></span><br><span class="line">class JetifyTransform @Inject constructor() : ArtifactTransform() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换依赖库，将support lib依赖替换为androidX</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function">fun <span class="title">replaceOldSupportLibraries</span><span class="params">(project: Project)</span> </span>&#123;</span><br><span class="line">            project.dependencies.components.all &#123; component -&gt;</span><br><span class="line">                component.allVariants &#123; variant -&gt;</span><br><span class="line">                    variant.withDependencies &#123; metadata -&gt;</span><br><span class="line">                        val oldDeps = mutableSetOf&lt;DirectDependencyMetadata&gt;()</span><br><span class="line">                        val newDeps = mutableListOf&lt;String&gt;()</span><br><span class="line">                        metadata.forEach &#123; it -&gt;</span><br><span class="line">                            val newDep = <span class="keyword">if</span> (bypassDependencySubstitution(it)) &#123;</span><br><span class="line">                                <span class="keyword">null</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                androidXMappings[<span class="string">"$&#123;it.group&#125;:$&#123;it.name&#125;"</span>]</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (newDep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldDeps.add(it)</span><br><span class="line">                                newDeps.add(newDep)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (oldDep in oldDeps.map &#123; it -&gt; <span class="string">"$&#123;it.group&#125;:$&#123;it.name&#125;"</span> &#125;) &#123;</span><br><span class="line">                            metadata.removeIf &#123; it -&gt; <span class="string">"$&#123;it.group&#125;:$&#123;it.name&#125;"</span> == oldDep &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (newDep in newDeps) &#123;</span><br><span class="line">                            metadata.add(newDep)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            project.configurations.all &#123; config -&gt;</span><br><span class="line">                <span class="keyword">if</span> (config.isCanBeResolved) &#123;</span><br><span class="line">                    config.resolutionStrategy.dependencySubstitution.all &#123; it -&gt;</span><br><span class="line">                        JetifyTransform.maybeSubstituteDependency(it, config)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件遍历，矫正依赖库</span></span><br><span class="line">    <span class="function">override fun <span class="title">transform</span><span class="params">(aarOrJarFile: File)</span>: List&lt;File&gt; </span>&#123;</span><br><span class="line">        Preconditions.checkArgument(</span><br><span class="line">            aarOrJarFile.name.toLowerCase().endsWith(<span class="string">".aar"</span>)</span><br><span class="line">                    || aarOrJarFile.name.toLowerCase().endsWith(<span class="string">".jar"</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case 1: 对AndroidX依赖，不做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (jetifyProcessor.isNewDependencyFile(aarOrJarFile)) &#123;</span><br><span class="line">            <span class="keyword">return</span> listOf(aarOrJarFile)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case 2: 正常情况，已经不存在support依赖，因此对support lib不做任何操作 </span></span><br><span class="line">        <span class="keyword">if</span> (jetifyProcessor.isOldDependencyFile(aarOrJarFile)) &#123;</span><br><span class="line">            <span class="keyword">return</span> listOf(aarOrJarFile)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case 3: 对剩余依赖库，进行矫正操作</span></span><br><span class="line">        <span class="comment">// 具体操作为，通过asm浏览aar、jar的字节码，将support的包名通过映射关系，转化为androidX的包名。</span></span><br><span class="line">        <span class="comment">// 映射关系如下：https://developer.android.com/jetpack/androidx/migrate#migrate</span></span><br><span class="line">        val outputFile = File(outputDirectory, <span class="string">"jetified-"</span> + aarOrJarFile.name)</span><br><span class="line">        val maybeTransformedFile = <span class="keyword">try</span> &#123;</span><br><span class="line">            jetifyProcessor.transform(</span><br><span class="line">                setOf(FileMapping(aarOrJarFile, outputFile)), <span class="keyword">false</span></span><br><span class="line">            )</span><br><span class="line">                .single()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(</span><br><span class="line">                <span class="string">"Failed to transform '$aarOrJarFile' using Jetifier."</span></span><br><span class="line">                        + <span class="string">" Reason: $&#123;exception.message&#125;. (Run with --stacktrace for more details.)"</span></span><br><span class="line">                        + <span class="string">" To disable Jetifier,"</span></span><br><span class="line">                        + <span class="string">" set $&#123;BooleanOption.ENABLE_JETIFIER.propertyName&#125;=false in your"</span></span><br><span class="line">                        + <span class="string">" gradle.properties file."</span>,</span><br><span class="line">                exception</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Preconditions.checkState(</span><br><span class="line">            maybeTransformedFile == aarOrJarFile || maybeTransformedFile == outputFile</span><br><span class="line">        )</span><br><span class="line">        Verify.verify(maybeTransformedFile.exists(), <span class="string">"$outputFile does not exist"</span>)</span><br><span class="line">        <span class="keyword">return</span> listOf(maybeTransformedFile)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/jetpack/androidx" target="_blank" rel="noopener">https://developer.android.com/jetpack/androidx</a><br><a href="https://developer.android.com/jetpack/androidx/migrate" target="_blank" rel="noopener">https://developer.android.com/jetpack/androidx/migrate</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-壳工程业务</title>
      <link href="/2019/09/22/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E5%A3%B3%E5%B7%A5%E7%A8%8B%E4%B8%9A%E5%8A%A1/"/>
      <url>/2019/09/22/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E5%A3%B3%E5%B7%A5%E7%A8%8B%E4%B8%9A%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>正处于孵化阶段阶段的业务，基本以前端开发业务为主。我们会帮助进行App工程的搭建，上半年支持3个新App的工程搭建。</p><p><img width="300" src="/image/kegongchen_app_icon.png"></p><h2 id="大体工作"><a href="#大体工作" class="headerlink" title="大体工作"></a>大体工作</h2><p>在不断的接入业务的过程中，我们抽象出了壳工程的通用模板SDK。不断优化模板SDK，最终达到了高效支持业务的目的。</p><p><img width="900" src="/image/kegongchen_大体结构.png"></p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-工程辅助系统</title>
      <link href="/2019/09/22/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E5%B7%A5%E7%A8%8B%E8%BE%85%E5%8A%A9%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/22/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E5%B7%A5%E7%A8%8B%E8%BE%85%E5%8A%A9%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>工程辅助系统主要包括SDK应用市场、SDK上传插件、路由协议查询、项目依赖关系查询这四个功能。</p><ul><li><strong>SDK应用市场</strong>：客户端SDK缺乏管理，事业部之间各自为政，关于SDK的使用方式、依赖关系、源码位置缺乏文档统一。产出SDK应用市场，来辅助管理和集结SDK，简化沟通成本。</li><li><strong>SDK上传插件</strong>：客户端SDK发布随意，缺少审核机制，任何人都可以往核心库发布版本。SDK上传工具目的在于，约束SDK发布流程，并将发布人、当前分支、Git仓库、使用文档收集起来，供SDK市场展示。</li><li><strong>路由协议查询</strong>：客户端组件化后，路由协议分散到各个SDK上。前端开发在容器之后进行业务开发时，对原生路由协议的认知几乎黑盒，已成为业务开发的很大卡点。产出路由协议查询功能，提供对应项目的协议查询能力。</li><li><strong>项目依赖关系</strong>：各大App平台，依赖的SDK版本不一，架构组无法掌握项目中SDK的依赖关系。提供项目依赖关系图，帮助架构组掌握SDK的依赖情况与健康度。</li></ul><h2 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h2><p>工程辅助系统，我主要负责：</p><ul><li>规划工程辅助系统重点方向；</li><li>设计系统总体视觉与交互；</li><li>开发Android上传工具，Android扫描任务，工程辅助系统后台搭建；</li></ul><h2 id="系统概览"><a href="#系统概览" class="headerlink" title="系统概览"></a>系统概览</h2><p><img width="600" src="/image/gongchenfuzhu_jiagoutu.png"></p><p>工程辅助服务，从移动端开发体系来尝试解决问题，主要由以下这个部分组成：</p><ul><li>React前端，提供SDK应用市场、项目依赖关系、路由协议查询的前端展示功能；</li><li>代码扫描器，支持Android和iOS的代码扫描工作，内部自行维护扫描任务队列；</li><li>Node后端，用于提供SDK信息、项目依赖、协议信息的增删改查，并执行定时扫描任务；</li><li>SDK上传工具，规范化客户端SDK的发布流程，并在上传完成后，向Node后端发送SDK扫描请求；</li></ul><h3 id="Android扫描流程概览"><a href="#Android扫描流程概览" class="headerlink" title="Android扫描流程概览"></a>Android扫描流程概览</h3><p><img width="600" src="/image/gongchefuzhu_android_scanner.jpg"></p><h3 id="SDK上传插件"><a href="#SDK上传插件" class="headerlink" title="SDK上传插件"></a>SDK上传插件</h3><p>Android端SDK上传插件，是基于Gradle Maven Task的二次封装。在原生Task基础之上，封装了额外功能，包括本地测试发布、远程发布和多渠道发布。同时，为SDK发布添加了一些标准化规范，包括发布人、Git仓库地址、Git Branch、Git Tag。</p><p><img width="600" src="/image/gongchenfuzhu_maven_upload.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-通用容器框架</title>
      <link href="/2019/09/22/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/22/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<style>table th:first-of-type {    width: 200px;}</style><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>H5 容器是一款移动端 Hybrid 解决方案 SDK，提供标准且健全的H5运行环境。<br>抹平公司多SaaS平台标准不统一的问题，降低业务在各App之间的迁移成本。<br>为工程标准化，业务单元化打下坚实的基础。</p><h2 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h2><p>通用容器框架，主要负责：</p><ul><li>规划端上通用容器的重点方向；</li><li>主导端上接入、集成、使用相关的API设计；</li><li>端上具体实现的技术方案选型；</li><li>端上接入和使用文档的官方文档建设；</li><li>端上通用容器的接入技术支持；</li></ul><h2 id="框架概览"><a href="#框架概览" class="headerlink" title="框架概览"></a>框架概览</h2><p><img width="900" src="/image/jarvis_整体架构图.png"></p><h3 id="标准化UI样式"><a href="#标准化UI样式" class="headerlink" title="标准化UI样式"></a>标准化UI样式</h3><p><strong>效果图</strong></p><p><img width="400" src="/image/jarvis_ui_1.png"><br><img width="400" src="/image/jarvis_ui_2.png"><br><img width="400" src="/image/jarvis_ui_3.png"><br><img width="400" src="/image/jarvis_ui_4.png"></p><p><strong>自定义配置方式</strong></p><ul><li>协议内配置方式</li><li>初始化配置方式</li><li>配置文件配置方式</li></ul><p><strong>自定义配置支持以下内容</strong></p><table><thead><tr><th>类型</th><th>详情</th></tr></thead><tbody><tr><td>导航栏-主题配置</td><td>- 主题色<br>- 是否采用沉浸式导航栏<br>- 加载进度条<br>- 导航栏分割线</td></tr><tr><td>导航栏-左侧模式</td><td>- 返回按钮<br>- 关闭按钮<br>- 自定义按钮</td></tr><tr><td>导航栏-右侧模式</td><td>- 刷新按钮<br>- 更多按钮<br>- 自定义按钮</td></tr><tr><td>导航栏-居中模式</td><td>- 标题模式<br>- Tab模式<br>- 搜索模式</td></tr><tr><td>下拉刷新</td><td>- 下拉刷新动画<br>- 刷新状态文案<br></td></tr><tr><td>启动页</td><td>- 启动页动画<br></td></tr></tbody></table><h3 id="离线包优化"><a href="#离线包优化" class="headerlink" title="离线包优化"></a>离线包优化</h3><p>引入离线包机制，降低H5网络请求而导致的用户体验延时问题。引入离线包后，H5页基本能达到秒开效果。</p><p><strong>离线包加载机制</strong><br><img width="900" src="/image/jarvis_bundle.png"></p><p><strong>Webview网络请求拦截</strong><br><img width="900" src="/image/jarvis_vritual_host.png"></p><h3 id="统一标准能力"><a href="#统一标准能力" class="headerlink" title="统一标准能力"></a>统一标准能力</h3><p><strong>提供协议标准规范</strong></p><blockquote><p>协议格式为：scheme://xxx/su_xxxxx<br>su表示 standard unify 规范统一</p></blockquote><p>返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    &quot;data&quot;: &quot;&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;&quot;,</span><br><span class="line">    &quot;success&quot;: &quot;&quot;,</span><br><span class="line">    &quot;code&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>code编码值</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>正常</td></tr><tr><td>2101</td><td>没有权限</td></tr><tr><td>2102</td><td>必选参数缺失</td></tr><tr><td>2103</td><td>失败</td></tr><tr><td>2104</td><td>参数格式错误</td></tr><tr><td>2105</td><td>系统错误</td></tr><tr><td>2106</td><td>目标不存在</td></tr><tr><td>2107</td><td>协议调起失败</td></tr></tbody></table><p><strong>提供通用能力列表</strong></p><ul><li>定位</li><li>持久存储</li><li>运行期间存储</li><li>剪切板</li><li>获取通讯录</li><li>获取设备信息</li><li>拍照</li><li>打开相册</li><li>保存图片到相册</li></ul><h3 id="小程序样式"><a href="#小程序样式" class="headerlink" title="小程序样式"></a>小程序样式</h3><p>搜车小程序样式，是一种全新的展现形式，帮助业务打造强感知的共享业务应用概念，提供标准化容器，来提高业务稳定性，动态性，可移植性。</p><p><strong>代码结构分布</strong><br><img width="700" src="/image/jarvis_mina.png"></p><p><strong>小程序效果展示</strong><br><img width="1200" src="/image/jarvis_mina_demo.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-路由框架</title>
      <link href="/2019/09/21/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/21/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Router是一个为协议导航设计的框架。你可以使用一个URI来说明你将要跳转的页面、想要调用的目标方法以及所必须的参数。<br>通过Router去调用其他模块的组件是一种很好的解耦方式，在开发自己的模块时，直接使用协议调起即可，只需要最终的主项目引入了目标库即可。<br>基于这一点，我们可以做更多的事，因为同一个协议可以有多个不同的库来实现，我们可以做多次崩溃的自动降级策略、动态路由等。</p><h2 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h2><p>数据存储框架，我主要负责：</p><ul><li>Router框架监控器设计与开发工作；</li><li>Router框架协议解析器设计与开发工作；</li><li>Router框架日常维护和技术支持；</li></ul><h2 id="框架概览"><a href="#框架概览" class="headerlink" title="框架概览"></a>框架概览</h2><p>通过注解的方式进行协议的静态注册。下面描述的协议，其模块名为math，方法名为isPrime。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块名为：math</span></span><br><span class="line"><span class="meta">@Route</span>(<span class="string">"math"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 定义模块方法为：isSyncPrime</span></span><br><span class="line">  <span class="meta">@RouteMethod</span>(<span class="string">"isSyncPrime"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSyncPrime</span><span class="params">(@RouteParam(name = <span class="string">"num"</span>)</span> <span class="keyword">int</span> num) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑代码...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义异步模块方法：isAsyncPrime</span></span><br><span class="line">  <span class="meta">@RouteMethod</span>(<span class="string">"isAsyncPrime"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isAsyncPrime</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @RouteParam(name = Router.Param.RequestCode)</span> <span class="keyword">int</span> requestCode,</span></span><br><span class="line"><span class="function">    @<span class="title">RouteParam</span><span class="params">(name = <span class="string">"num"</span>)</span> <span class="keyword">int</span> num) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑代码...</span></span><br><span class="line">    Router.invokeCallback(requestCode, Collections.singletonMap(<span class="string">"result"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法调用</span></span><br><span class="line"><span class="keyword">boolean</span> result = Router.parse(context, <span class="string">"cheniu://isSyncPrime/math?num=123"</span>).call();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步方法调用</span></span><br><span class="line">Router.parse(<span class="string">"cheniu://isPrime/math?num=11"</span>).call(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Map&lt;String, Object&gt; resultMap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异步结果回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p><img width="600" src="/image/router_技术方案.png"></p><h2 id="协议路由流程图"><a href="#协议路由流程图" class="headerlink" title="协议路由流程图"></a>协议路由流程图</h2><p><img width="600" src="/image/router_协议路由流程图.png"></p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-数据存储框架</title>
      <link href="/2019/09/20/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/20/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<style>table th:first-of-type {    width: 200px;}</style><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数据存储框架，通过协议来进行数据的存储操作。为RN和H5技术栈，提供统一的数据存储方式。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前公司业务发展方向，主要是以容器化方向为主。客户端提供上层运行容器（主要包括：RN和H5容器），前端同学在容器之上进行业务开发。由于H5和RN技术栈本身的差异，数据持久化无法进行完全融合。于是产生了数据存储框架，目的是，帮助前端使用容器无关的数据持久化能力。</p><h2 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h2><p>数据存储框架，我主要负责：</p><ul><li>RESTful协议设计；</li><li>持久化存储方案设计；</li></ul><h2 id="协议概览"><a href="#协议概览" class="headerlink" title="协议概览"></a>协议概览</h2><blockquote><p>协议格式如下：<strong>scheme://支持操作/存储类型?支持类型=值&amp;支持类型=值</strong></p></blockquote><table><thead><tr><th>类型</th><th>详情</th></tr></thead><tbody><tr><td>支持操作</td><td>- put：添加 <br>- post：创建 <br>- patch：合并 <br>- get：获取 <br>- delete：删除</td></tr><tr><td>支持类型</td><td>- json：json-object类型数据 <br>- string：字符串类型数据 <br>- array：json-array类型数据 <br>- number：double数值类型</td></tr><tr><td>存储类型</td><td>- memory：内存存储 <br>- storage：文件存储</td></tr></tbody></table><p><strong>使用方式举例</strong></p><p>通过RESTful规范，来完成数据存储能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往developer中，创建array数据，并存入文件中 </span></span><br><span class="line">Router.start(<span class="string">"scheme://post/storage?array[developer]=[ "</span>android<span class="string">", "</span>web<span class="string">" ]"</span>);</span><br><span class="line"><span class="comment">// 文件内容更新如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"developer"</span> : [</span><br><span class="line">        <span class="string">"android"</span>,</span><br><span class="line">        <span class="string">"web"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 往developer中，添加数据，并存入到文件中</span></span><br><span class="line">Router.start(<span class="string">"scheme://patch/storage?array[developer]=[ "</span>rn<span class="string">" ]"</span>);</span><br><span class="line"><span class="comment">// 文件内容更新如下：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"developer"</span> : [</span><br><span class="line">        <span class="string">"android"</span>,</span><br><span class="line">        <span class="string">"web"</span>,</span><br><span class="line">        <span class="string">"rn"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p><img width="600" src="/image/data_stroage_技术方案.png"></p><h2 id="亮点回顾"><a href="#亮点回顾" class="headerlink" title="亮点回顾"></a>亮点回顾</h2><h4 id="RESTful接口设计规范"><a href="#RESTful接口设计规范" class="headerlink" title="RESTful接口设计规范"></a>RESTful接口设计规范</h4><p>用RESTful设计规范来定义文件存储方式。类似于将存储数据看作是服务器资源，提供了增删改查的操作方式。这样做有利于，提高数据存储的自解释性，降低使用者的学习成本。</p><h4 id="数据持久化备份恢复机制"><a href="#数据持久化备份恢复机制" class="headerlink" title="数据持久化备份恢复机制"></a>数据持久化备份恢复机制</h4><p>操作步骤如下：</p><ol><li>进行源文件备份</li><li>进行文件写入</li><li>写入成功后，将源文件进行删除</li></ol><p>如果在文件操作中的任意一步，出现了异常（程序异常&amp;系统异常）。将会启动备份恢复机制，对数据进行恢复处理。</p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-人机校验服务框架</title>
      <link href="/2019/09/19/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E4%BA%BA%E6%9C%BA%E6%A0%A1%E9%AA%8C%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/19/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E4%BA%BA%E6%9C%BA%E6%A0%A1%E9%AA%8C%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>人机校验服务，提供准确的机器人识别校验。根据设备风险类别，智能切换校验方式，提供三种难度梯度的验证方式。为公司内部的登录，支付系统保驾护航。</p><h2 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h2><p>人机校验服务，我主要负责：</p><ul><li>设计客户端集成和使用方式；</li><li>制定 “数据加密” 规则；</li><li>参与客户端校验流程制定；</li></ul><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p><img width="900" src="/image/man_machine_check_流程图.png"></p><h2 id="亮点回顾"><a href="#亮点回顾" class="headerlink" title="亮点回顾"></a>亮点回顾</h2><p>本SDK属于人机校验框架，对安全有着较高的要求。所以在秘钥的存储上，我们做了些手脚。</p><ul><li>关键数据加密。将密码表暗藏在jpg文件。进行加密操作时，首先解析图片文件中的密码，再对内容进行加密操作。</li><li>参数防篡改校验。将所有请求内容合并到一起，利用摘要算法，提供防篡改二次校验。</li></ul><p><img width="800" src="/image/man_machine_check_加密操作流程.png"></p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-自动初始化框架</title>
      <link href="/2019/09/09/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/09/09/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>自动初始化框架，针对业务模块化现状，帮助降低接入SDK成本。只填写初始化配置文件，零编码接入。将SDK初始化这件事情，做到最简单化。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着公司的高速发展，Android生态的不断健全，我司SDK数量存在爆发性的增长。据不完全统计，当前存在600+的SDK二方库，存在6886+个SDK版本。客户端开发者根本不可能清楚每个SDK的集成和接入方案。每当新起一个App项目时，SDK集成和初始化已经成为一件极其复杂的事情。正常情况下，从接入到初始化到最终运行，需要7个工作日左右的时间。为了解决接入Android客户端SDK集成成本高的问题。自动初始化框架应运而生，目的在于简化集成流程，监控初始化健康度。</p><h2 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h2><p>自动初始化框架，主要负责：</p><ul><li>框架的规划；</li><li>API 的设计；</li><li>技术方案宣讲与推广；</li><li>后期落地推动；</li><li>申请技术专利；</li></ul><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p><img width="1000" src="/image/auto_init_技术方案概览.png"></p><h2 id="亮点回顾"><a href="#亮点回顾" class="headerlink" title="亮点回顾"></a>亮点回顾</h2><p><strong>注解声明初始化模块</strong><br>本框架，在API设计的时候，就希望通过注解的方式来声明初始化模块。包括，声明模块名，模块依赖关系，模块参数都是通过注解来实现的。从面向切面的角度来插入初始化信息，而不影响SDK主功能的流程开发。</p><p><strong>循环依赖校验</strong><br>依赖图构建完毕后，需要校验本次依赖的健康度。包括，依赖是否缺失，是否重复依赖等问题，其中最为头疼的就是循环依赖问题。校验循环依赖，我们通过DFS算法来进行”有向循环图”的依赖关系检查。如果，单个初始化模块节点，被重复遍历，则表明存在循环依赖关系。</p><p>简单展示，依赖关系图表现形式：</p><p><img width="800" src="/image/auto_init_依赖关系图.png"></p><p><strong>自动初始化专利</strong><br>自动初始化框架，已经作为技术创新类专利，通过专利局审核。</p><h2 id="框架用法概览"><a href="#框架用法概览" class="headerlink" title="框架用法概览"></a>框架用法概览</h2><h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入自动初始化框架</span></span><br><span class="line">implementation <span class="string">'com.souche.android.init:ellen:1.0.0'</span></span><br><span class="line"><span class="comment">// 由于自动初始化框架，依赖注解收集器实现；因此需要引入自动初始化插件</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'plugin.nara'</span></span><br></pre></td></tr></table></figure><h4 id="声明初始化模块"><a href="#声明初始化模块" class="headerlink" title="声明初始化模块"></a>声明初始化模块</h4><p>本框架，通过注解的方式来声明初始化模块。通过注解可以指定当前模块名，初始化时机，依赖模块，所需参数，当前Context，当前运行环境，线程池工具。使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InitAuto</span>(name = <span class="string">"模块名"</span>, </span><br><span class="line">            includes = &#123;<span class="string">"模块内部依赖的模块"</span>&#125;, </span><br><span class="line">            depend = &#123;<span class="string">"依赖模块A"</span>, <span class="string">"依赖模块B"</span>&#125;, </span><br><span class="line">            description = <span class="string">"须清楚描述模块作用"</span>, </span><br><span class="line">            when = AutoInitTiming.APP_ON_CREATE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(@InitParam(<span class="string">"custom_prefix.a"</span>)</span> <span class="keyword">int</span> a, @<span class="title">InitParam</span><span class="params">(<span class="string">"custom_prefix.list"</span>)</span> List&lt;Integer&gt; list, </span></span><br><span class="line"><span class="function">                        @InitContext Context context, @InitEnv AutoInitEnv env, </span></span><br><span class="line"><span class="function">                        @InitExecutor Executor executor, @InitProviderStack ProviderStack providerStack) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解介绍</strong></p><ul><li>@InitAuto          表示当前方法将作为初始化方法被调用，其中name表示当前模块名，depend表示依赖模块列表，when表示初始化时间</li><li>@InitParam         表示该参数需要自动注入，支持泛型，支持参数变动观察者操作</li><li>@InitContext       表示该参数需要自动注入Context对象</li><li>@InitEnv           表示该参数需要自动注入AutoInitEnv对象，表示当前运行环境</li><li>@InitProviderStack 表示该参数需要自动注入ProviderStack对象，用于添加参数提供器到提供器链的头部</li><li>@InitExecutor 表示该参数需要自动注入Executor，用于多线程操作，<strong>多线程操作必须通过Executor完成，否则初始化监听将无效，当初始化方法执行完毕后，就无法使用Executor了</strong></li></ul><h4 id="参数提供器"><a href="#参数提供器" class="headerlink" title="参数提供器"></a>参数提供器</h4><p>参数提供器，用于提供初始化方法所需参数，引入参数前缀机制，方便对参数进行聚合归类。采用洋葱圈模型，将参数传递权限交由参数提供器，提供最大限度的灵活度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义参数提供器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomParamsProvider</span> <span class="keyword">extends</span> <span class="title">ParamsProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CustomParamsProvider() &#123;</span><br><span class="line">        <span class="comment">// 声明参数前缀，参数前缀符合条件，才会调用此提供器</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"custom_prefix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getParam</span><span class="params">(String <span class="keyword">module</span>, String param, Type targetType, Chain chain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">".a"</span>.equals(param))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">".list"</span>.equals(param))&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> ParamListItem(<span class="string">"1"</span>), <span class="keyword">new</span> ParamListItem(<span class="string">"2"</span>), <span class="keyword">new</span> ParamListItem(<span class="string">"3"</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">""</span>.equals(param))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Param(Arrays.asList(<span class="keyword">new</span> ParamListItem(<span class="string">"1"</span>), <span class="keyword">new</span> ParamListItem(<span class="string">"2"</span>), <span class="keyword">new</span> ParamListItem(<span class="string">"3"</span>)), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重点:</span></span><br><span class="line">        <span class="comment">// 当前提供器无法提供参数对象，则将责任传递给下一个提供器。若所有提供器都无法提供参数，则返回 Ellen.UNDEFINED_PARAM</span></span><br><span class="line">        <span class="keyword">return</span> chain.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="框架初始化"><a href="#框架初始化" class="headerlink" title="框架初始化"></a>框架初始化</h4><p>通过hook到Application的生命周期来完成本框架的模块初始化功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    <span class="comment">// 监听attachBaseContext方法，内部完成APP_BEFORE_CREATE时机模块初始化</span></span><br><span class="line">    Ellen.hookAttachBaseContext(<span class="keyword">this</span>, AutoInitEnv.DEV_ENV_DEVELOP,</span><br><span class="line">            <span class="keyword">new</span> CustomAutoInitCompletedListener(),</span><br><span class="line">            <span class="keyword">new</span> DefaultParamsProvider(), <span class="keyword">new</span> CustomParamsProvider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="comment">// 监听onCreate方法，内部完成APP_ON_CREATE和APP_AFTER_CREATE时机模块初始化</span></span><br><span class="line">    Ellen.hookOnCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组织管理-宣讲的小技巧</title>
      <link href="/2019/09/08/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E5%AE%A3%E8%AE%B2%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/09/08/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E5%AE%A3%E8%AE%B2%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<ul><li>搞清楚目标用户<br>不同的人关注的点是不一样的，在进行技术宣讲之前，我们需要弄清楚这次宣讲的听众是谁？</li><li>要营造上下文<br>讲里程碑式的成果时，需要先讲背景，再讲问题，再讲手段，最终讲我们的成果。</li><li>结合例子生动形象<br>为了更好的表达效果，不能干讲，最好准备典型场景的例子，从例子开始，到例子结束。</li><li>未来规划需要精准<br>对于未来的畅想，需要有详细的规划和排期。规划越精准，别人越放心。同时，需要设立合适的里程碑。</li><li>重视用户反馈<br>每次宣讲完，需要做绝对的复盘。充分分析用户需求，充分消化用户建议。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-编译时注解收集器</title>
      <link href="/2019/09/07/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2019/09/07/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>注解收集器是一个编译时注解底层库，帮助抽象编译时逻辑，简化编译时复杂度。</p><p>只需要将自定义注解标记上注解收集器的标签@ShadowBinding。之后，只要是被你的注解标注过的类，方法，属性，就能很方便的被找到和使用。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在动手之前，需要先弄清楚大家利用注解都做了哪些事情。弄清楚注解的使用场景，能帮助我们抽象出一个更好用的注解框架。于是，我们调研了 Android 端上常用的注解框架，看看他们利用注解都做了什么事情？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ButterKnife：例如<span class="meta">@BindViews</span>，ButterKnife 在编译期，利用<span class="meta">@BindView</span> 将控件 ID 和类属性建立对应关系。然后在页面启动时，根据控件 ID 通过 findViewById 方法将控件赋值到类属性上。</span><br><span class="line"></span><br><span class="line">EventBus：通过<span class="meta">@Subscribe</span> 对普通方法进行标记。然后，EventBus 在编译期通过<span class="meta">@Subscribe</span> 将这些方法收集起来，作为 EventBus 的订阅方法。</span><br><span class="line"></span><br><span class="line">Retrofit：通过反射方式处理注解，不再本文范畴。</span><br></pre></td></tr></table></figure><p>编译时注解的主要用途在于，收集注解并通过注解信息生成一些有规律的代码。<br>而这些有规律的代码，一般都是可以通过其他方式来间接实现的。比如说，ButterKnife 的属性赋值可以通过反射来实现，EventBus 的方法收集可以直接换个写法。所以，如果要对编译时注解做进一步抽象，我们认为可以从注解收集方面入手。由此，注解收集器诞生了。</p><h2 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h2><p>注解收集器框架，主要负责：</p><ul><li>框架的规划；</li><li>API 的设计；</li><li>技术方案的选型；</li><li>后期的宣讲与推广；</li></ul><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p><img width="900" src="/image/annotation_collection_架构图.png"></p><h2 id="亮点回顾"><a href="#亮点回顾" class="headerlink" title="亮点回顾"></a>亮点回顾</h2><p>项目中遇到的难点主要是在编译时的注解相关信息的收集。如何收集自定义注解、如何对自定义注解进行 APT 操作、如果将 APT 的代码产物有效组织起来，算是这个项目的技术上的核心难点。通过下面流程图来简单介绍~</p><p><img width="600" src="/image/annotation_collection_编译流程.png"></p><h2 id="框架用法概览"><a href="#框架用法概览" class="headerlink" title="框架用法概览"></a>框架用法概览</h2><h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部适配了Jar，Aar，Application的场景</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.souche.nara'</span></span><br></pre></td></tr></table></figure><h4 id="自定义注解声明和使用"><a href="#自定义注解声明和使用" class="headerlink" title="自定义注解声明和使用"></a>自定义注解声明和使用</h4><p>以方法注解来举例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过@ShadowBinding来声明注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@ShadowBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Observer &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式和普通注解一样</span></span><br><span class="line"><span class="meta">@Observer</span>(name = <span class="string">"daiyibo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerObserveOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"souche"</span>, <span class="string">"test1()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义注解声明和使用-1"><a href="#自定义注解声明和使用-1" class="headerlink" title="自定义注解声明和使用"></a>自定义注解声明和使用</h4><p>以方法注解来举例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过@ShadowBinding来声明注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@ShadowBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Observer &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式和普通注解一样</span></span><br><span class="line"><span class="comment">// 收集操作支持作用域: public，protected，default</span></span><br><span class="line"><span class="meta">@Observer</span>(name = <span class="string">"daiyibo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerObserveOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"souche"</span>, <span class="string">"test1()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="搜索被注解的方法"><a href="#搜索被注解的方法" class="headerlink" title="搜索被注解的方法"></a>搜索被注解的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MethodDesc&gt; listMethod = Nara</span><br><span class="line">                .findMethod(Observer.class) <span class="comment">// 查找函数，参数为其所在注解</span></span><br><span class="line">                .filter(<span class="keyword">new</span> AnnotationFilter&lt;MethodDesc&gt;() &#123; <span class="comment">// 自定义筛选条件：return true 表示过滤掉当前函数</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(MethodDesc obj)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .list(); <span class="comment">// 返回符合条件的函数集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MethodDesc，提供了精简的API来方便使用者对Method进行操作，API说明如下：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modifier</span><span class="params">()</span></span>; <span class="comment">// 方法作用域说明，同java.lang.reflect.Modifier</span></span><br><span class="line"><span class="function">List&lt;ParamDesc&gt; <span class="title">arguments</span><span class="params">()</span></span>; <span class="comment">// 返回参数列表，支持泛型</span></span><br><span class="line"><span class="function">Type <span class="title">returnType</span><span class="params">()</span></span>; <span class="comment">// 返回函数返回类型，支持泛型</span></span><br><span class="line"><span class="function">String <span class="title">methodName</span><span class="params">()</span></span>; <span class="comment">// 返回函数名</span></span><br><span class="line"><span class="function">Class <span class="title">declareRealClazz</span><span class="params">()</span></span>; <span class="comment">// 返回函数声明类</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object... params)</span></span>; <span class="comment">// 调用函数，如果调用的是成员方法，则params[0]应该为Method所在类的对象</span></span><br><span class="line">&lt;T extends Annotation&gt; <span class="function">T <span class="title">annotation</span><span class="params">(Class&lt;T&gt; clazz)</span></span>; <span class="comment">// 返回特定注解实例对象</span></span><br><span class="line"><span class="function">List&lt;Class&gt; <span class="title">annotationClasses</span><span class="params">()</span></span>; <span class="comment">// 返回所有注解类</span></span><br></pre></td></tr></table></figure><h2 id="落地项目"><a href="#落地项目" class="headerlink" title="落地项目"></a>落地项目</h2><p>本框架主要提供编译时 AOP 的解决方案。为下列框架提供了有效的技术支持：</p><ul><li>自动初始化框架</li><li>路由框架</li><li>IOT 框架</li></ul><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://blog.souche.com/nara_compile_annotation_collect/" target="_blank" rel="noopener">https://blog.souche.com/nara_compile_annotation_collect/</a></p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java-基础类型N进宫</title>
      <link href="/2019/09/07/Java-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8BN%E8%BF%9B%E5%AE%AB/"/>
      <url>/2019/09/07/Java-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8BN%E8%BF%9B%E5%AE%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型介绍"><a href="#基本类型介绍" class="headerlink" title="基本类型介绍"></a>基本类型介绍</h2><h1 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h1><ul><li>占 8 位，有符号的</li><li>最小值：-128（-2^7）</li><li>最大值：127（2^7 -1）</li></ul><h1 id="short"><a href="#short" class="headerlink" title="short"></a>short</h1><ul><li>占 16 位，有符号的</li><li>最小值：-32768（-2^15）</li><li>最大值：32767（2^15-1）</li></ul><h1 id="int"><a href="#int" class="headerlink" title="int"></a>int</h1><ul><li>占 32 位，有符号的</li><li>最小值：-2147483648（-2^31）</li><li>最大值：2147483647（2^31-1）</li></ul><h1 id="long"><a href="#long" class="headerlink" title="long"></a>long</h1><ul><li>占 64 位，有符号的</li><li>最小值：-9223372036854775808（-2^63）</li><li>最大值：9223372036854775807（2^63-1）</li></ul><h1 id="float"><a href="#float" class="headerlink" title="float"></a>float</h1><ul><li>占 32 位</li><li>符合 IEEE 754 标准的浮点数</li><li>单精度</li></ul><h1 id="double"><a href="#double" class="headerlink" title="double"></a>double</h1><ul><li>占 64 位</li><li>符合 IEEE 754 标准的浮点数</li><li>双精度</li></ul><h1 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h1><ul><li>占 1 位</li><li>0 表示 false，1 表示 true</li></ul><h1 id="char"><a href="#char" class="headerlink" title="char"></a>char</h1><ul><li>占 16 位</li><li>最小值：\u0000（即为 0）</li><li>最大值：\uFFFF（即为 65535）</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="如何表示正负值？"><a href="#如何表示正负值？" class="headerlink" title="如何表示正负值？"></a>如何表示正负值？</h2><p>类似于 int，long，short 这种基本类型，内存中第 1 位表示该数值的正反值。</p><h2 id="Java-数值中反码的应用？"><a href="#Java-数值中反码的应用？" class="headerlink" title="Java 数值中反码的应用？"></a>Java 数值中反码的应用？</h2><p>在 java 虚拟机中整数有 byte、short、int、long 四种 分别表示 8 位、16 位、32 位、64 位有符号整数。整数使用补码表示。<br>补码：一个数如果为正，则它的原码、反码、补码相同；一个数如果为负，去到反码然后加 1。（反码加 1 就是补码）为了简单起见，我们用 1 个 byte 来表示一个整数：<br>-7 的原码为： 10000111<br>-7 的反码为： 11111000<br>-7 的补码为： 11111001<br><a href="https://blog.csdn.net/qq_30739519/article/details/50991484" target="_blank" rel="noopener">https://blog.csdn.net/qq_30739519/article/details/50991484</a></p><h2 id="单精度和双精度的区别？"><a href="#单精度和双精度的区别？" class="headerlink" title="单精度和双精度的区别？"></a>单精度和双精度的区别？</h2><p><strong>float 是 32 位，double 是 64 位</strong><br>float32 位中，有 1 位符号位，8 位指数位，23 位尾数位<br>double64 位中，1 位符号位，11 位指数位，52 位尾数位</p><p><strong>取值范围看指数部分</strong><br>float 是有符号型，其中，8 位指数位，2^8=（-128—127），因此实际的范围是-2^128—2^127，约为-3.4E38—3.4E38<br>同理 double 范围约是-1.7E308—1.7E308<br><strong>精度看尾数部分</strong><br>float 尾数位 23 位，2^23=8.3E6，7 位，所以不同的编译器规定不同，有些是 7 位，有些 8 位<br>double 尾数 52 位，2^52=4.5E15，15 位，所以 double 的有效位数是 15 位</p><p><a href="https://blog.csdn.net/Ideality_hunter/article/details/78437439" target="_blank" rel="noopener">https://blog.csdn.net/Ideality_hunter/article/details/78437439</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工作回顾-搜车之星统一规则</title>
      <link href="/2019/09/03/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E6%90%9C%E8%BD%A6%E4%B9%8B%E6%98%9F%E7%BB%9F%E4%B8%80%E8%A7%84%E5%88%99/"/>
      <url>/2019/09/03/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE-%E6%90%9C%E8%BD%A6%E4%B9%8B%E6%98%9F%E7%BB%9F%E4%B8%80%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="“搜车之星”统一规则"><a href="#“搜车之星”统一规则" class="headerlink" title="“搜车之星”统一规则"></a>“搜车之星”统一规则</h1><h2 id="“搜车之星”是什么？"><a href="#“搜车之星”是什么？" class="headerlink" title="“搜车之星”是什么？"></a><a href="#6n0ktd"></a>“搜车之星”是什么？</h2><p>鼓励阅读、分享、总结、贡献、交流，年中和年底两次盘点和奖励，并且未来可能会成为跟随员工终身的一个信息标签。<br>对应的输出会获得不同数量的 ★，10 个 ★ 兑换一个 🌙 ，五个 🌙 兑换一个 🌞</p><h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a><a href="#400ncf"></a>形式</h2><p>归类一下目前存在的几种可选形式</p><h3 id="CODE-REVIEW"><a href="#CODE-REVIEW" class="headerlink" title="CODE REVIEW"></a><a href="#g9rihg"></a>CODE REVIEW</h3><p>可以是实现某个功能的一段有价值的代码，<br>可以是代码规范，<br>可以是你最近的一些新的想法，和大家分享，寻找一起钻研的人。</p><h3 id="文章精读"><a href="#文章精读" class="headerlink" title="文章精读"></a><a href="#d9wdzg"></a>文章精读</h3><p>每周一位同学，挑选一篇自己看到的有意义的文章，产出自己的心得体会，与大家分享。</p><h3 id="SmallTalk-or-话题交流"><a href="#SmallTalk-or-话题交流" class="headerlink" title="SmallTalk or 话题交流"></a><a href="#xhx8tq"></a>SmallTalk or 话题交流</h3><p>确定主题 -&gt; 发布主题，组员自行预约 -&gt; 茶话会分享 -&gt; 总结分享产出总结</p><h3 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a><a href="#v6ciwk"></a>技术博客</h3><p><a href="https://blog.souche.com/admin" target="_blank" rel="noopener">https://blog.souche.com/admin</a></p><h3 id="公司级分享"><a href="#公司级分享" class="headerlink" title="公司级分享"></a><a href="#lpqpso"></a>公司级分享</h3><p>联系公司技术分享 HR 报名</p><h3 id="无线大团队分享"><a href="#无线大团队分享" class="headerlink" title="无线大团队分享"></a>无线大团队分享</h3><p>准备话题在整个无线团队分享</p><h2 id="积分制度"><a href="#积分制度" class="headerlink" title="积分制度"></a><a href="#s9xveu"></a>积分制度</h2><p>10 个 ★ 兑换一个 🌙 ，五个 🌙 兑换一个 🌞</p><table><thead><tr><th>形式</th><th>积分</th></tr></thead><tbody><tr><td>精读文章</td><td>★</td></tr><tr><td>Code Review</td><td>★★</td></tr><tr><td>茶话会/SmallTalk</td><td>★★</td></tr><tr><td>技术博客</td><td>★★</td></tr><tr><td>内部开源项目 MR 被合并</td><td>★★★</td></tr><tr><td>公司级分享</td><td>★★★★★</td></tr><tr><td>无线大团队分享</td><td>★★★★★</td></tr></tbody></table><p>每个团队在每次分享有更新的时候记录每个人的积分数，每半年我们会对积分进行一次盘点和奖励，未来有可能会成为员工内网的标准技术属性。</p>]]></content>
      
      
      <categories>
          
          <category> 回顾 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>读书笔记-架构漫谈</title>
      <link href="/2019/07/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E6%BC%AB%E8%B0%88/"/>
      <url>/2019/07/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84%E6%BC%AB%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="软件概念"><a href="#软件概念" class="headerlink" title="软件概念"></a>软件概念</h2><h3 id="软件的目的"><a href="#软件的目的" class="headerlink" title="软件的目的"></a>软件的目的</h3><p>软件的目的，是把人类的生活模拟化，提供更低成本，高效率的新的生活。</p><h3 id="搞清楚技术与业务的关系"><a href="#搞清楚技术与业务的关系" class="headerlink" title="搞清楚技术与业务的关系"></a>搞清楚技术与业务的关系</h3><ol><li>业务相当于人的大脑，而技术相当于人的四肢。我们真正应该投入的是大脑部分。因为大脑能够决定四肢长什么样，而不是反过来。而我们大部分开发人员的工作主要专注于四肢部分。</li><li>很多架构师、技术人员主要专注于计算机相关的技术，忽略了业务本身，甚至看不起业务，这也是为什么技术总是和业务冲突的原因。</li><li>技术总是在人类解决对业务的要求不断提高的情况下产生，目的也是为了获取更大更好的利益。</li></ol><h3 id="避免开发自嗨式软件"><a href="#避免开发自嗨式软件" class="headerlink" title="避免开发自嗨式软件"></a>避免开发自嗨式软件</h3><p>软件的目的是解决别人的问题。完成了自己的工作，也并不一定就解决了别人的问题。如果别人的问题没有解决 – 即使我们认为自己的工作完成了 – 我们的工作实际也没完成，因为我们工作是否完成，是别人说的算的，不是我们自己。</p><h2 id="识别问题"><a href="#识别问题" class="headerlink" title="识别问题"></a>识别问题</h2><h3 id="如何识别问题"><a href="#如何识别问题" class="headerlink" title="如何识别问题"></a>如何识别问题</h3><p>想要真正认识问题之前，需要抓住两个关键点：</p><ol><li>这是谁的问题？</li><li>有什么问题？</li></ol><h3 id="如何识别是谁的问题"><a href="#如何识别是谁的问题" class="headerlink" title="如何识别是谁的问题"></a>如何识别是谁的问题</h3><ol><li>如果问题不解决，究竟谁会有利益的损失？</li><li>如果问题解决了，究竟谁会有收益，谁的收益最大？</li></ol><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><ol><li>根据要解决的问题，对目标系统的边界进行界定。</li><li>并对目标系统按某个原则的进行切分。切分的原则，要便于不同的角色，对切分出来的部分，并行或串行开展工作，一般并行才能减少时间。</li><li>并对这些切分出来的部分，设立沟通机制。</li><li>根据 3，使得这些部分之间能够进行有机的联系，合并组装成为一个整体，完成目标系统的所有工作。</li></ol><h3 id="架构包含什么"><a href="#架构包含什么" class="headerlink" title="架构包含什么"></a>架构包含什么</h3><ol><li>软件因为流量增大而分拆成不同的运行单元，在不同的机器上部署所形成的架构，属于软件架构。</li><li>每个运行单元为了让不同角色的人，比如前端，业务，数据存储等能够并行工作，所分成的代码架构，也属于软件架构。</li></ol><h3 id="架构的切分原则"><a href="#架构的切分原则" class="headerlink" title="架构的切分原则"></a>架构的切分原则</h3><ol><li>必须在连续时间内发生的一个活动，不能切分。比如孕妇怀孕，必须要 10 月怀胎，不能够切成 10 个人一个月完成。</li><li>切分出来的部分的负责人，对这个部分的权利和义务必须是对等的。</li><li>切分出来的部分，不应该超出一个自然人的负载。</li><li>切分是内部活动，内部无论怎么切，对整个系统的外部应该是透明的。</li></ol><h3 id="架构的切分总结"><a href="#架构的切分总结" class="headerlink" title="架构的切分总结"></a>架构的切分总结</h3><ol><li>架构的切分的导火索是人的负载太重。</li><li>架构的切分实际就是对 stakeholder 的利益进行切分或合并，使得每个 stakeholder 的权责是对等的，每个 stakeholder 可以为自己的利益负责。</li><li>架构切分的最终结果都会体现在组织架构上，只有这样才能够让架构落地并推进。</li><li>架构切分的结果一定是一个树状，这也是为什么会产生分层。层数越多沟通越多，效率越低，分层要越少越好。尽可能变成一颗平衡树，才能让整个系统的效率最大化。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part01" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part01</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part02" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part02</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part03" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part03</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part04" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part04</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part05" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part05</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part06" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part06</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part07" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part07</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part08" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part08</a><br><a href="https://www.infoq.cn/article/an-informal-discussion-on-architecture-part09" target="_blank" rel="noopener">https://www.infoq.cn/article/an-informal-discussion-on-architecture-part09</a></p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>读书笔记-稻盛和夫 心法</title>
      <link href="/2019/07/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A8%BB%E7%9B%9B%E5%92%8C%E5%A4%AB-%E5%BF%83%E6%B3%95/"/>
      <url>/2019/07/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%A8%BB%E7%9B%9B%E5%92%8C%E5%A4%AB-%E5%BF%83%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><ul><li>尽人事，待天命</li><li>贪，嗔，痴，慢，疑，见<ul><li>贪：一切都想要据为己有的贪婪之心</li><li>嗔：不管他人感受，我信我素，稍不如意就发火动怒的浅薄之心</li><li>痴：把变化无偿的世界看作一成不变，当自己幻想破灭时就发牢骚、鸣不平，对佛的智慧一窍不通的痴愚之心</li><li>慢：傲慢不逊</li><li>疑：对释迦摩尼宣导的真理抱有的怀疑之心</li><li>见：总从负面看待事物之心</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>服务发现-补漏</title>
      <link href="/2019/07/01/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-%E8%A1%A5%E6%BC%8F/"/>
      <url>/2019/07/01/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-%E8%A1%A5%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是服务发现"><a href="#什么是服务发现" class="headerlink" title="什么是服务发现"></a>什么是服务发现</h2><p>在传统的系统部署中，服务运行在一个固定的已知的 IP 和端口上，如果一个服务需要调用另外一个服务，可以通过地址直接调用，但是，在虚拟化或容器话的环境中，服务实例的启动和销毁是很频繁的，服务地址在动态的变化，如果需要将请求发送到动态变化的服务实例上，至少需要两个步骤：</p><blockquote><ol><li>服务注册 — 存储服务的主机和端口信息</li><li>服务发现 — 允许其他用户发现服务注册阶段存储的信息</li></ol></blockquote><h2 id="服务发现的优点"><a href="#服务发现的优点" class="headerlink" title="服务发现的优点"></a>服务发现的优点</h2><p>服务发现的主要好处是「零配置」：不用使用硬编码的网络地址，只需服务的名字（有时甚至连名字都不用）就能使用服务。在现代的体系架构中，单个服务实例的启动和销毁很常见，所以应该做到：无需了解整个架构的部署拓扑，就能找到这个实例。</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>在一个分布式系统中，服务注册与发现组件主要解决两个问题：服务注册和服务发现。</p><ul><li>服务注册：服务实例将自身服务信息注册到注册中心。这部分服务信息包括服务所在主机 IP 和提供服务的 Port，以及暴露服务自身状态以及访问协议等信息。</li><li>服务发现：服务实例请求注册中心获取所依赖服务信息。服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</li></ul><p>除此之外，服务注册与发现需要关注监控服务实例运行状态、负载均衡等问题。</p><ul><li>监控：微服务应用中，服务处于动态变化的情况，需要一定机制处理无效的服务实例。一般来讲，服务实例与注册中心在注册后通过心跳的方式维系联系，一旦心跳缺少，对应的服务实例会被注册中心剔除。</li><li>负载均衡：同一服务可能同时存在多个实例，需要正确处理对该服务的负载均衡。</li></ul><h2 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h2><p>在使用客户端发现方式时，客户端通过查询服务注册中心，获取可用的服务的实际网络地址（IP 和端口）。然后通过负载均衡算法来选择一个可用的服务实例，并将请求发送至该服务。<br>优点：架构简单，扩展灵活，方便实现负载均衡功能。<br>缺点：强耦合，有一定开发成本。<br><img width="900" src="/image/client_discover.jpg"></p><h2 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h2><p>客户端向 load balancer 发送请求。load balancer 查询服务注册中心找到可用的服务，然后转发请求到该服务上。和客户端发现一样，服务都要到注册中心进行服务注册和注销。<br>优点：服务的发现逻辑对客户端是透明的。<br>缺点：需要额外部署和维护高可用的负载均衡器。<br><img width="900" src="/image/server_discover.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Yemilice/p/10923331.html" target="_blank" rel="noopener">https://www.cnblogs.com/Yemilice/p/10923331.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组织管理-阿米巴经营读后感</title>
      <link href="/2019/06/26/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E9%98%BF%E7%B1%B3%E5%B7%B4%E7%BB%8F%E8%90%A5%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2019/06/26/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E9%98%BF%E7%B1%B3%E5%B7%B4%E7%BB%8F%E8%90%A5%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><ul><li>公司拆分事业部，主要也是想要每个事业部对自己负责。进而发挥每一个员工的价值，让大家在自己的岗位上发光发热。</li><li>架构组做的底层框架，需要不断的收集数据，通过数据来证明自己的清白。</li><li>需要关注团队中的进步，而不是团队中的产出。相比于产出，进步才是更有价值的表现。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="/image/《阿米巴经营》稻盛和夫.pdf">阿米巴经营-稻盛和夫.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组织管理-GMTC参会有感</title>
      <link href="/2019/06/21/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-GMTC%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/06/21/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-GMTC%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/image/gmtc_growing.png" alt="成长方向"></p><h2 id="参后感"><a href="#参后感" class="headerlink" title="参后感"></a>参后感</h2><ul><li><p>内功思考</p><ul><li>关注价值：技术能力（做到） 不等于 企业价值（价值）</li><li>数据驱动：通过数据，可以了解现状，可以分析现状，可以发现问题，可以量化指标，可以证明价值</li><li>强调闭环：规划方案，设计框架时，应该将方案做成闭环，从而产生更大的价值</li><li>思考方向：商业化思考，数据化思考，产品化思考</li></ul></li><li><p>外功思考</p><ul><li>技术发展趋势：移动端开发 -&gt; 全栈开发方向转 -&gt; 无线开发</li><li>大前端：逐渐成为应用开发的必备技能，React Native &amp; Flutter</li><li>端上监控：掌握端上应用运行状况，并通过监控数据来促进应用稳定运行</li><li>架构理解：偏向于实现 85 分框架，将时间花在关键技术的关键卡点上，而非陷入细节</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>链接: <a href="https://pan.baidu.com/s/1w1YSKI90lDro5YRxJ96W8Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1w1YSKI90lDro5YRxJ96W8Q</a><br>提取码: 2eg1</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组织管理-规划的方法论</title>
      <link href="/2019/06/19/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E8%A7%84%E5%88%92%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>/2019/06/19/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E8%A7%84%E5%88%92%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="需求的维度"><a href="#需求的维度" class="headerlink" title="需求的维度"></a>需求的维度</h2><ul><li>正常支撑业务开发</li><li>稳定、高效的支撑业务开发</li><li>从技术的角度提供新的能力，来影响业务的发展</li></ul><h2 id="规划方向的步骤"><a href="#规划方向的步骤" class="headerlink" title="规划方向的步骤"></a>规划方向的步骤</h2><p>以“H5 离线容器方向”来举例：</p><ul><li>畅想未来：对“H5 离线容器”的最终目标是什么？</li><li>阶段成果：根据“畅想未来”的结果，划分出（一年，半年，一季度，一个月）的阶段性成果。</li><li>目标列表：根据“阶段成果”，细化需求列表，抽象成可执行单位，进行排期开发。</li></ul><h2 id="质问“规划方向”的准确性"><a href="#质问“规划方向”的准确性" class="headerlink" title="质问“规划方向”的准确性"></a>质问“规划方向”的准确性</h2><p>讲故事的能力：当别人来问你的时候，你要讲的清楚这件事情干了什么，有什么价值</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>阶段性成果的时间线，由远及近，一年，半年，一季度，一个月…</li><li>考虑方案时，不能总是以客户端为中心，应俯视流程，从大局出发。</li><li>高效会议，应避免无效的细节讨论。在钉钉产出一点思考后，进行头脑碰撞才是会议的目的。</li><li>阶段性成果最小化，有利于上下级之间信息的同步。遇到偏差，才能快速纠正。</li><li>高效的信息同步，如何准确理解上级的想法，如何准确传到自己的想法，都是很重要的能力。</li><li>规划、开发过程中，应时刻考虑落地</li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li><p>阶段性规划的格式：<img width="900" src="/image/grow_result.png"></p></li><li><p>聚焦思维的方式：<img width="300" src="/image/grow_xmind.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-Maven依赖规则</title>
      <link href="/2019/06/11/Android-Maven%E4%BE%9D%E8%B5%96%E8%A7%84%E5%88%99/"/>
      <url>/2019/06/11/Android-Maven%E4%BE%9D%E8%B5%96%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="dependencies-字段说明"><a href="#dependencies-字段说明" class="headerlink" title="dependencies 字段说明"></a>dependencies 字段说明</h2><ul><li>groupId：所需 Jar 包的项目名</li><li>artifactId：所需 Jar 包的模块名</li><li>version：所需 Jar 包的版本号</li><li>type：依赖类型，默认类型是 Jar</li><li>exclusions：主动排除子项目传递过来的依赖</li><li>scope：设置依赖的传递范围<ol><li>compile<br>编译范围，默认 scope，在工程环境的 classpath（编译环境）和打包（如果是 WAR 包，会包含在 WAR 包中）时候都有效。</li><li>provided<br>容器或 JDK 已提供范围，表示该依赖包已经由目标容器（如 tomcat）和 JDK 提供，只在编译的 classpath 中加载和使用，打包的时候不会包含在目标包中。最常见的是 j2ee 规范相关的 servlet-api 和 jsp-api 等 jar 包，一般由 servlet 容器提供，无需在打包到 war 包中，如果不配置为 provided，把这些包打包到工程 war 包中，在 tomcat6 以上版本会出现冲突无法正常运行程序（版本不符的情况）。</li><li>runtime<br>一般是运行和测试环境使用，编译时候不用加入 classpath，打包时候会打包到目标包中。一般是通过动态加载或接口反射加载的情况比较多。也就是说程序只使用了接口，具体的时候可能有多个，运行时通过配置文件或 jar 包扫描动态加载的情况。典型的包括：JDBC 驱动等。</li><li>test<br>测试范围，一般是单元测试场景使用，在编译环境加入 classpath，但打包时不会加入，如 junit 等。</li><li>system<br>系统范围，与 provided 类似，只是标记为该 scope 的依赖包需要明确指定基于文件系统的 jar 包路径。因为需要通过 systemPath 指定本地 jar 文件路径，所以该 scope 是不推荐的。如果是基于组织的，一般会建立本地镜像，会把本地的或组织的基础组件加入本地镜像管理，避过使用该 scope 的情况。</li></ol></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a><br><a href="https://www.cnblogs.com/wangyonghao/p/5976055.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyonghao/p/5976055.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>TypeScript-基础语法</title>
      <link href="/2019/06/11/TypeScript-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/06/11/TypeScript-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><p>作为从 Java 迁移过来的开发者，感觉 TypeScript 真的是搭救我从 JavaScript 的大坑中出来的神器呢~<br>再也不用担心因为类型不安全而导致编码不严谨的各式各样的问题了。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 布尔值</span><br><span class="line">let isDone: boolean = false;</span><br><span class="line">// 数字</span><br><span class="line">let num: number = 6;</span><br><span class="line">// 字符串</span><br><span class="line">let name:string = &quot;bob&quot;;</span><br><span class="line">let sentence: string = `Hello, my name is $&#123;name&#125;`;</span><br><span class="line">// 数组</span><br><span class="line">let list: number[] = [1, 2, 3, 4];</span><br><span class="line">let list: Array&lt;number&gt; = [1, 2, 3];</span><br><span class="line">// 枚举</span><br><span class="line">enum Color &#123; Red, Green, Blue &#125;;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line">// Symbols：与javascript同意义</span><br><span class="line">let sym1 = Symbol();</span><br><span class="line">let sym2 = Symbol();</span><br><span class="line">// Any：可以理解为Object对象</span><br><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = &quot;maybe a string instead&quot;;</span><br><span class="line">notSure = false;</span><br><span class="line">// Void：表示没有任何类型</span><br><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// Null &amp; Undifined：~ extend from javascript</span><br><span class="line">let u: undefined = undifined;</span><br><span class="line">let n: null = null;</span><br><span class="line">// Never：表示一个永远无法达到的类型</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line">// Object：表示非原始类型，即除number，string，boolean，symbol之外的类型</span><br><span class="line">function create(o: object): void;</span><br><span class="line">create(&#123; prop: 0 &#125;);// ok</span><br><span class="line">create(1);// error</span><br><span class="line">// 类型断言：类似于java中的类型强转</span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLenght1: number = (&lt;string&gt;someValue).lenght;</span><br><span class="line">let strLenght2: number = (someValue as string).lenght;</span><br></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">var str1 = &quot;string 1&quot;;</span><br><span class="line">let str2 = &quot;string 2&quot;;</span><br><span class="line">const str3 = &quot;string 3&quot;;</span><br><span class="line">// 解构-数组</span><br><span class="line">let input = [1, 2];</span><br><span class="line">let [first, second] = input;</span><br><span class="line">console.log(first);// output -&gt; 1</span><br><span class="line">console.log(second);// output -&gt; 2</span><br><span class="line">// 解构-对象</span><br><span class="line">let o = &#123;</span><br><span class="line">    a: &quot;foo&quot;,</span><br><span class="line">    b: 12,</span><br><span class="line">    c: &quot;bar&quot;,</span><br><span class="line">&#125;</span><br><span class="line">let &#123; a, b &#125; = o;</span><br><span class="line">console.log(a);// output -&gt; foo</span><br><span class="line">console.log(b);// output -&gt;12</span><br><span class="line">// 展开-数组</span><br><span class="line">let first = [1, 2];</span><br><span class="line">let second = [3, 4];</span><br><span class="line">let bothPlus = [ 0, ...first, ...second, 5];</span><br><span class="line">// 展开-对象</span><br><span class="line">let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;</span><br><span class="line">let search = &#123; ...defaults, food: &quot;rich&quot; &#125;;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口-标准使用：没有对象实现接口的概念，只是一个类型检查</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明接口</span><br><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line">// 实现接口</span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line">// 使用接口</span><br><span class="line">let myObj = &#123;size: 10, label: &quot;Size 10 Object&quot;&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure><p><strong>接口-可选属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string; // 可选参数</span><br><span class="line">  width?: number; // 可选参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口-只读属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">let p1: Point = &#123; x: 1, y: 2 &#125;;</span><br><span class="line">p1.x = 1;// error</span><br></pre></td></tr></table></figure><p><strong>接口-声明函数：声明函数时，会生成一个方法签名；规则与 java 基本相同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">interface SearchFunc &#123;</span><br><span class="line">  search(source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">let mySearch: SearchFunc = &#123;</span><br><span class="line">  search: function(source: string, subString: string): boolean &#123;</span><br><span class="line">    let result = source.search(subString);</span><br><span class="line">    return result &gt; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>接口-实现接口：与 java 中的接口基本作用一样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  setTime(d: Date): void;</span><br><span class="line">&#125;</span><br><span class="line">// 实现</span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  // 构造方法</span><br><span class="line">  constructor(h: number, m: number) &#123;</span><br><span class="line">    this.currentTime = new Date();</span><br><span class="line">    this.currentTime.setHours(h, m);</span><br><span class="line">  &#125;</span><br><span class="line">  // 接口方法</span><br><span class="line">  setTime(d: Date): void &#123;</span><br><span class="line">    this.currentTime = d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口-多继承：操作方法与 java 类似</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">interface Shape &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">  penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line">// 声明多继承接口</span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">  sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">let square: Square = &#123;</span><br><span class="line">  color: &apos;blue&apos;,</span><br><span class="line">  sideLength: 10,</span><br><span class="line">  penWidth: 5.0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>接口-继承与类的接口：当接口继承了一个类类型时，它会继承类的成员但不包括其实现，接口同样会继承到类的 private 和 protected 成员。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Control &#123;</span><br><span class="line">    private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">    select(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Control implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TextBox extends Control &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：“Image”类型缺少“state”属性。</span><br><span class="line">class Image implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：“Image”类型缺少Control类的“state”属性。</span><br><span class="line">class Location implements SelectableControl &#123;</span><br><span class="line">    private state: any;// 此 state 非彼 state</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>类-创建</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    constructor(message: string) &#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        return &quot;Hello, &quot; + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter = new Greeter(&quot;world&quot;);</span><br></pre></td></tr></table></figure><p><strong>类-继承</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  move(distanceInMeters: number = 0) &#123;</span><br><span class="line">    console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    console.log(&apos;Woof! Woof!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure><p><strong>类-修饰符：公共，私有与受保护的修饰符</strong></p><ul><li>public：默认值，表示可以类的外部访问</li><li>private：当成员被标记成 private 时，它就不能在声明它的类的外部访问</li><li>protected：protected 修饰符与 private 修饰符的行为很相似，但有一点不同， protected 成员在派生类中仍然可以访问</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  protected name: string;</span><br><span class="line">  private age: number;</span><br><span class="line">  protected constructor(theName: string) &#123;</span><br><span class="line">    this.name = theName;</span><br><span class="line">    this.age = 18;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person &#123;</span><br><span class="line">  private department: string;</span><br><span class="line">  /* public */ constructor(name: string, department: string) &#123;</span><br><span class="line">    super(name);</span><br><span class="line">    this.department = department;</span><br><span class="line">    this.age = 24; // error: Person的age属性为private</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public getElevatorPitch() &#123;</span><br><span class="line">    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let howard = new Employee(&apos;Howard&apos;, &apos;Sales&apos;);</span><br><span class="line">let john = new Person(&apos;John&apos;); // error: Persion的构造函数为protected</span><br></pre></td></tr></table></figure><p><strong>类-readonly 修饰符：将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Octopus &#123;</span><br><span class="line">  readonly name: string;</span><br><span class="line">  readonly numberOfLegs: number = 8;</span><br><span class="line">  constructor(theName: string) &#123;</span><br><span class="line">    this.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dad = new Octopus(&apos;Man with the 8 strong legs&apos;);</span><br><span class="line">dad.name = &apos;Man with the 3-piece suit&apos;; // 错误! name 是只读的.</span><br></pre></td></tr></table></figure><p><strong>类-存取器：TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Employee &#123;</span><br><span class="line">  fullName: string = &apos;empty&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let employee = new Employee();</span><br><span class="line">employee.fullName = &apos;Bob Smith&apos;;</span><br><span class="line">if (employee.fullName) &#123;</span><br><span class="line">  console.log(employee.fullName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 存取器转化 ===&gt;</span><br><span class="line"></span><br><span class="line">class Employee &#123;</span><br><span class="line">  private _fullName: string = &apos;empty&apos;;</span><br><span class="line"></span><br><span class="line">  get fullName(): string &#123;</span><br><span class="line">    return this._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set fullName(newName: string) &#123;</span><br><span class="line">    this._fullName = newName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let employee = new Employee();</span><br><span class="line">employee.fullName = &apos;Bob Smith&apos;;</span><br><span class="line">if (employee.fullName) &#123;</span><br><span class="line">  console.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类-静态属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Grid &#123;</span><br><span class="line">  static origin = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123;</span><br><span class="line">    let xDist = point.x - Grid.origin.x;</span><br><span class="line">    let yDist = point.y - Grid.origin.y;</span><br><span class="line">    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;</span><br><span class="line">  &#125;</span><br><span class="line">  // 构造函数-参数：scale 为声明成员属性的另一种方式</span><br><span class="line">  constructor(public scale: number) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let grid1 = new Grid(1.0); // 1x scale</span><br><span class="line">let grid2 = new Grid(5.0); // 5x scale</span><br><span class="line"></span><br><span class="line">console.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));</span><br><span class="line">console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));</span><br></pre></td></tr></table></figure><p><strong>类-抽象类：abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">abstract class Department &#123;</span><br><span class="line"></span><br><span class="line">    constructor(public name: string) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printName(): void &#123;</span><br><span class="line">        console.log(&apos;Department name: &apos; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract printMeeting(): void; // 必须在派生类中实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AccountingDepartment extends Department &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super(&apos;Accounting and Auditing&apos;); // 在派生类的构造函数中必须调用 super()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMeeting(): void &#123;</span><br><span class="line">        console.log(&apos;The Accounting Department meets each Monday at 10am.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateReports(): void &#123;</span><br><span class="line">        console.log(&apos;Generating accounting reports...&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let department: Department; // 允许创建一个对抽象类型的引用</span><br><span class="line">department = new Department(); // 错误: 不能创建一个抽象类的实例</span><br><span class="line">department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值</span><br><span class="line">department.printName();</span><br><span class="line">department.printMeeting();</span><br><span class="line">department.generateReports(); // 错误: 方法在声明的抽象类中不存在</span><br></pre></td></tr></table></figure><h2 id="类-amp-接口-继承关系"><a href="#类-amp-接口-继承关系" class="headerlink" title="类&amp;接口-继承关系"></a>类&amp;接口-继承关系</h2><ul><li>接口：多继承，可继承自类（继承类的方法签名和属性签名）</li><li>类：单继承，实现多接口</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>定义函数类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方式1</span><br><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">// 方式2</span><br><span class="line">let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;</span><br><span class="line">// 方式3</span><br><span class="line">let myAdd: (x: number, y: number) =&gt; number =</span><br><span class="line">    function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure><p><strong>可选函数类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 可选参数，必须在函数末尾</span><br><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">    if (lastName)</span><br><span class="line">        return firstName + &quot; &quot; + lastName;</span><br><span class="line">    else</span><br><span class="line">        return firstName;</span><br><span class="line">&#125;</span><br><span class="line">// 为参数设置默认值，等价于参数为可选参数，默认值参数不需要在函数末尾</span><br><span class="line">function buildName1(firstName: string, lastName = &quot;Smith&quot;) &#123;</span><br><span class="line">    return firstName + &quot; &quot; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">function buildName2(firstName: string, lastName: string = &quot;Smith&quot;) &#123;</span><br><span class="line">    return firstName + &quot; &quot; + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剩余函数：效果和 java 类似</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, ...restOfName: string[]) &#123;</span><br><span class="line">  return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);</span><br></pre></td></tr></table></figure><p><strong>重载函数：和 java 这类编译器语言有所不同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line"></span><br><span class="line">  // 方法1</span><br><span class="line">  public test(para: string): number;</span><br><span class="line">  // 方法2</span><br><span class="line">  public test(para: number, flag: boolean): number;</span><br><span class="line"></span><br><span class="line">  // 具体实现</span><br><span class="line">  public test(para: string | number, flag?: boolean): number &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new SomeClass().test(1, true);</span><br><span class="line">new SomeClass().test(&apos;1&apos;);</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型声明：和 java 类似</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str: string = identity(&apos;str&apos;);</span><br><span class="line">let num: number = identity(0);</span><br></pre></td></tr></table></figure><p><strong>泛型接口&amp;泛型类：与 java 类似</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 泛型接口</span><br><span class="line">interface GenericIdentityInterface&lt;T&gt; &#123;</span><br><span class="line">  identity(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 泛型类</span><br><span class="line">class GenericIdentityClass&lt;V&gt; implements GenericIdentityInterface&lt;string&gt; &#123;</span><br><span class="line">  prop: V;</span><br><span class="line"></span><br><span class="line">  constructor(prop: V) &#123;</span><br><span class="line">    this.prop = prop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getProp(): V &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  identity(arg: string): string &#123;</span><br><span class="line">    return arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">let interfaces: GenericIdentityInterface&lt;string&gt; = new GenericIdentityClass(&apos;str&apos;);</span><br><span class="line">let clazz: GenericIdentityClass&lt;string&gt; = new GenericIdentityClass(&apos;str&apos;);</span><br></pre></td></tr></table></figure><p><strong>泛型约束：和 java 类似</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length); // Now we know it has a .length property, so no more error</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><strong>数字枚举：和 java 类似</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up = 1,// 枚举值从1开始，并向后递增</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串枚举：枚举值通过字符串来表示，更加符合语义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up = &quot;UP&quot;,// 字符串枚举，每个枚举值都必须进行赋值</span><br><span class="line">    Down = &quot;DOWN&quot;,</span><br><span class="line">    Left = &quot;LEFT&quot;,</span><br><span class="line">    Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li>for..in 迭代的是对象的 键 的列表</li><li>for..of 迭代的是对象的键对应的值 的列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let list = [4, 5, 6];</span><br><span class="line">// 迭代对象为键</span><br><span class="line">for (let i in list) &#123;</span><br><span class="line">    console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,</span><br><span class="line">&#125;</span><br><span class="line">// 迭代对象为键对应的值</span><br><span class="line">for (let i of list) &#123;</span><br><span class="line">    console.log(i); // &quot;4&quot;, &quot;5&quot;, &quot;6&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-Https单向认证和双向认证</title>
      <link href="/2019/05/26/%E7%BD%91%E7%BB%9C-Https%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
      <url>/2019/05/26/%E7%BD%91%E7%BB%9C-Https%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="SSL协议加密方式"><a href="#SSL协议加密方式" class="headerlink" title="SSL协议加密方式"></a>SSL协议加密方式</h2><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><ul><li><p>对称加密<br>速度高，可加密内容较大，用来加密会话过程中的消息</p></li><li><p>公钥加密<br>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p></li></ul><h2 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h2><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：<br><img width="900" src="/image/network_check_1.jpeg"></p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ul><li>证书是否过期</li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ul></li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</li><li>服务器将选择好的加密方案通过明文方式返回给客户端</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</li></ol><h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：<br><img width="900" src="/image/network_check_2.jpeg"></p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：<ul><li>证书是否过期</li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li><li>验证通过后，将继续进行通信，否则，终止通信</li></ul></li><li>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-Kotlin赶潮流学习</title>
      <link href="/2019/05/20/Android-Kotlin%E8%B5%B6%E6%BD%AE%E6%B5%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/05/20/Android-Kotlin%E8%B5%B6%E6%BD%AE%E6%B5%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Kotlin-语法糖理解"><a href="#Kotlin-语法糖理解" class="headerlink" title="Kotlin 语法糖理解"></a>Kotlin 语法糖理解</h2><p>Kotlin 和 Java 都是运行在 JVM 上，最终都会转化成 bytecode。因而将同一份 bytecode 反编译成 Java 和 Kotlin 文件是等价的。<br>将 Kotlin 编译后的 bytecode 反编译成 Java，再进行语法对比，从而了解语法糖到底干了些什么。</p><p>以 object 单例为例，比对结果如下：<br><img src="/image/android_kotlin_compare_1.png" alt=""></p><h2 id="Kotlin-编写-SDK-对-App-的影响"><a href="#Kotlin-编写-SDK-对-App-的影响" class="headerlink" title="Kotlin 编写 SDK 对 App 的影响"></a>Kotlin 编写 SDK 对 App 的影响</h2><p>Kotlin 语法糖在编译后，最终会调用 kotlin-stdlib 方法。因此，在 SDK 中使用 Kotlin，会为使用此 SDK 的 App 引入 kotlin-stdlib 包。在未混淆的情况下，会给 App 增加 600KB 的源码体积。</p><p>引入 Kotlin 之后，会增加以下依赖库：</p><ul><li>org.jetbrains.kotlin:kotlin-stdlib-jdk8: 是 Kotlin JVM 运行环境标准库的 Java 8 扩展版</li><li>org.jetbrains.kotlin:kotlin-stdlib-jdk7: 是 Kotlin JVM 运行环境标准库的 Java 7 扩展版</li><li>org.jetbrains.kotlin:kotlin-stdlib: 是 Kotlin JVM 运行环境的标准库</li><li>org.jetbrains.kotlin:kotlin-stdlib-common: 是 Kotlin 运行环境的标准库的公共实现。<code>kotlin-stdlib-js</code>与<code>kotlin-stdlib</code>都依赖此库，作为标准库的通用逻辑实现库</li><li>org.jetbrains:annotations: 老东家的注解包，辅助<code>kotlin-stdlib</code>实现注解元信息的作用</li></ul><p>依赖关系如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.31</span><br><span class="line">     +--- org.jetbrains.kotlin:kotlin-stdlib:1.3.31</span><br><span class="line">     |    +--- org.jetbrains.kotlin:kotlin-stdlib-common:1.3.31</span><br><span class="line">     |    \--- org.jetbrains:annotations:13.0</span><br><span class="line">     \--- org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.3.31</span><br><span class="line">          \--- org.jetbrains.kotlin:kotlin-stdlib:1.3.31 (*)</span><br></pre></td></tr></table></figure><p>SDK 中使用 Kotlin 的推荐配置如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// kotlin 标准库</span></span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span></span><br><span class="line"><span class="comment">//    // 要使用java 7特性时，使用kotlin-stdlib-jdk7依赖库，不推荐</span></span><br><span class="line"><span class="comment">//    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"</span></span><br><span class="line"><span class="comment">//    // 要使用java 8特性时，使用kotlin-stdlib-jdk8依赖库，不推荐</span></span><br><span class="line"><span class="comment">//    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插件-kotlin-android-extensions-介绍"><a href="#插件-kotlin-android-extensions-介绍" class="headerlink" title="插件 kotlin-android-extensions 介绍"></a>插件 kotlin-android-extensions 介绍</h2><p>Kotlin Android Extensions 是 Kotlin 官方推出的简化 Android 开发的 Gradle 插件。目前主要针对如下几种场景：</p><ul><li>View Binding：即 UI 绑定，不需要再依赖其它 library(如 butterknife)，即可实现 UI 绑定</li><li>View Caching：UI 缓存，内置已实现了 UI 的缓存策略</li><li>Parcelable：使用注解即可实现 Android 的 Parcelable 序列化</li></ul><p><strong>注: 个人感觉这个插件意义不大</strong></p><h2 id="Kotlin-在编译时对比"><a href="#Kotlin-在编译时对比" class="headerlink" title="Kotlin 在编译时对比"></a>Kotlin 在编译时对比</h2><p>通过编译任务对比，发现<code>kotlin-android</code>为编译任务多添加了一个<code>compileXXXXKotlin</code>任务。该任务的目标是将 kotlin 代码编译成 jvm 字节码<br><img src="/image/android_kotlin_compare_1.png" alt=""></p><p>源码版本为 <code>kotlin-gradle-plugin:1.3.31</code></p><p>插件 <code>kotlin-android</code> 定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// kotlin-android.properties</span><br><span class="line">implementation-class=org.jetbrains.kotlin.gradle.plugin.KotlinAndroidPluginWrapper</span><br></pre></td></tr></table></figure><p>Kotlin 编译 <code>compileXXXXKotlin</code> 任务<br>实现类为 org.jetbrains.kotlin.gradle.tasks.Tasks.kt 内部类 KotlinCompile</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://droidyue.com/blog/2017/05/08/how-to-study-kotlin/" target="_blank" rel="noopener">https://droidyue.com/blog/2017/05/08/how-to-study-kotlin/</a><br><a href="https://www.kotlincn.net/docs/reference/basic-syntax.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/basic-syntax.html</a><br><a href="https://blog.csdn.net/tscyds/article/details/79668536" target="_blank" rel="noopener">https://blog.csdn.net/tscyds/article/details/79668536</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-编译版本到底做了啥?</title>
      <link href="/2019/05/10/Android-%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E5%95%A5/"/>
      <url>/2019/05/10/Android-%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E5%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h2><p>应用编译时使用的sdk版本(仅编译时生效，与运行时无关)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 我们日常开发中编译、打包apk时使用的android sdk版本就是由compileSdkVersion指定的</span><br><span class="line">2. 代码中可用的api也与该版本对应，高于声明版本的api则无法找到、使用</span><br><span class="line">3. 顺带一提，buildtools的版本要与compileSdkVersion保持一致</span><br><span class="line">4. 推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备</span><br></pre></td></tr></table></figure><h2 id="buildToolsVersion"><a href="#buildToolsVersion" class="headerlink" title="buildToolsVersion"></a>buildToolsVersion</h2><p>buildToolsVersion 是 Android SDK 构建工具，是构建 Android 应用程序所需的 Android SDK 的一个组件。它安装在 <sdk>/build-tools/ 目录中，它只是构建工具</sdk></p><h2 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h2><p>一个用于指定应用运行所需最低 API 级别的整数。 如果系统的 API 级别低于该属性中指定的值，Android 系统将阻止用户安装应用</p><h2 id="maxSdkVersion"><a href="#maxSdkVersion" class="headerlink" title="maxSdkVersion"></a>maxSdkVersion</h2><p>一个指定作为应用设计运行目标的最高 API 级别的整数，新版本平台完全向前兼容，所以默认支持到最高版本</p><h2 id="targetSdkVersion（重要）"><a href="#targetSdkVersion（重要）" class="headerlink" title="targetSdkVersion（重要）"></a>targetSdkVersion（重要）</h2><p>应用运行时使用的sdk版本，指定的android sdk的功能特性，将在运行时生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">举个例子，比如android6.0(api 23)系统的动态权限检查功能</span><br><span class="line">1、targetSdkVersion&lt;23时：</span><br><span class="line">该应用安装在android6.0的手机上后，</span><br><span class="line">不会执行android6.0系统以上特有的动态权限检查逻辑，</span><br><span class="line">而是仍继续执行以前的权限检查逻辑。</span><br><span class="line"></span><br><span class="line">2、当targetSdkVersion变为23后：</span><br><span class="line">android6.0系统的动态权限检查特性将生效。</span><br><span class="line"></span><br><span class="line">3、当targetSdkVersion为25(代表android7.0)&gt;23：</span><br><span class="line">安装在android6.0的设备上时，</span><br><span class="line">仍只能执行6.0及其以下的功能特性，无法执行7.0的新特性。</span><br><span class="line"></span><br><span class="line">通常targetSdkVersion 小于等于 compileSdkVersion，</span><br><span class="line">一般都是在compileSdkVersion指定的版本编译并测试过相关特性没有问题后，</span><br><span class="line">才将targetSdkVersion改为compileSdkVersion的版本</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git-git config使用介绍</title>
      <link href="/2019/05/08/Git-git-config%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/08/Git-git-config%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git 提供了一个叫做 git config 的工具。主要用来配置或者读取相应的环境变量。而这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。</p><h2 id="配置文件的位置"><a href="#配置文件的位置" class="headerlink" title="配置文件的位置"></a>配置文件的位置</h2><p>git config 文件的存放位置主要有三个处：</p><ul><li><strong>./etc/gitconfig 文件</strong>：包含了适用于系统所有用户和所有Git仓库的值。可以通过传递 <code>--system</code> 使 Git 读或写这个特定的文件。</li><li><strong>~/.gitconfig 文件</strong>：具体到当前用户和当前用户Git仓库的值。可以通过传递 <code>--global</code> 使 Git 读或写这个特定的文件。</li><li><strong>gitDir/.git/config 文件</strong>：特定指向工作区的单一的Git仓库。每个级别重写前一个级别的值。</li></ul><p>覆盖规则如下：</p><ul><li>gitDir/.git/config -&gt; ~/.gitconfig -&gt; ./etc/gitconfig</li></ul><h2 id="查看当前Git仓库配置"><a href="#查看当前Git仓库配置" class="headerlink" title="查看当前Git仓库配置"></a>查看当前Git仓库配置</h2><p>如果你想查看当前Git仓库的配置，你可以使用 <code>git config --list</code> 命令来列出Git在该处找到的所有的设置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">daiyibodeMacBook-Pro:maven-upload-tool daiyibo$ git config --list</span><br><span class="line">user.name=daiyibo</span><br><span class="line">user.email=daiyibo@souche.com</span><br><span class="line">core.autocrlf=input</span><br><span class="line">core.excludesfile=/Users/daiyibo/.gitignore_global</span><br><span class="line">difftool.sourcetree.cmd=opendiff "$LOCAL" "$REMOTE"</span><br><span class="line">difftool.sourcetree.path=</span><br><span class="line">mergetool.sourcetree.cmd=/Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh "$LOCAL" "$REMOTE" -ancestor "$BASE" -merge "$MERGED"</span><br><span class="line">mergetool.sourcetree.trustexitcode=true</span><br><span class="line">color.ui=auto</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=true</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.ignorecase=true</span><br><span class="line">core.precomposeunicode=true</span><br><span class="line">remote.origin.url=git@git.souche-inc.com:souche-wireless-architecture/Pakun/maven-upload-tool.git</span><br><span class="line">remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*</span><br><span class="line">branch.master.remote=origin</span><br><span class="line">branch.master.merge=refs/heads/master</span><br></pre></td></tr></table></figure><h2 id="调整-git-config文件"><a href="#调整-git-config文件" class="headerlink" title="调整.git/config文件"></a>调整.git/config文件</h2><p>调整git仓库是否支持大小写，其实是在<code>gitDir/.git/config</code>下修改了配置项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">daiyibodeMacBook-Pro:maven-upload-tool daiyibo$ cat .git/config | grep "ignorecase"</span><br><span class="line">ignorecase = true</span><br><span class="line">daiyibodeMacBook-Pro:maven-upload-tool daiyibo$ git config core.ignorecase false</span><br><span class="line">daiyibodeMacBook-Pro:maven-upload-tool daiyibo$ cat .git/config | grep "ignorecase"</span><br><span class="line">ignorecase = false</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/79253737" target="_blank" rel="noopener">https://blog.csdn.net/gdutxiaoxu/article/details/79253737</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-Gradle大杂烩</title>
      <link href="/2019/05/04/Android-Gradle%E5%AE%9E%E6%88%98/"/>
      <url>/2019/05/04/Android-Gradle%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Gradle-常用操作"><a href="#Gradle-常用操作" class="headerlink" title="Gradle 常用操作"></a>Gradle 常用操作</h2><ul><li><strong>doFirst</strong>：任务最先执行的 action</li><li><strong>doLast</strong>：任务最后执行的 action</li><li><strong>dependsOn</strong>：任务之间存在依赖关系</li><li><strong>finalizedBy</strong>：任务执行完之后，要执行的任务</li><li><strong>mustRunAfter</strong>：当两个任务同时存在时，任务之间存在优先级关系</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">task stand &#123;</span><br><span class="line"></span><br><span class="line">    group=<span class="string">'behavior'</span></span><br><span class="line">    description=<span class="string">'stand -&gt; walk -&gt; run'</span></span><br><span class="line"></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">'doFirst: stand'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'doLast: stand'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task jump &#123;</span><br><span class="line"></span><br><span class="line">    group=<span class="string">'behavior'</span></span><br><span class="line">    description=<span class="string">'jump -&gt; run'</span></span><br><span class="line"></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">'doFirst: jump'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'doLast: jump'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task walk &#123;</span><br><span class="line"></span><br><span class="line">    group=<span class="string">'behavior'</span></span><br><span class="line">    description=<span class="string">'walk -&gt; run'</span></span><br><span class="line"></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">'doFirst: walk'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'doLast: walk'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task run &#123;</span><br><span class="line"></span><br><span class="line">    group=<span class="string">'behavior'</span></span><br><span class="line">    description=<span class="string">'run, run, run ~'</span></span><br><span class="line"></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">'doFirst: run'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'doLast: run'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task rest &#123;</span><br><span class="line"></span><br><span class="line">    group=<span class="string">'behavior'</span></span><br><span class="line">    description=<span class="string">'take a rest'</span></span><br><span class="line"></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">'doFirst: rest'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'doLast: rest'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">walk.dependsOn stand</span><br><span class="line">jump.dependsOn stand</span><br><span class="line">run.dependsOn walk</span><br><span class="line">run.dependsOn jump</span><br><span class="line">jump.mustRunAfter walk</span><br><span class="line">run.finalizedBy rest</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下：</span></span><br><span class="line">MacBook-<span class="string">Pro:</span>temp daiyibo$ ./gradlew -q run</span><br><span class="line"><span class="string">doFirst:</span> stand</span><br><span class="line"><span class="string">doLast:</span> stand</span><br><span class="line"><span class="string">doFirst:</span> walk</span><br><span class="line"><span class="string">doLast:</span> walk</span><br><span class="line"><span class="string">doFirst:</span> jump</span><br><span class="line"><span class="string">doLast:</span> jump</span><br><span class="line"><span class="string">doFirst:</span> run</span><br><span class="line"><span class="string">doLast:</span> run</span><br><span class="line"><span class="string">doFirst:</span> rest</span><br><span class="line"><span class="string">doLast:</span> rest</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/lzyzsd/article/details/46935405" target="_blank" rel="noopener">https://blog.csdn.net/lzyzsd/article/details/46935405</a></p><h2 id="Gradle-Wrapper-的作用"><a href="#Gradle-Wrapper-的作用" class="headerlink" title="Gradle Wrapper 的作用"></a>Gradle Wrapper 的作用</h2><p>Gradle Wrapper，它是一个脚本，能够指定 Gradle 的版本。使用 Gradle Wrapper 启动 Gradle 时，如果指定版本的 Gradle 没有被下载关联，会先从 Gradle 官方仓库下载该版本 Gradle 到用户本地，并使用下载的 Gradle 执行任务。这样就标准化了项目，提高了开发效率。</p><p>以 Linux 为例，在调用 gradlew 执行任务时，实际上是通过 shell 在执行 gradlew 脚本任务。这个脚本任务，间接通过 jre 调起工作目录下的 gradle/wrapper/gradle-wrapper.jar。由 gradle-wrapper.jar 来负责处理 gradle 的版本控制和任务执行。</p><p>参考文章：<a href="http://liuwangshu.cn/application/gradle/4-wrapper.html" target="_blank" rel="noopener">http://liuwangshu.cn/application/gradle/4-wrapper.html</a></p><h2 id="Gradle-插件类型"><a href="#Gradle-插件类型" class="headerlink" title="Gradle 插件类型"></a>Gradle 插件类型</h2><p>在 Gradle 中一般有两种类型的插件，分别叫做脚本插件和对象插件。脚本插件是额外的构建脚本，它会进一步配置构建，可以把它理解为一个普通的 build.gradle。对象插件又叫做二进制插件，是实现了 Plugin 接口的类。</p><ul><li>脚本插件，相当于写了一个 xxx.gradle 脚本，在 build.gradle 中引入了这个脚本。例如：<a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">gradle-mvn-push</a></li><li>对象插件，就是实现了 org.gradle.api.plugins<project>接口的插件，例如常见的字节码插桩的编译时插件</project></li></ul><p>参考：<a href="http://liuwangshu.cn/application/gradle/5-plugins.html" target="_blank" rel="noopener">http://liuwangshu.cn/application/gradle/5-plugins.html</a></p><h2 id="Gradle-生命周期"><a href="#Gradle-生命周期" class="headerlink" title="Gradle 生命周期"></a>Gradle 生命周期</h2><p>Gradle 生命周期有三个阶段，分别是：实例化阶段-&gt;配置阶段-&gt;执行阶段</p><ul><li><strong>初始化阶段</strong>：通过 settings.gradle 判断有哪些项目需要初始化,加载所有需要初始化的项目的 build.gradle 文件并为每个项目创建 project 对象</li><li><strong>配置阶段</strong>：执行各项目下的 build.gradle 脚本，完成 project 的配置，并且构造 Task 任务依赖关系图以便在执行阶段按照依赖关系执行 Task.执行 task 中的配置代码</li><li><strong>执行阶段</strong>： 通过配置阶段的 Task 图,按顺序执行需要执行的 任务中的动作代码,就是执行任务中写在 doFirst 或 doLast 中的代码</li></ul><p><img width="600" src="/image/gradle_lifecycle.jpg"></p><p>参考：<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/build_lifecycle.html</a><br>参考：<a href="https://www.heqiangfly.com/2016/03/18/development-tool-gradle-lifecycle/" target="_blank" rel="noopener">https://www.heqiangfly.com/2016/03/18/development-tool-gradle-lifecycle/</a></p><h2 id="理解-groovy-的闭包"><a href="#理解-groovy-的闭包" class="headerlink" title="理解 groovy 的闭包"></a>理解 groovy 的闭包</h2><p>闭包（Closure）是很多编程语言中很重要的概念，那么 Groovy 中闭包是什么，官方定义是“Groovy 中的闭包是一个开放，匿名的代码块，可以接受参数，返回值并分配给变量”，简而言之，他说一个匿名的代码块，可以接受参数，有返回值</p><h4 id="声明和使用"><a href="#声明和使用" class="headerlink" title="声明和使用"></a>声明和使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/** 闭包结构 **/</span><br><span class="line">&#123; [closureParameters -&gt; ] statements &#125;</span><br><span class="line"></span><br><span class="line">/** 举例 **/</span><br><span class="line">//执行一句话</span><br><span class="line">&#123; printf &apos;Hello World&apos; &#125;</span><br><span class="line"></span><br><span class="line">//闭包有默认参数it，且不用申明</span><br><span class="line">&#123; println it &#125;</span><br><span class="line"></span><br><span class="line">//闭包有默认参数it，申明了也无所谓</span><br><span class="line">&#123; it -&gt; println it &#125;</span><br><span class="line"></span><br><span class="line">// name是自定义的参数名</span><br><span class="line">&#123; name -&gt; println name &#125;</span><br><span class="line"></span><br><span class="line"> //多个参数的闭包</span><br><span class="line">&#123; String x, int y -&gt;</span><br><span class="line">    println &quot;hey $&#123;x&#125; the value is $&#123;y&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="闭包内的对象：this，owner，delegate"><a href="#闭包内的对象：this，owner，delegate" class="headerlink" title="闭包内的对象：this，owner，delegate"></a>闭包内的对象：this，owner，delegate</h4><ul><li><strong>this</strong>：对应于定义闭包的那个类，如果在内部类中定义，指向的是内部类</li><li><strong>owenr</strong>：对应于定义闭包的那个类或者闭包，如果在闭包中定义，对应闭包，否则同 this 一致</li><li><strong>delegate</strong>：默认是和 owner 一致，或者自定义 delegate 指向</li></ul><h4 id="闭包内的-delegate-策略"><a href="#闭包内的-delegate-策略" class="headerlink" title="闭包内的 delegate 策略"></a>闭包内的 delegate 策略</h4><ul><li><strong>Closure.OWNER_FIRST</strong>：是默认策略。优先在 owner 寻找，owner 没有再 delegate</li><li><strong>Closure.DELEGATE_FIRST</strong>：优先在 delegate 寻找，delegate 没有再 owner</li><li><strong>Closure.OWNER_ONLY</strong>：只在 owner 中寻找</li><li><strong>Closure.DELEGATE_ONLY</strong>：只在 delegate 中寻找</li><li><strong>Closure.TO_SELF</strong>：自定义策略，未指定属性位置时，都通过自定义策略来获取属性值</li></ul><p>参考：<a href="https://www.jianshu.com/p/6dc2074480b8" target="_blank" rel="noopener">https://www.jianshu.com/p/6dc2074480b8</a><br>参考：<a href="http://www.groovy-lang.org/closures.html" target="_blank" rel="noopener">http://www.groovy-lang.org/closures.html</a><br>参考：<a href="http://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html" target="_blank" rel="noopener">http://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html</a><br>参考：<a href="https://www.jianshu.com/p/ae10f75b37cf" target="_blank" rel="noopener">https://www.jianshu.com/p/ae10f75b37cf</a></p><h1 id="gradle-执行-Android-app-运行任务的原理"><a href="#gradle-执行-Android-app-运行任务的原理" class="headerlink" title="gradle 执行 Android app 运行任务的原理"></a>gradle 执行 Android app 运行任务的原理</h1><p>参考：<a href="https://mp.weixin.qq.com/s/aqo6ueTUxEOdGx5tyzQrPQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aqo6ueTUxEOdGx5tyzQrPQ</a><br>参考：<a href="https://mp.weixin.qq.com/s/DzuLtqx_CBFm9tJos9j2Ag" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DzuLtqx_CBFm9tJos9j2Ag</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Gradle 核心思想：<a href="http://liuwangshu.cn/tags/Gradle%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/" target="_blank" rel="noopener">http://liuwangshu.cn/tags/Gradle%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</a><br>搞定 Groovy 闭包这一篇就够了：<a href="https://www.jianshu.com/p/6dc2074480b8" target="_blank" rel="noopener">https://www.jianshu.com/p/6dc2074480b8</a><br>Groovy-Closures 官方文档：<a href="http://www.groovy-lang.org/closures.html" target="_blank" rel="noopener">http://www.groovy-lang.org/closures.html</a><br>Groovy-DSL 官方文档：<a href="http://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html" target="_blank" rel="noopener">http://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html</a><br>Groovy-Closures 官方文档-翻译节选：<a href="https://www.jianshu.com/p/ae10f75b37cf" target="_blank" rel="noopener">https://www.jianshu.com/p/ae10f75b37cf</a><br>Gradle-构建生命周期：<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/build_lifecycle.html</a><br>Gradle tip #3-指定 Task 顺序：<a href="https://blog.csdn.net/lzyzsd/article/details/46935405" target="_blank" rel="noopener">https://blog.csdn.net/lzyzsd/article/details/46935405</a><br>Gradle 使用指南-Gradle 生命周期：<a href="https://www.heqiangfly.com/2016/03/18/development-tool-gradle-lifecycle/" target="_blank" rel="noopener">https://www.heqiangfly.com/2016/03/18/development-tool-gradle-lifecycle/</a><br>实战 Gradle<em>中文完整版.pdf：[点击打开](/image/实战 Gradle</em>中文完整版@<a href="http://www.jqhtml.com.pdf" target="_blank" rel="noopener">www.jqhtml.com.pdf</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git-文件大小写补漏</title>
      <link href="/2019/04/15/Git-%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%86%99%E8%A1%A5%E6%BC%8F/"/>
      <url>/2019/04/15/Git-%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%86%99%E8%A1%A5%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么解决Git文件大小？"><a href="#怎么解决Git文件大小？" class="headerlink" title="怎么解决Git文件大小？"></a>怎么解决Git文件大小？</h2><h3 id="使用Git-MV-★★★"><a href="#使用Git-MV-★★★" class="headerlink" title="使用Git MV ★★★"></a>使用Git MV ★★★</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv xxx.file XXX.file</span><br></pre></td></tr></table></figure><h3 id="手动修改-★★"><a href="#手动修改-★★" class="headerlink" title="手动修改 ★★"></a>手动修改 ★★</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 删除原文件</span><br><span class="line">git rm xxx.file</span><br><span class="line">// 修改文件名，大小写进行区分</span><br><span class="line">mv xxx.file XXX.file</span><br><span class="line">// 提交新文件</span><br><span class="line">git add XXX.file</span><br></pre></td></tr></table></figure><h3 id="配置Git仓库-★"><a href="#配置Git仓库-★" class="headerlink" title="配置Git仓库 ★"></a>配置Git仓库 ★</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 关闭忽略大小写配置</span><br><span class="line">git config core.ignorecase false</span><br><span class="line">// 打开忽略大小写配置</span><br><span class="line">git config core.ignorecase true</span><br></pre></td></tr></table></figure><h2 id="git为什么默认不区分文件大小写？"><a href="#git为什么默认不区分文件大小写？" class="headerlink" title="git为什么默认不区分文件大小写？"></a>git为什么默认不区分文件大小写？</h2><p>macOS 默认是『 Mac OS 扩展（日志式）』格式的磁盘，这个是不区分大小写的，而 Linux 是区分大小写的，所以其实还是要注意这个方面把。</p><p>另外你可以把磁盘抹成『 Mac OS 扩展（区分大小写，日志式）』，但是有些软件可能就挂了，所以还是别瞎折腾了。</p><p>可以通过 git mv 操作来避免 git 未识别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv myfolder tmp</span><br><span class="line">git mv tmp MyFolder</span><br></pre></td></tr></table></figure><p>你也可以修改 git config 来达到区分大小写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.ignorecase false</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/haojiahong/p/5594257.html" target="_blank" rel="noopener">https://www.cnblogs.com/haojiahong/p/5594257.html</a><br><a href="https://www.zhihu.com/question/57779034" target="_blank" rel="noopener">https://www.zhihu.com/question/57779034</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-Dalvik虚拟机记录</title>
      <link href="/2019/04/07/Android-Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/04/07/Android-Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="LocalSocket-介绍"><a href="#LocalSocket-介绍" class="headerlink" title="LocalSocket 介绍"></a>LocalSocket 介绍</h2><p>简介：<a href="http://www.cnblogs.com/bastard/archive/2012/10/09/2717052.html" target="_blank" rel="noopener">http://www.cnblogs.com/bastard/archive/2012/10/09/2717052.html</a><br>代码示例：<a href="https://blog.csdn.net/azhengye/article/details/73863404#localsocket%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B" target="_blank" rel="noopener">https://blog.csdn.net/azhengye/article/details/73863404#localsocket%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B</a></p><h2 id="Dalvik-虚拟机"><a href="#Dalvik-虚拟机" class="headerlink" title="Dalvik 虚拟机"></a>Dalvik 虚拟机</h2><p>学习计划：<a href="https://blog.csdn.net/luoshengyang/article/details/41338251" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/41338251</a><br>Dalvik 虚拟机简要介绍：<a href="https://blog.csdn.net/luoshengyang/article/details/8852432" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/8852432</a><br>系统进程 Zygote 启动过程：<a href="https://blog.csdn.net/luoshengyang/article/details/6768304" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/6768304</a><br>Dalvik 虚拟机的启动过程分析：<a href="https://blog.csdn.net/luoshengyang/article/details/8885792" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/8885792</a><br>Dalvik 虚拟机的运行过程分析：<a href="https://blog.csdn.net/luoshengyang/article/details/8914953" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/8914953</a></p><h2 id="初始化描述文件-init-rc"><a href="#初始化描述文件-init-rc" class="headerlink" title="初始化描述文件 init.rc"></a>初始化描述文件 init.rc</h2><p>Android 初始化语言：<a href="https://blog.csdn.net/xusiwei1236/article/details/41577231" target="_blank" rel="noopener">https://blog.csdn.net/xusiwei1236/article/details/41577231</a><br>init.rc 文件解析：<a href="https://blog.csdn.net/u010223349/article/details/8829613" target="_blank" rel="noopener">https://blog.csdn.net/u010223349/article/details/8829613</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-搭建Jenkins服务流程</title>
      <link href="/2019/03/22/Android-%E6%90%AD%E5%BB%BAJenkins%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/03/22/Android-%E6%90%AD%E5%BB%BAJenkins%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="持续集成简介"><a href="#持续集成简介" class="headerlink" title="持续集成简介"></a>持续集成简介</h2><p>持续集成指的是，频繁地（一天多次）将代码集成到主干。</p><p>它的好处主要有两个。</p><ol><li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li><li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li></ol><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">持续集成是什么？</a><br><a href="https://www.zhihu.com/question/23444990" target="_blank" rel="noopener">如何理解持续集成、持续交付、持续部署？</a></p></blockquote><h2 id="Jenkins安装篇"><a href="#Jenkins安装篇" class="headerlink" title="Jenkins安装篇"></a>Jenkins安装篇</h2><ul><li>安装Java运行环境：Jenkins的运行依赖Java环境，所以在安装Jenkins之前必须要安装JDK或JRE</li><li><p>安装Jenkins工具：在mac上安装Jenkins服务极其简单，只需要下载<a href="https://jenkins.io/download/" target="_blank" rel="noopener">Jenkins安装包</a>，双击安装即可</p></li><li><p>启动和停止Jenkins服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 启动Jenkins</span><br><span class="line">sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</span><br><span class="line">// 终止Jenkins</span><br><span class="line">sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</span><br></pre></td></tr></table></figure></li></ul><h2 id="Jenkins配置Android项目"><a href="#Jenkins配置Android项目" class="headerlink" title="Jenkins配置Android项目"></a>Jenkins配置Android项目</h2><ul><li>全局配置android环境，gradle环境，java环境</li><li>配置Git仓库地址</li><li>编写构建Android项目脚本</li><li>编译后文件存档</li></ul><blockquote><p><a href="https://blog.csdn.net/it_talk/article/details/50261229" target="_blank" rel="noopener">Jenkins配置Android项目</a></p></blockquote><h2 id="Jenkins搭建分布式构建"><a href="#Jenkins搭建分布式构建" class="headerlink" title="Jenkins搭建分布式构建"></a>Jenkins搭建分布式构建</h2><ul><li>配置ssh秘钥</li><li>通过ssh建立master与slave之间的关联</li><li>启动节点</li><li>将构建任务分配给slave节点执行</li></ul><blockquote><p><a href="https://blog.csdn.net/jiang1986829/article/details/51141731" target="_blank" rel="noopener">Jenkins创建slave节点-Linux平台</a></p></blockquote><h2 id="Jenkins自动化测试（Sonarqueb）"><a href="#Jenkins自动化测试（Sonarqueb）" class="headerlink" title="Jenkins自动化测试（Sonarqueb）"></a>Jenkins自动化测试（Sonarqueb）</h2><ul><li>安装Sonarqube工具</li><li>配置mysql数据库</li><li>加入扫描插件</li><li>配置jenkins构建工程，加入sonarqueb步骤</li><li>构建，产生报表</li></ul><blockquote><p><a href="https://yq.aliyun.com/articles/541761" target="_blank" rel="noopener">Jenkins+Sonarqueb进行自动化测试和代码质量检测</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://daiyibo.oss-cn-hongkong.aliyuncs.com/blog_file/Jenkins%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%40www.jqhtml.com.pdf" target="_blank" rel="noopener">Jenkins权威指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-Debug调试原理</title>
      <link href="/2019/03/22/Android-Debug%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86/"/>
      <url>/2019/03/22/Android-Debug%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-Debug原理"><a href="#Java-Debug原理" class="headerlink" title="Java-Debug原理"></a>Java-Debug原理</h2><p>JPDA 定义了一个完整独立的体系，它由三个相对独立的层次共同组成，而且规定了它们三者之间的交互方式，或者说定义了它们通信的接口。<br>这三个层次由低到高分别是 Java 虚拟机工具接口（JVMTI），Java 调试线协议（JDWP）以及 Java 调试接口（JDI）。这三个模块把调试过程分解成几个很自然的概念：调试者（debugger）和被调试者（debuggee），以及他们中间的通信器。被调试者运行于我们想调试的 Java 虚拟机之上，它可以通过 JVMTI 这个标准接口，监控当前虚拟机的信息；调试者定义了用户可使用的调试接口，通过这些接口，用户可以对被调试虚拟机发送调试命令，同时调试者接受并显示调试结果。在调试者和被调试着之间，调试命令和调试结果，都是通过 JDWP 的通讯协议传输的。所有的命令被封装成 JDWP 命令包，通过传输层发送给被调试者，被调试者接收到 JDWP 命令包后，解析这个命令并转化为 JVMTI 的调用，在被调试者上运行。类似的，JVMTI 的运行结果，被格式化成 JDWP 数据包，发送给调试者并返回给 JDI 调用。而调试器开发人员就是通过 JDI 得到数据，发出指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            Components                         Debugger Interfaces</span><br><span class="line"></span><br><span class="line">               /    |--------------|</span><br><span class="line">              /     |     VM       |</span><br><span class="line">debuggee ----(      |--------------|  &lt;------- JVM TI - Java VM Tool Interface</span><br><span class="line">              \     |   back-end   |</span><br><span class="line">               \    |--------------|</span><br><span class="line">               /           |</span><br><span class="line">comm channel -(            |  &lt;--------------- JDWP - Java Debug Wire Protocol</span><br><span class="line">               \           |</span><br><span class="line">                    |--------------|</span><br><span class="line">                    | front-end    |</span><br><span class="line">                    |--------------|  &lt;------- JDI - Java Debug Interface</span><br><span class="line">                    |      UI      |</span><br><span class="line">                    |--------------|</span><br></pre></td></tr></table></figure><h2 id="Android相关"><a href="#Android相关" class="headerlink" title="Android相关"></a>Android相关</h2><p>Android调试原理<br>Android调试模型可以看作JPDA框架的具体实现。其中变化比较大的一个是JVM TI适配了Android设备特有的Dalvik虚拟机/ART虚拟机，另一个是JDWP的实现支持ADB和Socket两种通信方式（ADB全称为Android Debug Bridge，是Android系统的一个很重要的调试工具）。整体的调试模型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">             ____________________________________</span><br><span class="line">            |                                    |</span><br><span class="line">            |          ADB Server (host)         |</span><br><span class="line">            |                                    |</span><br><span class="line"> Debugger &lt;---&gt; LocalSocket &lt;----&gt; RemoteSocket  |</span><br><span class="line">            |                           ||       |</span><br><span class="line">            |___________________________||_______|</span><br><span class="line">                                        ||</span><br><span class="line">                              Transport ||</span><br><span class="line">    (TCP for emulator - USB for device) ||</span><br><span class="line">                                        ||</span><br><span class="line">             ___________________________||_______</span><br><span class="line">            |                           ||       |</span><br><span class="line">            |          ADBD  (device)   ||       |</span><br><span class="line">            |                           ||       |</span><br><span class="line">Android-VM  |                           ||       |</span><br><span class="line">JDWP-thread &lt;====&gt; LocalSocket &lt;-&gt; RemoteSocket  |</span><br><span class="line">            |                                    |</span><br><span class="line">            |____________________________________|</span><br></pre></td></tr></table></figure><p>运行在PC上的ADB Server和运行在Android设备上的ADBD守护进程之间通过USB或者无线网络建立连接，分别负责Debugger和Android设备的虚拟机进行通信。一旦连接建立起来，Debugger和Android VM通过“桥梁”进行数据的交换，ADB Server和ADBD对它们来说是透明的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.mtyun.com/library/android-remote-debug" target="_blank" rel="noopener">https://www.mtyun.com/library/android-remote-debug</a><br><a href="https://www.freebuf.com/articles/terminal/114869.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/terminal/114869.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jpda1/index.html?ca=drs-</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/index.html?ca=drs-</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda3/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jpda3/index.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda4/index.html?ca=drs-" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jpda4/index.html?ca=drs-</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法-客户端加密算法乱谈</title>
      <link href="/2019/02/20/%E7%AE%97%E6%B3%95-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B9%B1%E8%B0%88/"/>
      <url>/2019/02/20/%E7%AE%97%E6%B3%95-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B9%B1%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="MD5摘要算法"><a href="#MD5摘要算法" class="headerlink" title="MD5摘要算法"></a>MD5摘要算法</h2><p>漫画MD5摘要：<br><a href="https://juejin.im/entry/59cf56a26fb9a00a4a4ceb64" target="_blank" rel="noopener">https://juejin.im/entry/59cf56a26fb9a00a4a4ceb64</a><br>MD5实现原理：<br><a href="https://blog.csdn.net/u012611878/article/details/54000607" target="_blank" rel="noopener">https://blog.csdn.net/u012611878/article/details/54000607</a></p><h2 id="SHA摘要算法"><a href="#SHA摘要算法" class="headerlink" title="SHA摘要算法"></a>SHA摘要算法</h2><p>漫画SHA摘要：<br><a href="https://www.itcodemonkey.com/article/967.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/967.html</a><br>SHA256原理：<br><a href="https://blog.csdn.net/u011583927/article/details/80905740" target="_blank" rel="noopener">https://blog.csdn.net/u011583927/article/details/80905740</a></p><h2 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h2><p>漫画AES加密：<br><a href="https://juejin.im/entry/59eea418f265da4320026b1f" target="_blank" rel="noopener">https://juejin.im/entry/59eea418f265da4320026b1f</a><br>AES算法简介：<br><a href="https://www.cnblogs.com/luop/p/4334160.html" target="_blank" rel="noopener">https://www.cnblogs.com/luop/p/4334160.html</a><br>AES模式简介：<br><a href="https://blog.poxiao.me/p/advanced-encryption-standard-and-block-cipher-mode/" target="_blank" rel="noopener">https://blog.poxiao.me/p/advanced-encryption-standard-and-block-cipher-mode/</a></p><h2 id="客户端加密总结"><a href="#客户端加密总结" class="headerlink" title="客户端加密总结"></a>客户端加密总结</h2><ol><li>密钥直接明文存在sharedprefs文件中，这是最不安全的。</li><li>密钥直接硬编码在Java代码中，这很不安全，dex文件很容易被逆向成java代码。</li><li>将密钥分成不同的几段，有的存储在文件中、有的存储在代码中，最后将他们拼接起来，可以将整个操作写的很复杂，这因为还是在java层，逆向者只要花点时间，也很容易被逆向。</li><li>用ndk开发，将密钥放在so文件，加密解密操作都在so文件里，这从一定程度上提高了的安全性，挡住了一些逆向者，但是有经验的逆向者还是会使用IDA破解的。</li><li>在so文件中不存储密钥，so文件中对密钥进行加解密操作，将密钥加密后的密钥命名为其他普通文件，存放在assets目录下或者其他目录下，接着在so文件里面添加无关代码（花指令），虽然可以增加静态分析难度，但是可以使用动态调式的方法，追踪加密解密函数，也可以查找到密钥内容。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/24279535" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24279535</a><br><a href="https://zhuanlan.zhihu.com/p/24255780" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24255780</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java-理解Boolean对|=操作符的使用</title>
      <link href="/2019/02/20/Java-%E7%90%86%E8%A7%A3Boolean%E5%AF%B9-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/20/Java-%E7%90%86%E8%A7%A3Boolean%E5%AF%B9-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关于这个操作符的首次理解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> aBool = <span class="keyword">true</span>;</span><br><span class="line">aBool |= <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">boolean</span> aBool = <span class="keyword">true</span>;</span><br><span class="line">aBool = aBool | <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>这里延伸出来两个问题：</p><pre><code>- boolean可以用来做位操作，boolean在内存中的存储方式是怎么样的呢？- 为啥不用 || 来替代 | 进行boolean操作呢？这样做有啥好处呢？</code></pre><h2 id="boolean的内存占用规则"><a href="#boolean的内存占用规则" class="headerlink" title="boolean的内存占用规则"></a>boolean的内存占用规则</h2><p>参考《Java虚拟机规范》得出结论，声明boolean变量时占了4字节，声明数组时单个boolean元素占了1字节。</p><p>通过代码验证以上说法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** java代码 **/</span></span><br><span class="line"><span class="keyword">boolean</span> a;</span><br><span class="line"><span class="comment">// 1: 常量赋值 true</span></span><br><span class="line">a = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 2: 常量赋值 false</span></span><br><span class="line">a = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 3: 创建boolean数组</span></span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 4: 数组中boolean元素赋值 true</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 5: 数组中boolean元素赋值 flase</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** JVM指令助记符 **/</span></span><br><span class="line"><span class="comment">// 1: 常量赋值 true</span></span><br><span class="line"><span class="number">0</span>: iconst_1</span><br><span class="line"><span class="number">1</span>: istore_1</span><br><span class="line"><span class="comment">// 2: 常量赋值 false</span></span><br><span class="line"><span class="number">2</span>: iconst_0</span><br><span class="line"><span class="number">3</span>: istore_1</span><br><span class="line"><span class="comment">// 3: 创建boolean数组</span></span><br><span class="line"><span class="number">4</span>: iconst_1</span><br><span class="line"><span class="number">5</span>: newarray       <span class="keyword">boolean</span></span><br><span class="line"><span class="number">7</span>: astore_2</span><br><span class="line"><span class="comment">// 4: 数组中boolean元素赋值 true</span></span><br><span class="line"><span class="number">8</span>: aload_2</span><br><span class="line"><span class="number">9</span>: iconst_0</span><br><span class="line"><span class="number">10</span>: iconst_1</span><br><span class="line"><span class="number">11</span>: bastore</span><br><span class="line"><span class="comment">// 5: 数组中boolean元素赋值 flase</span></span><br><span class="line"><span class="number">12</span>: aload_2</span><br><span class="line"><span class="number">13</span>: iconst_0</span><br><span class="line"><span class="number">14</span>: iconst_0</span><br><span class="line"><span class="number">15</span>: bastore</span><br><span class="line"><span class="number">16</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><blockquote><p>注：boolean变量在虚拟机中，其实是用int操作来代替的；而boolean数组中变量，其实是用byte来代替的。</p></blockquote><h2 id="boolean中对-和-进行对比操作"><a href="#boolean中对-和-进行对比操作" class="headerlink" title="boolean中对||和|进行对比操作"></a>boolean中对||和|进行对比操作</h2><p>其实说破很简单，||（逻辑或），从操作码中可以看出，只要一个条件为true，就会省略后面的逻辑判断操作，从而做到了逻辑上的简化。而|（按位或），从操作码中可以看出，需要将所有boolean结果分别进行按位操作。所以得出结论，| 的性能，应该要比 || 慢。 以后编码的时候，还是少用为好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** java代码 **/</span></span><br><span class="line"><span class="comment">// 1: 声明变量 b1，b2，b3，b4，b5，b6</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> b3 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b4 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> b5 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b6 = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 2: 逻辑或操作</span></span><br><span class="line"><span class="keyword">boolean</span> return1 = b1 || b2 || b3 || b4 || b5 || b6;</span><br><span class="line"><span class="comment">// 3: 按位或操作</span></span><br><span class="line"><span class="keyword">boolean</span> return2 = b1 | b2 | b3 | b4 | b5 | b6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** JVM指令助记符 **/</span></span><br><span class="line"><span class="comment">// 1: 声明变量 b1，b2，b3，b4，b5，b6</span></span><br><span class="line"><span class="number">0</span>: iconst_1</span><br><span class="line"><span class="number">1</span>: istore_1</span><br><span class="line"><span class="number">2</span>: iconst_0</span><br><span class="line"><span class="number">3</span>: istore_2</span><br><span class="line"><span class="number">4</span>: iconst_1</span><br><span class="line"><span class="number">5</span>: istore_3</span><br><span class="line"><span class="number">6</span>: iconst_0</span><br><span class="line"><span class="number">7</span>: istore        <span class="number">4</span></span><br><span class="line"><span class="number">9</span>: iconst_1</span><br><span class="line"><span class="number">10</span>: istore        <span class="number">5</span></span><br><span class="line"><span class="number">12</span>: iconst_0</span><br><span class="line"><span class="number">13</span>: istore        <span class="number">6</span></span><br><span class="line"><span class="comment">// 2: 逻辑或操作</span></span><br><span class="line"><span class="number">15</span>: iload_1</span><br><span class="line"><span class="number">16</span>: ifne          <span class="number">42</span></span><br><span class="line"><span class="number">19</span>: iload_2</span><br><span class="line"><span class="number">20</span>: ifne          <span class="number">42</span></span><br><span class="line"><span class="number">23</span>: iload_3</span><br><span class="line"><span class="number">24</span>: ifne          <span class="number">42</span></span><br><span class="line"><span class="number">27</span>: iload         <span class="number">4</span></span><br><span class="line"><span class="number">29</span>: ifne          <span class="number">42</span></span><br><span class="line"><span class="number">32</span>: iload         <span class="number">5</span></span><br><span class="line"><span class="number">34</span>: ifne          <span class="number">42</span></span><br><span class="line"><span class="number">37</span>: iload         <span class="number">6</span></span><br><span class="line"><span class="number">39</span>: ifeq          <span class="number">46</span></span><br><span class="line"><span class="number">42</span>: iconst_1</span><br><span class="line"><span class="number">43</span>: goto          <span class="number">47</span></span><br><span class="line"><span class="number">46</span>: iconst_0</span><br><span class="line"><span class="number">47</span>: istore        <span class="number">7</span></span><br><span class="line"><span class="comment">// 3: 按位或操作</span></span><br><span class="line"><span class="number">49</span>: iload_1</span><br><span class="line"><span class="number">50</span>: iload_2</span><br><span class="line"><span class="number">51</span>: ior</span><br><span class="line"><span class="number">52</span>: iload_3</span><br><span class="line"><span class="number">53</span>: ior</span><br><span class="line"><span class="number">54</span>: iload         <span class="number">4</span></span><br><span class="line"><span class="number">56</span>: ior</span><br><span class="line"><span class="number">57</span>: iload         <span class="number">5</span></span><br><span class="line"><span class="number">59</span>: ior</span><br><span class="line"><span class="number">60</span>: iload         <span class="number">6</span></span><br><span class="line"><span class="number">62</span>: ior</span><br><span class="line"><span class="number">63</span>: istore        <span class="number">8</span></span><br><span class="line"><span class="number">65</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/dreamsky1989/article/details/7458259" target="_blank" rel="noopener">https://blog.csdn.net/dreamsky1989/article/details/7458259</a><br><a href="https://www.jianshu.com/p/2f663dc820d0" target="_blank" rel="noopener">https://www.jianshu.com/p/2f663dc820d0</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组织管理-谈谈我对OKR的理解?</title>
      <link href="/2019/02/04/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9OKR%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/02/04/%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86-%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9OKR%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>OKR是一套思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在能促进组织成长的、可衡量的贡献上。</p><h2 id="OKR带来的收益"><a href="#OKR带来的收益" class="headerlink" title="OKR带来的收益"></a>OKR带来的收益</h2><p><img src="/image/okr_earnings.gif" alt="OKR带来的收益"></p><h2 id="OKR制定技巧"><a href="#OKR制定技巧" class="headerlink" title="OKR制定技巧"></a>OKR制定技巧</h2><h3 id="OKR数量"><a href="#OKR数量" class="headerlink" title="OKR数量"></a>OKR数量</h3><p>Objective建议是2~5个，Key Result建议是2~4个</p><h3 id="目标衡量标准（Objective）"><a href="#目标衡量标准（Objective）" class="headerlink" title="目标衡量标准（Objective）"></a>目标衡量标准（Objective）</h3><p><img src="/image/okr_objective.gif" alt="OKR带来的收益"></p><ul><li><strong>挑战性：</strong><br>  目标应当具备鼓舞人心的力量，驱动人们达到更高的绩效。如果你知道10%的提升对你来说轻而易举，那么就不应该把他设置为你的目标。因为这意味着你和过去没什么两样，只是比以前努力了那么一点点而已。但如果你告诉我，你希望你负责的那块要提升50%，你很可能会说：“天啊，要做到这一点，我不得不使出浑身解数。”或者说：“我需要重新思考现在正在处理的X或者Y”。那才是OKR的应有之意。</li><li><strong>可达性：</strong><br>  在指定目标时，你必须要找到理想与现实的平衡点。一方面，我们鼓励你尽可能地将员工的想象力发挥到极致，但这应当有一个度。如果你做得太过火，对公司而言，可能就是一场灾难。</li><li><strong>以季度为周期：</strong><br>  如果你以季度为周期制定OKR，那么你肯定希望在接下来的三个月里，完成点什么。如果你草拟了一个目标，但大家普遍认为这个目标可能需要一年时间才能完成，那么你这个目标就更像是一个战略，或者愿景。</li><li><strong>在团队可控范围之内：</strong><br>  在创建OKR时，都应该确保达成结果在其相应层级内是可控的。通过OKR来促进跨部门协作当然很重要，但当你创建的OKR时，你一定要非常清楚：你应当有办法独立地实现它。</li><li><strong>有商业价值：</strong><br>  提出的目标，必须要有他自己的商业价值。符合公司战略的商业价值。</li><li><strong>定性的：</strong><br>  目标应当代表着你希望完成的那些事，因此他应当以文字的形式而为数字的形式来表述。</li></ul><h3 id="关键节点衡量标准（Key-Result）"><a href="#关键节点衡量标准（Key-Result）" class="headerlink" title="关键节点衡量标准（Key_Result）"></a>关键节点衡量标准（Key_Result）</h3><p><img src="/image/okr_key_result.gif" alt="关键节点衡量标准"></p><ul><li><strong>有挑战的：</strong><br>  设定高挑战性目标，能带来更好的绩效和更高的工作满意度。在可以达到的情况下，将目标设置的具有挑战性。</li><li><strong>定量的：</strong><br>  目标总是定性的，代表一个期望的方向；而KR则应当是定量的，因此可以用数字去衡量我们是否达成了目标。</li><li><strong>具体的：</strong><br>  在制定OKR时，澄清术语和概念、确保理解一致至关重要，这可以促进团队之间无障碍沟通，避免不必要的歧义。</li><li><strong>自主制定：</strong><br>  大多数OKE应当由OKR的负责人自己创建，而非公司强制下发。具体实践时，我们期望的是自上而下和自下而上两者的融合。</li><li><strong>基于进度的：</strong><br>  KR必须要能支持你频繁地看到进步，至少每两个星期要能体现出进度变化。</li><li><strong>上下左右对齐一致：</strong><br>  确信你的OKR既和领导团队实现上下对齐，同时也和你所依赖的团队或者依赖你的团队实现了水平对齐。</li><li><strong>驱动正确的行为表现：</strong><br>  我们建议你仔细考虑每个KR可能会对人们行为产生的影响。不能让团队成员为了完成目标而完成目标。</li></ul><h3 id="OKR类型"><a href="#OKR类型" class="headerlink" title="OKR类型"></a>OKR类型</h3><p>由于绩效管理系统成熟度和数据可获得性上的差异，你可能会使用不止一种类型的KR。下面将对OKR类型做简单介绍。<br><img src="/image/okr_type.gif" alt=""></p><h3 id="OKR打分"><a href="#OKR打分" class="headerlink" title="OKR打分"></a>OKR打分</h3><p><img src="/image/okr_score.gif" alt=""></p><h3 id="用OKR进行日常管理"><a href="#用OKR进行日常管理" class="headerlink" title="用OKR进行日常管理"></a>用OKR进行日常管理</h3><h4 id="日常管理时的关注点"><a href="#日常管理时的关注点" class="headerlink" title="日常管理时的关注点"></a>日常管理时的关注点</h4><ul><li><strong>确定工作优先级：</strong><br>  以OKR为导向，确定工作优先级。这周的工作重点是什么？要做哪些事情才能让OKR的达成更进一步？大家很容易陷入泥潭而忘记了初心，忘记了那些对结果达成最重要的事情。所以明确工作优先级会帮助大家更好的达成OKR。</li><li><strong>状态确认：</strong><br>  评估OKR的进行程度，到季度末期，完成OKR的概率是提高了，还是降低了。</li><li><strong>激发员工敬业度：</strong><br>  OKR应该要能充分激发大家进行创造性思考，以达到前所未有的高度。需要及时了解团队的情绪状态，进行情绪调整。</li><li><strong>从大局出发：</strong><br>  进行上下团队，左右团队的对齐操作。避免重复劳动。</li></ul><h4 id="日常管理的时间节点"><a href="#日常管理的时间节点" class="headerlink" title="日常管理的时间节点"></a>日常管理的时间节点</h4><ul><li><strong>周例会：</strong><br>  周例会有三个目的，评估进度，在问题爆发前识别潜在风险，在使用OKR之初，就严谨地把OKR和基于绩效的管理方法集成到公司文化中，以确保团队持续聚焦。</li><li><strong>季度中期审视：</strong><br>  在季度中期审视OKR，判断团队OKR是否产生了偏差。</li><li><strong>季度评估：</strong><br>  在每个季度结束时，对OKR进行评估，评估完成情况，评估目标走向是否准确。</li></ul><h3 id="OKR与邮件相关联"><a href="#OKR与邮件相关联" class="headerlink" title="OKR与邮件相关联"></a>OKR与邮件相关联</h3><p><img src="/image/okr_email.jpeg" alt=""></p><h3 id="避开OKR中常见的坑"><a href="#避开OKR中常见的坑" class="headerlink" title="避开OKR中常见的坑"></a>避开OKR中常见的坑</h3><ul><li>设置多个目标：如果你设置了过多的目标，所有人都不会记得公司的目标到底是什么。</li><li>设置OKR的时间过短：如果一个目标能够在一周或两周内完成，他顶多算一个任务。</li><li>用绩效指标来驱动目标的完成：如果将OKR和KPI混为一谈，那将没有人愿意主动提示具有挑战性的目标。</li><li>没有设置信心指数：将每个目标能够完成的信心指数都设置为50%，意味着有50%的机会达到目标，挑战一下自己吧。</li><li>没有跟踪信心指数的变化：需要持续关注OKR信心指数的变化，希望随着任务时间的进行，信心指数不断增长。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="/image/OKR源于英特尔和谷歌的目标管理利器.pdf">OKR源于英特尔和谷歌的目标管理利器.pdf</a><br><a href="/image/OKR工作法：谷歌、领英等顶级公司的高绩效秘籍-克里斯蒂娜·沃特克.pdf">OKR工作法：谷歌、领英等顶级公司的高绩效秘籍-克里斯蒂娜·沃特克.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-#转：koa-route路由源码解析</title>
      <link href="/2019/02/03/Node-%E8%BD%AC%EF%BC%9Akoa-route%E8%B7%AF%E7%94%B1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/02/03/Node-%E8%BD%AC%EF%BC%9Akoa-route%E8%B7%AF%E7%94%B1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>koa-route 在 koa 中负责路由分发，是很重要的一环。本打算自己写篇文章总结下的，但在<code>segmentfault</code>上看到了一篇总结得很到位的文章。感觉自己写也就只能写成这样了，所以直接转载了 😂</p><blockquote><p>文章地址：<a href="https://segmentfault.com/a/1190000007468233" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007468233</a></p></blockquote><hr><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="/image/koa_router_method_struct.png" alt=""></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/image/koa_route_method_flow.png" alt=""></p><blockquote><p>上面两张图主要将 koa-router 的整体代码结构和大概的执行流程画了出来，画的不够具体。那下面主要讲 koa-router 中的几处的关键代码解读一下。</p></blockquote><p>读代码首先要找到入口文件，那几乎所有的 node 模块的入口文件都会在 package.json 文件中的 main 属性指明了。koa-router 的入口文件就是 lib/router.js。</p><h2 id="第三方模块说明"><a href="#第三方模块说明" class="headerlink" title="第三方模块说明"></a>第三方模块说明</h2><p>首先先讲几个第三方的 node 模块了解一下，因为后面的代码讲解中会用到，不去看具体实现，只要知道其功能就行：</p><ul><li><strong><a href="https://github.com/koajs/compose" target="_blank" rel="noopener">koa-compose</a></strong>： 提供给它一个中间件数组， 返回一个顺序执行所有中间件的执行函数</li><li><strong><a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a></strong>： node 中支持的 http 动词，就是 http.METHODS，可以在终端输出看看</li><li><strong><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a></strong>： 将路径字符串转换成强大的正则表达式，还可以输出路径参数</li></ul><h2 id="Router-amp-Layer"><a href="#Router-amp-Layer" class="headerlink" title="Router &amp; Layer"></a>Router &amp; Layer</h2><p><img src="/image/koa_route_route_and_layer.png" alt=""></p><p>Router 和 Layer 分别是两个构造函数，分别在 router.js 和 layer.js 中，koa-router 的所有代码也就在这两个文件中，可以知道它的代码量并不是很多。</p><h4 id="Router-创建管理整个路由模块的实例"><a href="#Router-创建管理整个路由模块的实例" class="headerlink" title="Router: 创建管理整个路由模块的实例"></a>Router: 创建管理整个路由模块的实例</h4><ul><li><strong>this.methods</strong>: 在后面要讲的 allowedMethods 方法中要用到的，目的是响应 options 请求和请求出错的处理</li><li><strong>this.params</strong>: 全局的路由参数处理的中间件组成的对象</li><li><strong>this.stack</strong>: 其实就是各个路由(Layer)实例组成的数组。每次处理请求时都需要循环这个数组找到匹配的路由</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 常用的 去new 方式</span></span><br><span class="line">  <span class="comment">// 初始化Router只需要调用require('koa-router')()，而不需要调用new require('koa-router')()方法</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Router)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Router(opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.methods = <span class="keyword">this</span>.opts.methods || [<span class="string">'HEAD'</span>, <span class="string">'OPTIONS'</span>, <span class="string">'GET'</span>, <span class="string">'PUT'</span>, <span class="string">'PATCH'</span>, <span class="string">'POST'</span>, <span class="string">'DELETE'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.params = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.stack = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Layer-创建各个路由实例"><a href="#Layer-创建各个路由实例" class="headerlink" title="Layer: 创建各个路由实例"></a>Layer: 创建各个路由实例</h4><p>这里的 this.stack 和 Router 中的不同，这里的是路由所有的中间件的数组。（一个路由可以有多个中间件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layer</span>(<span class="params">path, methods, middleware, opts</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.stack = <span class="built_in">Array</span>.isArray(middleware) ? middleware : [middleware];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为给后面的allowedMthods处理</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="keyword">this</span>.methods.push(method.toUpperCase());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.methods[l<span class="number">-1</span>] === <span class="string">'GET'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是get请求，则支持head请求</span></span><br><span class="line">      <span class="keyword">this</span>.methods.unshift(<span class="string">'HEAD'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保路由的每个中间件都是函数</span></span><br><span class="line">  <span class="keyword">this</span>.stack.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type = (<span class="keyword">typeof</span> fn);</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        methods.toString() + <span class="string">" `"</span> + (<span class="keyword">this</span>.opts.name || path) +<span class="string">"`: `middleware` "</span></span><br><span class="line">        + <span class="string">"must be a function, not `"</span> + type + <span class="string">"`"</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.path = path;</span><br><span class="line">  <span class="comment">// 利用path-to-rege模块生产的路径的正则表达式</span></span><br><span class="line">  <span class="keyword">this</span>.regexp = pathToRegExp(path, <span class="keyword">this</span>.paramNames, <span class="keyword">this</span>.opts);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="router-register-注册路由"><a href="#router-register-注册路由" class="headerlink" title="router.register() 注册路由"></a>router.register() 注册路由</h2><p>从上一篇的代码结构图中可以看出，Router 的几个实例方法都直接或间接地调用了 register 方法，可见，它应该是比较核心的函数, 代码不长，我们一行行看一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.register = <span class="function"><span class="keyword">function</span>(<span class="params">path, methods, middleware, opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全部路由</span></span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.stack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 说明路由的path是支持数组的</span></span><br><span class="line">  <span class="comment">// 如果是数组的话，需要递归调用register来注册路由</span></span><br><span class="line">  <span class="comment">// 因为一个path对应一个路由</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(path)) &#123;</span><br><span class="line">    path.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">      router.register.call(router, p, methods, middleware, opts);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建路由，路由就是Layer的实例</span></span><br><span class="line">  <span class="comment">// methods 是路由处理的http方法</span></span><br><span class="line">  <span class="comment">// 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的</span></span><br><span class="line">  <span class="keyword">var</span> route = <span class="keyword">new</span> Layer(path, methods, middleware, &#123;</span><br><span class="line">    end: opts.end === <span class="literal">false</span> ? opts.end : <span class="literal">true</span>,</span><br><span class="line">    name: opts.name,</span><br><span class="line">    sensitive: opts.sensitive || <span class="keyword">this</span>.opts.sensitive || <span class="literal">false</span>,</span><br><span class="line">    strict: opts.strict || <span class="keyword">this</span>.opts.strict || <span class="literal">false</span>,</span><br><span class="line">    prefix: opts.prefix || <span class="keyword">this</span>.opts.prefix || <span class="string">''</span>,</span><br><span class="line">    ignoreCaptures: opts.ignoreCaptures</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理路径前缀</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.opts.prefix) &#123;</span><br><span class="line">    route.setPrefix(<span class="keyword">this</span>.opts.prefix);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将全局的路由参数添加到每个路由中</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.params).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    route.param(param, <span class="keyword">this</span>.params[param]);</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往路由数组中添加新创建的路由</span></span><br><span class="line">  stack.push(route);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="router-verb-注册路由"><a href="#router-verb-注册路由" class="headerlink" title="router.verb() 注册路由"></a>router.verb() 注册路由</h2><blockquote><p>verb =&gt; get|put|post|patch|delete</p></blockquote><p>这是 koa-router 提供的直接注册相应 http 方法的路由，但最终还是会调用 register 方法如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p>和下面利用 register 方法等价：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(<span class="string">'/user'</span>, [<span class="string">'get'</span>], [<span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;...&#125;])</span><br></pre></td></tr></table></figure><p>可以看到直接使用 router.verb 注册路由会方便很多。来看看代码，你会发现 router.js 的代码里并没有 Router.prototype.get 的代码出现，原因是它还依赖了上面提到的 methods 模块来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的methods就是上面的methods模块提供的数组</span></span><br><span class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Router.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">name, path, middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> middleware;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段代码做了两件事：</span></span><br><span class="line">    <span class="comment">// 1.name 参数是可选的，所以要做一些参数置换的处理</span></span><br><span class="line">    <span class="comment">// 2.将所有路由中间件合并成一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span> || path <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">      middleware = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      middleware = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      path = name;</span><br><span class="line">      name = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用register方法</span></span><br><span class="line">    <span class="keyword">this</span>.register(path, [method], middleware, &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="router-routes-启动路由"><a href="#router-routes-启动路由" class="headerlink" title="router.routes() 启动路由"></a>router.routes() 启动路由</h2><p>这是在 koa 中配置路由的重要一步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line">...</span><br><span class="line">app.use(router.routes())</span><br></pre></td></tr></table></figure><p>就这样，koa-router 就启动了，所以我们也一定会很好奇这个 routes 函数到底做了什么,但可以肯定 router.routes()返回了一个中间件函数。<br>函数体长了一点，简化一下看下整体轮廓：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.routes = Router.prototype.middleware = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch.router = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> dispatch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里形成了一个闭包，在 routes 函数内部返回了一个 dispatch 函数作为中间件。<br>接下来看下 dispatch 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> path = router.opts.routerPath || ctx.routerPath || ctx.path;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// router.match函数内部遍历所有路由（this.stach）,</span></span><br><span class="line">  <span class="comment">// 根据路径和请求方法找到对应的路由</span></span><br><span class="line">  <span class="comment">// 返回的matched对象为：</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">      var matched = &#123;</span></span><br><span class="line"><span class="comment">        path: [], // 保存了path匹配的路由数组</span></span><br><span class="line"><span class="comment">        pathAndMethod: [], // 保存了path和methods都匹配的路由数组</span></span><br><span class="line"><span class="comment">        route: false // 是否有对应的路由</span></span><br><span class="line"><span class="comment">      &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">var</span> matched = router.match(path, ctx.method);</span><br><span class="line">  <span class="keyword">var</span> layerChain, layer, i;</span><br><span class="line">  <span class="keyword">if</span> (ctx.matched) &#123;</span><br><span class="line">    ctx.matched.push.apply(ctx.matched, matched.path);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.matched = matched.path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有对应的路由，则直接进入下一个中间件</span></span><br><span class="line">  <span class="keyword">if</span> (!matched.route) <span class="keyword">return</span> next();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到正确的路由的path</span></span><br><span class="line">  <span class="keyword">var</span> mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - <span class="number">1</span>].path;</span><br><span class="line">  ctx._matchedRoute = mostSpecificPath;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用reduce方法将路由的所有中间件形成一条链</span></span><br><span class="line">  layerChain = matched.pathAndMethod.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">memo, layer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params</span></span><br><span class="line">    <span class="comment">// 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了</span></span><br><span class="line">    memo.push(<span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 返回路由的参数的key</span></span><br><span class="line">      ctx.captures = layer.captures(path, ctx.captures);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回参数的key和对应的value组成的对象</span></span><br><span class="line">      ctx.params = layer.params(path, ctx.captures, ctx.params);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行下一个中间件</span></span><br><span class="line">      <span class="keyword">return</span> next();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将上面另外加的中间件和已有的路由中间件合并到一起</span></span><br><span class="line">    <span class="comment">// 所以最终 layerChain 将会是一个中间件的数组</span></span><br><span class="line">    <span class="keyword">return</span> memo.concat(layer.stack);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后调用上面提到的 compose 模块提供的方法，返回将 layerChain (中间件的数组)</span></span><br><span class="line">  <span class="comment">// 顺序执行所有中间件的执行函数， 并立即执行。</span></span><br><span class="line">  <span class="keyword">return</span> compose(layerChain)(ctx, next);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="router-allowMethods-处理请求出错逻辑"><a href="#router-allowMethods-处理请求出错逻辑" class="headerlink" title="router.allowMethods() 处理请求出错逻辑"></a>router.allowMethods() 处理请求出错逻辑</h2><p>同样也是 koa 中配置路由的中一步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line">...</span><br><span class="line">app.use(router.routes())</span><br><span class="line">app.use(router.allowMethods())</span><br></pre></td></tr></table></figure><p>可以看出，该方法也是闭包内返回了中间件函数。我们将代码简化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.allowedMethods = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> implemented = <span class="keyword">this</span>.methods;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">allowedMethods</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> allowed = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ctx.status || ctx.status === <span class="number">404</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!~implemented.indexOf(ctx.method)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (options.throw) &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.status = <span class="number">501</span>;</span><br><span class="line">            ctx.set(<span class="string">'Allow'</span>, allowedArr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedArr.length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ctx.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">            ctx.status = <span class="number">204</span>;</span><br><span class="line">            ctx.set(<span class="string">'Allow'</span>, allowedArr);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowed[ctx.method]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.throw) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              ctx.status = <span class="number">405</span>;</span><br><span class="line">              ctx.set(<span class="string">'Allow'</span>, allowedArr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>眼尖的同学可能会看到一些 http code ： 404, 501, 204, 405<br>那这个函数其实就是当所有中间件函数执行完了，并且请求出错了进行相应的处理：</p><ul><li>如果请求的方法 koa-router 不支持并且没有设置 throw 选项，则返回 501(未实现)</li><li>如果是 options 请求，则返回 204(无内容)</li><li>如果请求的方法支持但没有设置 throw 选项，则返回 405(不允许此方法 )</li></ul>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-Koa中间件的洋葱圈模型</title>
      <link href="/2019/01/29/Node-koa-compose%E6%B4%8B%E8%91%B1%E5%9C%88%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/01/29/Node-koa-compose%E6%B4%8B%E8%91%B1%E5%9C%88%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Koa-洋葱圈模型"><a href="#Koa-洋葱圈模型" class="headerlink" title="Koa 洋葱圈模型"></a>Koa 洋葱圈模型</h2><p>Koa 的中间件选择了洋葱圈模型。中间件结构如下所示：<br><img src="/image/koa_middleware.png" alt=""></p><p>所有的请求经过一个中间件的时候都会执行两次，Koa 的洋葱圈模型可以非常方便的实现后置处理逻辑。</p><h2 id="Koa-洋葱圈实例"><a href="#Koa-洋葱圈实例" class="headerlink" title="Koa 洋葱圈实例"></a>Koa 洋葱圈实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建koa实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1-start'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1-end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2-start'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2-end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3-start'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3-end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">----&gt; 打印结果：</span><br><span class="line">----&gt; <span class="number">1</span>-start</span><br><span class="line">----&gt; <span class="number">2</span>-start</span><br><span class="line">----&gt; <span class="number">3</span>-start</span><br><span class="line">----&gt; <span class="number">3</span>-end</span><br><span class="line">----&gt; <span class="number">2</span>-end</span><br><span class="line">----&gt; <span class="number">1</span>-end</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>本文重点在于讲解 koa 中间件的洋葱圈模型。因此，会省略部分无关代码。</p><h4 id="koa-use-方法"><a href="#koa-use-方法" class="headerlink" title="koa.use 方法"></a>koa.use 方法</h4><p>use 方法，为声明中间件的方法，将中间件存储在 middleware 数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line"></span><br><span class="line">    debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="koa-listen-方法"><a href="#koa-listen-方法" class="headerlink" title="koa.listen 方法"></a>koa.listen 方法</h4><p>listen 方法，为启动 http-server 的简便操作。关键操作还是在 callback 方法上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="koa-callback-方法"><a href="#koa-callback-方法" class="headerlink" title="koa.callback 方法"></a>koa.callback 方法</h4><p>callback 方法，返回参数为(req, res)的方法，每次 http-server 发生回调时，都会调用 callback 方法。因此，callback 方法才是真正的 koa 执行 http-server 的源头。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line"><span class="comment">// 实现洋葱圈的关键代码，从use方法可知，我们将中间件push到了middleware数组中。那么compose方法如何将middleware的数组转换为了洋葱圈模型的方法fn。就是实现洋葱圈模型的关键了。</span></span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="koa-compose-的-compose-方法"><a href="#koa-compose-的-compose-方法" class="headerlink" title="koa-compose 的 compose 方法"></a>koa-compose 的 compose 方法</h4><p>compose 方法，主要作用是将中间件数组，包装成了洋葱圈模型中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 校验middleware格式，必须为数组，子元素必须为方法</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; context</span></span><br><span class="line"><span class="comment">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 正常情况下， index 永远小于 i，除非next()被多次调用。</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>));</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">      <span class="comment">// 如果next参数存在，则next方法在最后调用。</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 递归调用dispatch方法实现从中间件数组到洋葱圈模型中间件的转变。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="koa-handleRequest-方法"><a href="#koa-handleRequest-方法" class="headerlink" title="koa.handleRequest 方法"></a>koa.handleRequest 方法</h4><p>handleRequest 方法，消费洋葱圈模型中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="comment">// 洋葱圈模型中间件，返回的都是Promise，通过下面代码消费中间件</span></span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://eggjs.org/zh-cn/intro/egg-and-koa.html" target="_blank" rel="noopener">https://eggjs.org/zh-cn/intro/egg-and-koa.html</a><br><a href="https://www.jianshu.com/p/5d0f1d9ef746" target="_blank" rel="noopener">https://www.jianshu.com/p/5d0f1d9ef746</a></p>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据库-MySql操作大全</title>
      <link href="/2019/01/24/%E6%95%B0%E6%8D%AE%E5%BA%93-MySql%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/01/24/%E6%95%B0%E6%8D%AE%E5%BA%93-MySql%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>详情</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 字节</td><td>有符号:(-128，127) <br>无符号:(0，255)</td><td>极小整数值</td></tr><tr><td>SMALLINT</td><td>2 字节</td><td>有符号:(-32 768，32 767) <br>无符号:(0，65 535)</td><td>小整数值</td></tr><tr><td>MEDIUMINT</td><td>3 字节</td><td>有符号:(-8 388 608，8 388 607) <br>无符号:(0，16 777 215)</td><td>中等整数值</td></tr><tr><td>INT 或 INTEGER</td><td>4 字节</td><td>有符号:(-2 147 483 648，2 147 483 647) <br>无符号:(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 字节</td><td>有符号:(-9,223,372,036,854,775,808，9 223 372 036 854 775 807) <br>无符号:(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 字节</td><td>有符号:(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) <br>无符号:0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>有符号:(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) <br>无符号:0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td>对 DECIMAL(M,D) ，如果 M&gt;D，为 M+2 否则为 D+2</td><td>依赖于 M 和 D 的值</td><td>小数值</td></tr></tbody></table><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>详情</th></tr></thead><tbody><tr><td>DATE</td><td>3 字节</td><td>1000-01-01 到 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3 字节</td><td>-838:59:59 到 838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1 字节</td><td>1901 到 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8 字节</td><td>1000-01-01 00:00:00 到 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4 字节</td><td>1970-01-01 00:00:00 到 2038 年 1 月 19 日 凌晨 03:14:07（格林尼治时间）</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>详情</th></tr></thead><tbody><tr><td>CHAR</td><td>0 到 255B</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0 到 64K</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0 到 255B</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0 到 255B</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0 到 64K</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0 到 64K</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0 到 16K</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0 到 16K</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0 到 4GB</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0 到 4GB</td><td>极大文本数据</td></tr></tbody></table><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接到数据库</span></span><br><span class="line">mysql -uroot -ppassword -hlocalhost -P3306;</span><br></pre></td></tr></table></figure><h2 id="切换数据库操作"><a href="#切换数据库操作" class="headerlink" title="切换数据库操作"></a>切换数据库操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| daiyibo_test       |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| pakun              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用数据库</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><h2 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示表单</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| Tables_in_daiyibo_test |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| test_1                 |</span><br><span class="line">| test_2                 |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示表单列信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> tablename;</span><br><span class="line"><span class="keyword">describe</span> tablename;</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| name  | varchar(19) | YES  |     | NULL    |       |</span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| value | varchar(10) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找所有信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete with handy hook                  |</span><br><span class="line">| ANV02   |    1001 | 1 ton anvil    |       9.99 | 1 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| ANV03   |    1001 | 2 ton anvil    |      14.99 | 2 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| DTNTR   |    1003 | Detonator      |      13.00 | Detonator (plunger powered), fuses not included                |</span><br><span class="line">| FB      |    1003 | Bird seed      |      10.00 | Large bag (suitable for road runners)                          |</span><br><span class="line">| FC      |    1003 | Carrots        |       2.50 | Carrots (rabbit hunting season only)                           |</span><br><span class="line">| FU1     |    1002 | Fuses          |       3.42 | 1 dozen, extra long                                            |</span><br><span class="line">| JP1000  |    1005 | JetPack 1000   |      35.00 | JetPack 1000, intended for single <span class="keyword">use</span>                          |</span><br><span class="line">| JP2000  |    <span class="number">1005</span> | JetPack <span class="number">2000</span>   |      <span class="number">55.00</span> | JetPack <span class="number">2000</span>, multi-<span class="keyword">use</span>                                        |</span><br><span class="line">| OL1     |    <span class="number">1002</span> | Oil can        |       <span class="number">8.99</span> | Oil can, red                                                   |</span><br><span class="line">| <span class="keyword">SAFE</span>    |    <span class="number">1003</span> | <span class="keyword">Safe</span>           |      <span class="number">50.00</span> | <span class="keyword">Safe</span> <span class="keyword">with</span> combination <span class="keyword">lock</span>                                     |</span><br><span class="line">| SLING   |    <span class="number">1003</span> | Sling          |       <span class="number">4.49</span> | Sling, one <span class="keyword">size</span> fits all                                       |</span><br><span class="line">| TNT1    |    <span class="number">1003</span> | TNT (<span class="number">1</span> stick)  |       <span class="number">2.50</span> | TNT, red, single stick                                         |</span><br><span class="line">| TNT2    |    <span class="number">1003</span> | TNT (<span class="number">5</span> sticks) |      <span class="number">10.00</span> | TNT, red, pack <span class="keyword">of</span> <span class="number">10</span> sticks                                    |</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找指定列信息</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_name <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">| vend_id | prod_name      |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">|    1001 | .5 ton anvil   |</span><br><span class="line">|    1001 | 1 ton anvil    |</span><br><span class="line">|    1001 | 2 ton anvil    |</span><br><span class="line">|    1003 | Detonator      |</span><br><span class="line">|    1003 | Bird seed      |</span><br><span class="line">|    1003 | Carrots        |</span><br><span class="line">|    1002 | Fuses          |</span><br><span class="line">|    1005 | JetPack 1000   |</span><br><span class="line">|    1005 | JetPack 2000   |</span><br><span class="line">|    1002 | Oil can        |</span><br><span class="line">|    1003 | Safe           |</span><br><span class="line">|    1003 | Sling          |</span><br><span class="line">|    1003 | TNT (1 stick)  |</span><br><span class="line">|    1003 | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找去重后的指定列信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> vend_id <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| vend_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+<span class="comment">---------+</span></span><br></pre></td></tr></table></figure><h3 id="SELECT-子句顺序"><a href="#SELECT-子句顺序" class="headerlink" title="SELECT 子句顺序"></a>SELECT 子句顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顺序：1      2              3                 4              5                  6              7</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tablename <span class="keyword">where</span> value1 &gt; <span class="number">0</span> <span class="keyword">group</span> <span class="keyword">by</span> value2 <span class="keyword">having</span> value3 &gt; <span class="number">0</span> <span class="keyword">order</span> <span class="keyword">by</span> value4 <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="控制行数"><a href="#控制行数" class="headerlink" title="控制行数"></a>控制行数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找信息后指定检索行数</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">limit</span> <span class="number">5</span>;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找信息后指定检索的开始行和行数</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">limit</span> <span class="number">1</span>, <span class="number">5</span>;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| prod_name   |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| 1 ton anvil |</span><br><span class="line">| 2 ton anvil |</span><br><span class="line">| Detonator   |</span><br><span class="line">| Bird seed   |</span><br><span class="line">| Carrots     |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找数据后进行排序</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> vend_id, prod_name <span class="keyword">desc</span>, prod_price <span class="keyword">desc</span>;</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br><span class="line">| vend_id | prod_name      | prod_price |</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br><span class="line">|    1001 | 2 ton anvil    |      14.99 |</span><br><span class="line">|    1001 | 1 ton anvil    |       9.99 |</span><br><span class="line">|    1001 | .5 ton anvil   |       5.99 |</span><br><span class="line">|    1002 | Oil can        |       8.99 |</span><br><span class="line">|    1002 | Fuses          |       3.42 |</span><br><span class="line">|    1003 | TNT (5 sticks) |      10.00 |</span><br><span class="line">|    1003 | TNT (1 stick)  |       2.50 |</span><br><span class="line">|    1003 | Sling          |       4.49 |</span><br><span class="line">|    1003 | Safe           |      50.00 |</span><br><span class="line">|    1003 | Detonator      |      13.00 |</span><br><span class="line">|    1003 | Carrots        |       2.50 |</span><br><span class="line">|    1003 | Bird seed      |      10.00 |</span><br><span class="line">|    1005 | JetPack 2000   |      55.00 |</span><br><span class="line">|    1005 | JetPack 1000   |      35.00 |</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br></pre></td></tr></table></figure><h3 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h3><p>将查找后的数据，进行过滤操作。</p><blockquote><p>过滤操作的操作符如下：<br>=，&lt;&gt;，!=， &lt;， &lt;=， &gt;， &gt;=， between and，is null</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 过滤数据，普通操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name = <span class="string">"fuses"</span>;</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| prod_name | prod_price |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| Fuses     |       3.42 |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，between操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">14</span>;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，is null操作符示例</span></span><br><span class="line"><span class="keyword">select</span> cust_email <span class="keyword">from</span> customers <span class="keyword">where</span> cust_email <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| cust_email |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| NULL       |</span><br><span class="line">| NULL       |</span><br><span class="line">+<span class="comment">------------+</span></span><br></pre></td></tr></table></figure><h3 id="多条件过滤操作符"><a href="#多条件过滤操作符" class="headerlink" title="多条件过滤操作符"></a>多条件过滤操作符</h3><p>将多个条件操作符组合起来，进行多条件过滤操作。</p><ul><li>AND：就是条件“且”的意思</li><li>OR：就是条件“或”的意思</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 过滤数据，or 操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1002</span> <span class="keyword">or</span> vend_id=<span class="number">1003</span>;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Fuses          |       3.42 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Carrots        |       2.50 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，and 操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1002</span> <span class="keyword">and</span> prod_price &gt; <span class="number">4</span>;</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| prod_name | prod_price |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| Oil can   |       8.99 |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，or、and 操作符混合使用示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> (vend_id=<span class="number">1002</span> <span class="keyword">or</span> vend_id=<span class="number">1003</span>) <span class="keyword">and</span> prod_price &gt; <span class="number">4</span>;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，in 表示只要允许其中()中的其中一个条件，操作符使用示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price, vend_id <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1002</span>, <span class="number">1003</span>);</span><br><span class="line">+<span class="comment">----------------+------------+---------+</span></span><br><span class="line">| prod_name      | prod_price | vend_id |</span><br><span class="line">+<span class="comment">----------------+------------+---------+</span></span><br><span class="line">| Fuses          |       3.42 |    1002 |</span><br><span class="line">| Oil can        |       8.99 |    1002 |</span><br><span class="line">| Detonator      |      13.00 |    1003 |</span><br><span class="line">| Bird seed      |      10.00 |    1003 |</span><br><span class="line">| Carrots        |       2.50 |    1003 |</span><br><span class="line">| Safe           |      50.00 |    1003 |</span><br><span class="line">| Sling          |       4.49 |    1003 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |    1003 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |    1003 |</span><br><span class="line">+<span class="comment">----------------+------------+---------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，not 表示对前面操作取反，使用示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price, vend_id <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1002</span>, <span class="number">1003</span>);</span><br><span class="line">+<span class="comment">--------------+------------+---------+</span></span><br><span class="line">| prod_name    | prod_price | vend_id |</span><br><span class="line">+<span class="comment">--------------+------------+---------+</span></span><br><span class="line">| .5 ton anvil |       5.99 |    1001 |</span><br><span class="line">| 1 ton anvil  |       9.99 |    1001 |</span><br><span class="line">| 2 ton anvil  |      14.99 |    1001 |</span><br><span class="line">| JetPack 1000 |      35.00 |    1005 |</span><br><span class="line">| JetPack 2000 |      55.00 |    1005 |</span><br><span class="line">+<span class="comment">--------------+------------+---------+</span></span><br></pre></td></tr></table></figure><h3 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h3><p>通配符过滤操作，有点类似于模糊过滤操作。下面主要介绍%和_两个操作符。</p><ul><li>“%” 操作符，表示匹配出现任何次数的任意字符。</li><li>“_” 操作符，表示匹配任何出现的单个字符。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- “%” 操作符使用介绍</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">"%anvil"</span>;</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| prod_id | prod_name    |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| ANV01   | .5 ton anvil |</span><br><span class="line">| ANV02   | 1 ton anvil  |</span><br><span class="line">| ANV03   | 2 ton anvil  |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- “_” 操作符使用介绍</span></span><br><span class="line"><span class="keyword">select</span> cust_contact, cust_id <span class="keyword">from</span> customers <span class="keyword">where</span> cust_contact <span class="keyword">like</span> <span class="string">"___am"</span>;</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br><span class="line">| cust_contact | cust_id |</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br><span class="line">| Y Sam        |   10004 |</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式过滤"><a href="#正则表达式过滤" class="headerlink" title="正则表达式过滤"></a>正则表达式过滤</h3><p>mysql 支持正则表达式。若要使用正则表达式，则用 regexp 作为操作符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> customers <span class="keyword">where</span> cust_address regexp <span class="string">"^2."</span>;</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+</span></span><br><span class="line">| cust_id | cust_name   | cust_address   | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email      |</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+</span></span><br><span class="line">|   10001 | Coyote Inc. | 200 Maple Lane | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com |</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+</span></span><br></pre></td></tr></table></figure><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>可以通过 concat 方法对字段内容进行拼接操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>) <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| concat(vend_name, '(', vend_country, ')') |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| ACME(USA)                                 |</span><br><span class="line">| Anvils R Us(USA)                          |</span><br><span class="line">| Furball Inc.(USA)                         |</span><br><span class="line">| Jet <span class="keyword">Set</span>(England)                          |</span><br><span class="line">| Jouets Et Ours(France)                    |</span><br><span class="line">| LT Supplies(USA)                          |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br></pre></td></tr></table></figure><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>别名是一个字段或值的替代名。通过 as 关键字赋予别名。如果使用了别名，相当于可以对字段进行重新命名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>) <span class="keyword">as</span> vend_title <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| vend_title             |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| ACME(USA)              |</span><br><span class="line">| Anvils R Us(USA)       |</span><br><span class="line">| Furball Inc.(USA)      |</span><br><span class="line">| Jet <span class="keyword">Set</span>(England)       |</span><br><span class="line">| Jouets Et Ours(France) |</span><br><span class="line">| LT Supplies(USA)       |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br></pre></td></tr></table></figure><h3 id="使用算数计算"><a href="#使用算数计算" class="headerlink" title="使用算数计算"></a>使用算数计算</h3><p>可以通过算数运算符对字段进行运算操作。支持的操作符有+，-，*，/。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, quantity, item_price, quantity*item_price <span class="keyword">as</span> expanded_price <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num = <span class="number">20005</span>;</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">| ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">| TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br></pre></td></tr></table></figure><h3 id="文本处理内置函数"><a href="#文本处理内置函数" class="headerlink" title="文本处理内置函数"></a>文本处理内置函数</h3><ul><li>Left()： 返回串左边的字符</li><li>Length()：返回串的长度</li><li>Locate()：找出串的一个子串</li><li>Lower()：将串转换为小写</li><li>LTrim()：去掉串左边的空格</li><li>Right()：返回串右边的字符</li><li>RTrim()：去掉串右边的空格</li><li>Soundex()：返回串的 SOUNDEX 值</li><li>SubString()：返回子串的字符</li><li>Upper()：将串转换为大写</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">upper</span>(prod_name) <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| upper(prod_name) |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| .5 TON ANVIL     |</span><br><span class="line">| 1 TON ANVIL      |</span><br><span class="line">| 2 TON ANVIL      |</span><br><span class="line">| DETONATOR        |</span><br><span class="line">| BIRD SEED        |</span><br><span class="line">| CARROTS          |</span><br><span class="line">| FUSES            |</span><br><span class="line">| JETPACK 1000     |</span><br><span class="line">| JETPACK 2000     |</span><br><span class="line">| OIL CAN          |</span><br><span class="line">| SAFE             |</span><br><span class="line">| SLING            |</span><br><span class="line">| TNT (1 STICK)    |</span><br><span class="line">| TNT (5 STICKS)   |</span><br><span class="line">+<span class="comment">------------------+</span></span><br></pre></td></tr></table></figure><h3 id="时间处理内置函数"><a href="#时间处理内置函数" class="headerlink" title="时间处理内置函数"></a>时间处理内置函数</h3><ul><li>AddDate()：增加一个日期(天、周等)</li><li>AddTime()：增加一个时间(时、分等)</li><li>CurDate()：返回当前日期</li><li>CurTime()：返回当前时间</li><li>Date()：返回日期时间的日期部分</li><li>DateDiff()：计算两个日期之差</li><li>Date_Add()：高度灵活的日期运算函数</li><li>Date_Format()：返回一个格式化的日期或时间串</li><li>Day()：返回一个日期的天数部分</li><li>DayOfWeek()：对于一个日期，返回对应的星期几</li><li>Hour()：返回一个时间的小时部分</li><li>Minute()：返回一个时间的分钟部分</li><li>Month()：返回一个日期的月份部分</li><li>Now()：返回当前日期和时间</li><li>Second()：返回一个时间的秒部分</li><li>Time()：返回一个日期时间的时间部分</li><li>Year()：返回一个日期的年份部分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- month显示操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(order_date) <span class="keyword">as</span> <span class="keyword">month</span> <span class="keyword">from</span> orders;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| month |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     9 |</span><br><span class="line">|     9 |</span><br><span class="line">|     9 |</span><br><span class="line">|    10 |</span><br><span class="line">|    10 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- month比较操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(order_date) <span class="keyword">as</span> <span class="keyword">month</span> <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="keyword">month</span>(order_date)&gt;<span class="number">9</span>;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| month |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|    10 |</span><br><span class="line">|    10 |</span><br><span class="line">+<span class="comment">-------+</span></span><br></pre></td></tr></table></figure><h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><ul><li>Abs()：返回一个数的绝对值</li><li>Cos()：返回一个角度的余弦</li><li>Exp()：返回一个数的指数值</li><li>Mod()：返回除操作的余数</li><li>Pi()：返回圆周率</li><li>Rand()：返回一个随机数</li><li>Sin()：返回一个角度的正弦</li><li>Sqrt()：返回一个数的平方根</li><li>Tan()：返回一个角度的正切</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">abs</span>(<span class="number">-1</span>);</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| abs(-1) |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       1 |</span><br><span class="line">+<span class="comment">---------+</span></span><br></pre></td></tr></table></figure><h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><ul><li>AVG()：返回某列的平均值</li><li>COUNT()：返回某列的行数</li><li>MAX()：返回某列的最大值</li><li>MIN()：返回某列的最小值</li><li>SUM()：返回某列值之和</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 汇总操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(prod_price) <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| avg(prod_price) |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">|       16.133571 |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复杂汇总操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> num_items, <span class="keyword">min</span>(prod_price) <span class="keyword">as</span> price_min, <span class="keyword">max</span>(prod_price) <span class="keyword">as</span> price_max, <span class="keyword">avg</span>(prod_price) <span class="keyword">as</span> price_avg <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">-----------+-----------+-----------+-----------+</span></span><br><span class="line">| num_items | price_min | price_max | price_avg |</span><br><span class="line">+<span class="comment">-----------+-----------+-----------+-----------+</span></span><br><span class="line">|        14 |      2.50 |     55.00 | 16.133571 |</span><br><span class="line">+<span class="comment">-----------+-----------+-----------+-----------+</span></span><br></pre></td></tr></table></figure><h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>MySQL 允许对数据进行分组操作，分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。</p><ul><li>“group by” 操作符，提供了对数据进行分组的能力。</li><li>“having” 操作符，提供了对分组数据进行过滤的能力。用法和“where”操作符无异，只是“where”操作对象为所有数据，“having”操作对象为分组后的数据。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分组查找数据</span></span><br><span class="line"><span class="keyword">select</span> vend_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|    1001 |         3 |</span><br><span class="line">|    1002 |         2 |</span><br><span class="line">|    1003 |         7 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line"><span class="comment">-- 对分组查找的数据进行过滤操作</span></span><br><span class="line"><span class="keyword">select</span> vend_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;=<span class="number">2</span>;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|    1001 |         3 |</span><br><span class="line">|    1002 |         2 |</span><br><span class="line">|    1003 |         7 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br></pre></td></tr></table></figure><h3 id="子句查询"><a href="#子句查询" class="headerlink" title="子句查询"></a>子句查询</h3><p>mysql 支持子查询，就是将嵌套使用 select 操作。在复杂的数据库操作中，是非常有用的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 利用子查询进行过滤</span></span><br><span class="line"><span class="keyword">select</span> cust_name,  cust_contact <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id=<span class="string">'TNT2'</span>));</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 作为计算字段利用子查询</span></span><br><span class="line"><span class="keyword">select</span> cust_name, cust_state, (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> orders <span class="keyword">where</span> orders.cust_id=customers.cust_id) <span class="keyword">as</span> order_count</span><br><span class="line">    <span class="keyword">from</span> customers <span class="keyword">order</span> <span class="keyword">by</span> cust_name;</span><br><span class="line">+<span class="comment">----------------+------------+-------------+</span></span><br><span class="line">| cust_name      | cust_state | order_count |</span><br><span class="line">+<span class="comment">----------------+------------+-------------+</span></span><br><span class="line">| Coyote Inc.    | MI         |           2 |</span><br><span class="line">| E Fudd         | IL         |           1 |</span><br><span class="line">| Mouse House    | OH         |           0 |</span><br><span class="line">| Wascals        | IN         |           1 |</span><br><span class="line">| Yosemite Place | AZ         |           1 |</span><br><span class="line">+<span class="comment">----------------+------------+-------------+</span></span><br></pre></td></tr></table></figure><h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>关系型数据库，会将数据组合成多个关系表的形式。此时，如果想要一次性查找多个表中的数据，就需要用到联结。联结操作有如下几种形式：</p><ul><li>内部联结：此联结操作只展示相关联的行。将两个表之间的数据，通过联结操作将关联的数据过滤出来，并展示出来。</li><li>外部联结：此联结操作除了展示相关联的行以外，还会展示没有关联的那些行。将两个表之间的数据，通过联结操作将不相关的数据排除在外，并展示保留下来的数据。</li><li>多表联结：算是内部联结的一种，但他指的是多个表之间的联结操作。</li><li>自联结：算是内部联结的一种，但他指的是单个表自己对自己的联结操作。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内部联结，下面两个sql语句等价</span></span><br><span class="line"><span class="keyword">select</span> customers.cust_id, orders.* <span class="keyword">from</span> customers <span class="keyword">inner</span> <span class="keyword">join</span> orders <span class="keyword">on</span> customers.cust_id=orders.cust_id;</span><br><span class="line"><span class="keyword">select</span> customers.cust_id, orders.* <span class="keyword">from</span> customers, orders <span class="keyword">where</span> customers.cust_id=orders.cust_id;</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">| cust_id | order_num | order_date          | cust_id |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">|   10001 |     20005 | 2005-09-01 00:00:00 |   10001 |</span><br><span class="line">|   10003 |     20006 | 2005-09-12 00:00:00 |   10003 |</span><br><span class="line">|   10004 |     20007 | 2005-09-30 00:00:00 |   10004 |</span><br><span class="line">|   10005 |     20008 | 2005-10-03 00:00:00 |   10005 |</span><br><span class="line">|   10001 |     20009 | 2005-10-08 00:00:00 |   10001 |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外部级联</span></span><br><span class="line"><span class="keyword">select</span> customers.cust_id, orders.* <span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> orders <span class="keyword">on</span> customers.cust_id=orders.cust_id;</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">| cust_id | order_num | order_date          | cust_id |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">|   10001 |     20005 | 2005-09-01 00:00:00 |   10001 |</span><br><span class="line">|   10001 |     20009 | 2005-10-08 00:00:00 |   10001 |</span><br><span class="line">|   10002 |      NULL | NULL                |    NULL |</span><br><span class="line">|   10003 |     20006 | 2005-09-12 00:00:00 |   10003 |</span><br><span class="line">|   10004 |     20007 | 2005-09-30 00:00:00 |   10004 |</span><br><span class="line">|   10005 |     20008 | 2005-10-03 00:00:00 |   10005 |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多表联结</span></span><br><span class="line"><span class="keyword">select</span> prod_name, vend_name, prod_price, quantity <span class="keyword">from</span> orderitems, products, vendors <span class="keyword">where</span> products.vend_id = vendors.vend_id <span class="keyword">and</span> orderitems.prod_id=products.prod_id <span class="keyword">and</span> order_num=<span class="number">20005</span>;</span><br><span class="line">+<span class="comment">----------------+-------------+------------+----------+</span></span><br><span class="line">| prod_name      | vend_name   | prod_price | quantity |</span><br><span class="line">+<span class="comment">----------------+-------------+------------+----------+</span></span><br><span class="line">| .5 ton anvil   | Anvils R Us |       5.99 |       10 |</span><br><span class="line">| 1 ton anvil    | Anvils R Us |       9.99 |        3 |</span><br><span class="line">| TNT (5 sticks) | ACME        |      10.00 |        5 |</span><br><span class="line">| Bird seed      | ACME        |      10.00 |        1 |</span><br><span class="line">+<span class="comment">----------------+-------------+------------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自联结</span></span><br><span class="line"><span class="keyword">select</span> p2.* <span class="keyword">from</span> products <span class="keyword">as</span> p1, products <span class="keyword">as</span> p2 <span class="keyword">where</span> p1.vend_id=p2.vend_id <span class="keyword">and</span> p1.prod_id=<span class="string">'DTNTR'</span>;</span><br><span class="line">+<span class="comment">---------+---------+-----------+------------+-------------------------------------------------+</span></span><br><span class="line">| prod_id | vend_id | prod_name | prod_price | prod_desc                                       |</span><br><span class="line">+<span class="comment">---------+---------+-----------+------------+-------------------------------------------------+</span></span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">+<span class="comment">---------+---------+-----------+------------+-------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>组合查询通过 union 或 union all 关键字将多个查询条件组合起来。使用组合查询的规则如下：</p><ul><li>每条 select 语句之间，必须通过 union 隔离</li><li>每条 select 语句，必须包含相同的列数</li><li>union all，表示合并多条 select 语句的查询结果，但不对重复数据做额外处理</li><li>union，表示合并多条 select 语句的查询结果，并对重复数据去重</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- union组合操作</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price &lt;= <span class="number">5</span> <span class="keyword">union</span> <span class="keyword">select</span> vend_id,prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1001</span> <span class="keyword">or</span> vend_id=<span class="number">1002</span> <span class="keyword">order</span> <span class="keyword">by</span> vend_id;</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- union all 组合操作</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price &lt;= <span class="number">5</span> <span class="keyword">union</span> all <span class="keyword">select</span> vend_id,prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1001</span> <span class="keyword">or</span> vend_id=<span class="number">1002</span> <span class="keyword">order</span> <span class="keyword">by</span> vend_id;</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>插入数据，分为插入完整的行，插入部分的行，插入多行，插入查询结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入完整行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers <span class="keyword">values</span>(<span class="literal">null</span>, <span class="string">'Pep E. Lapew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90046'</span>, <span class="string">'USA'</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入部分行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) <span class="keyword">values</span>(<span class="string">'Pep E. LaPew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90090'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) <span class="keyword">values</span>(<span class="string">'Pep E. LaPew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90090'</span>), (<span class="string">'Pep E. LaPew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90091'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入查询结果</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers_new(cust_id, cust_name, cust_address) <span class="keyword">select</span> customers.cust_id, customers.cust_name, customers.cust_address <span class="keyword">from</span> customers;</span><br></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>更新数据操作，很简单，直接上代码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新单行数据</span></span><br><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_email=<span class="string">'elmer@fudd.com'</span> <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新多行数据</span></span><br><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_email=<span class="string">'elmer@fudd.com'</span>, cust_name=<span class="string">'The Fudds'</span> <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除数据操作，很简单，直接上代码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>使用 create table 来创建 customers 表单。在创建表单时，可以使用 null，primary key，auto_increment，default 关键字来对字段进行修饰操作。</p><ul><li>null：指定列是否允许 null 值，not null 表示该列不允许存在 null 值。</li><li>primary key：指定表单的主键。</li><li>foreign key：指定外键。</li><li>auto_increment：指定主键是否自增。</li><li>default：指定字段的默认值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers (</span><br><span class="line">    cust_id      <span class="built_in">int</span>      <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    cust_name    <span class="built_in">char</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cust_address <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_city    <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_state   <span class="built_in">char</span>(<span class="number">5</span>)  <span class="literal">null</span>,</span><br><span class="line">    cust_zip     <span class="built_in">char</span>(<span class="number">10</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_country <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_contact <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_email   <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    test_fk      <span class="built_in">int</span>      <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (cust_id)</span><br><span class="line">    foreign <span class="keyword">key</span> (test_fk) <span class="keyword">REFERENCES</span> TestTable(test_fk)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表操作</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> customers;</span><br></pre></td></tr></table></figure><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重命名表操作</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> customers2 <span class="keyword">to</span> customers;</span><br></pre></td></tr></table></figure><h4 id="更新字段"><a href="#更新字段" class="headerlink" title="更新字段"></a>更新字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">add</span> new_id <span class="built_in">INT</span>;</span><br><span class="line"><span class="comment">-- 删除字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">drop</span> new_id;</span><br><span class="line"><span class="comment">-- 修改字段（将类型调整为char(10)）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">modify</span> new_id <span class="built_in">char</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- 修改字段（将字段名new_id改为new_id_2，将类型调整为INT）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">change</span> new_id new_id_2 <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure><h4 id="设置外键"><a href="#设置外键" class="headerlink" title="设置外键"></a>设置外键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders <span class="keyword">add</span> foreign <span class="keyword">key</span>(fk_id) <span class="keyword">references</span> TestTable(primary_id);</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders <span class="keyword">drop</span> foreign <span class="keyword">key</span> fk_id;</span><br></pre></td></tr></table></figure><h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。关键字介绍：</p><ul><li>begin：显式地开启一个事务</li><li>commit：也可以使用 commit work，不过二者是等价的。commit 会提交事务，并使已对数据库进行的所有修改成为永久性的</li><li>rollback：有可以使用 rollback work，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改</li><li>savepoint identifier：savepoint 允许在事务中创建一个保存点，一个事务中可以有多个 savepoint</li><li>rollback to identifier：把事务回滚到标记点</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> runoob_transaction_test( <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">5</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_transaction_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- commit事务示例</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> runoob_transaction_test <span class="keyword">value</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> runoob_transaction_test <span class="keyword">value</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_transaction_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rollback事务示例</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> runoob_transaction_test <span class="keyword">values</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_transaction_test;</span><br></pre></td></tr></table></figure><h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><p><a href="http://www.forta.com/books/0672327120/mysql_scripts.zip" target="_blank" rel="noopener">Mysql 必知必会-实现数据</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-Https的理解</title>
      <link href="/2019/01/20/%E7%BD%91%E7%BB%9C-Https%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/01/20/%E7%BD%91%E7%BB%9C-Https%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Http有啥问题？"><a href="#Http有啥问题？" class="headerlink" title="Http有啥问题？"></a>Http有啥问题？</h2><blockquote><ul><li>窃听风险（eavesdropping）：第三方可以获知通信内容</li><li>篡改风险（tampering）：第三方可以修改通信内容</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信</li></ul></blockquote><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><blockquote><ul><li>所有信息都是加密传播，第三方无法窃听</li><li>具有校验机制，一旦被篡改，通信双方会立刻发现</li><li>配备身份证书，防止身份被冒充</li></ul></blockquote><h2 id="Https是个啥？"><a href="#Https是个啥？" class="headerlink" title="Https是个啥？"></a>Https是个啥？</h2><p>为了更好地理解 HTTPS，我们来观察一下 HTTPS 的通信步骤。</p><p><img src="/image/network_https.png" alt="ssl握手图"></p><h4 id="客户端发出请求（ClientHello）"><a href="#客户端发出请求（ClientHello）" class="headerlink" title="客户端发出请求（ClientHello）"></a>客户端发出请求（ClientHello）</h4><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。<br>在这一步，客户端主要向服务器提供以下信息。</p><blockquote><p>（1） 支持的协议版本，比如TLS 1.0版。<br>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。<br>（3） 支持的加密方法，比如RSA公钥加密。<br>（4） 支持的压缩方法。</p></blockquote><h4 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h4><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p><blockquote><p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。<br>（3） 确认使用的加密方法，比如RSA公钥加密。<br>（4） 服务器证书。</p></blockquote><h4 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h4><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><blockquote><p>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>至于为什么一定要用3个随机数，来生成”会话密钥”，dog250解释得很好(<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">参考出处</a>)：</p><blockquote><p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，3个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote><h4 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h4><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><blockquote><p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><h2 id="Https内容防篡改"><a href="#Https内容防篡改" class="headerlink" title="Https内容防篡改"></a>Https内容防篡改</h2><p>HTTPS可以防止中间人的篡改。加密算法的安全性主要分为两种，一种是保护信息不被泄露的能力（CPA安全），一种是保护信息不被篡改的能力（CCA安全）。<br>单纯的加密算法是不具备防止篡改的能力的。比如AES-CBC加密的某一个消息“早上10点20分发起进攻”，我不需要知道这条消息的具体内容是什么，却可以通过某种手段随意把它改成我指定的时间，比如“早上11点10分发起进攻”。只有结合消息验证机制的加密算法才能防止篡改。比如AES-CBC with HMAC-SHA256、AES-GCM、ChaCha20-Poly1305等等。(<a href="https://www.zhihu.com/question/65464646" target="_blank" rel="noopener">参考出处</a>)</p><h2 id="Https的延迟"><a href="#Https的延迟" class="headerlink" title="Https的延迟"></a>Https的延迟</h2><p>通过下面实验，可以看到ssl握手时间是tcp握手的3倍。(<a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="noopener">参考出处</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -w "TCP handshake: %&#123;time_connect&#125;, SSL handshake: %&#123;time_appconnect&#125;\n" -so /dev/null https://www.alipay.com</span><br><span class="line"></span><br><span class="line">TCP handshake: 0.022, SSL handshake: 0.064</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html</a><br><a href="https://blog.csdn.net/AloneSword/article/details/47059945" target="_blank" rel="noopener">https://blog.csdn.net/AloneSword/article/details/47059945</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中类型转换的整理</title>
      <link href="/2019/01/18/Node-JS%E4%B8%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%95%B4%E7%90%86/"/>
      <url>/2019/01/18/Node-JS%E4%B8%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>JS中取值类型非常灵活，在进行算数运算符或比较运算符操作时，常常会进行类型转换操作。最近对类型转换做了系统的梳理。原始值之间的转换规则如下：<br><img src="/image/js_type.png" alt="原始值类型转换"></p><h3 id="对象转换操作"><a href="#对象转换操作" class="headerlink" title="对象转换操作"></a>对象转换操作</h3><p>对象转换，相比于原始值相互转换要稍微复杂点。在讲解对象转换前，先说两个对象内置的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认情况下，toString() -&gt; "[object Object]"</span></span><br><span class="line"><span class="comment"> * 许多类都继承了toString()方法，例如数组：</span></span><br><span class="line"><span class="comment"> * [1].toString() -&gt; "1"</span></span><br><span class="line"><span class="comment"> * ['1'].toString() -&gt; "1"</span></span><br><span class="line"><span class="comment"> * [1, 2].toString() -&gt; "1, 2"</span></span><br><span class="line"><span class="comment"> * @return 返回一个反映这个对象的字符串</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">toString() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认情况下， valueOf() -&gt; 对象本身。因为对象是复合值，而且大多数对象无法真正的表示一个原始值</span></span><br><span class="line"><span class="comment"> * 许多类都继承了valueOf()方法，例如日期类：</span></span><br><span class="line"><span class="comment"> * (new Date()).valueOf() -&gt; 1548296513124</span></span><br><span class="line"><span class="comment"> * @return 如果存在任意原始值，它就默认将对象转换为表示它的原始值。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">valueOf() &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="对象到字符串的转换流程"><a href="#对象到字符串的转换流程" class="headerlink" title="对象到字符串的转换流程"></a>对象到字符串的转换流程</h4><ul><li>如果对象具有toString()方法，则调用这个方法。如果他返回一个原始值，JS将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。</li><li>如果对象没有toString()方法，或者这个方法并不返回这个原始值，那么JS会调用valueOf()方法。如果存在这个方法，则JS调用他。如果返回值是原始值，JS将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。</li><li>否则，JS无法从toString()或者valueOf()获取一个原始值，因此这时他将抛出一个类型错误异常。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象转字符串伪代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj2String</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">    temp = obj.toString();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">    temp = obj.valueOf();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'转化失败'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象到数值的转换流程"><a href="#对象到数值的转换流程" class="headerlink" title="对象到数值的转换流程"></a>对象到数值的转换流程</h4><ul><li>如果对象具有valueOf()方法，或者返回一个原始值，则JS将这个原始值转换为数字，并返回这个数字。</li><li>否则，如果对象具有toString()方法，后者返回一个原始值，则JS将其转换并返回</li><li>否则，JS抛出一个类型错误异常</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象转数值伪代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj2Number</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">    temp = obj.valueOf();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">    temp = obj.toString();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'转化失败'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象到原始值的转换流程"><a href="#对象到原始值的转换流程" class="headerlink" title="对象到原始值的转换流程"></a>对象到原始值的转换流程</h4><p>在使用“+”，“==”，“!=”和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符。因为这些运算符不太清楚要将对象转成String还是Number。将对象转成原始值时，会首先尝试调用valueOf()，然后调用toString()。唯一例外的是Date类型，Date类型会首先尝试调用toString()，然后调用valueOf()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象转原始值伪代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj2OriginalValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj == <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.valueOf();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.valueOf();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="“-”-操作符功能简介"><a href="#“-”-操作符功能简介" class="headerlink" title="“+” 操作符功能简介"></a>“+” 操作符功能简介</h3><p>操作符的运算优先级为：string &gt; 其他类型</p><ul><li>存在string类型时，其他类型都会转换成string类型，然后进行字符串连接</li><li>不存在string类型时，会尝试将其他类型转换成数字，然后进行数字相加操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在string类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">undefined</span>);  <span class="comment">//str+undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">null</span>);  <span class="comment">//str+null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">false</span>);  <span class="comment">//str+false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">true</span>);  <span class="comment">//str+true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="number">123</span>);  <span class="comment">//str+123</span></span><br><span class="line"><span class="comment">// 不存在string类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="number">123</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="literal">null</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="literal">false</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="literal">true</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> + <span class="literal">null</span>);  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> + <span class="literal">false</span>);  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> + <span class="literal">true</span>);  <span class="comment">//124</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> + <span class="literal">true</span>);  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> + <span class="literal">false</span>);  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">false</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="“-”-操作符功能简介-1"><a href="#“-”-操作符功能简介-1" class="headerlink" title="“-” 操作符功能简介"></a>“-” 操作符功能简介</h3><p>基本类型进行“—”操作符运算时，将基本类型转换为数字，然后进行数字相减操作。“*”操作符和“/”操作符类似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">null</span>);  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">undefined</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">false</span>); <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">true</span>);  <span class="comment">//122</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="string">'1'</span>);  <span class="comment">//122</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-RESTful接口设计</title>
      <link href="/2019/01/07/%E7%BD%91%E7%BB%9C-RESTful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/01/07/%E7%BD%91%E7%BB%9C-RESTful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Http-Methods描述"><a href="#Http-Methods描述" class="headerlink" title="Http Methods描述"></a>Http Methods描述</h2><table><thead><tr><th>HTTP Methods</th><th>操作方式</th></tr></thead><tbody><tr><td>POST</td><td>创建数据 Create</td></tr><tr><td>GET</td><td>读取数据 Read</td></tr><tr><td>PUT</td><td>修改数据 Update 整条修改修改除ID外的所有属性</td></tr><tr><td>PATCH</td><td>修改数据 Update 部分修改 修改一条记录的部分属性</td></tr><tr><td>DELETE</td><td>删除数据 Delete</td></tr></tbody></table><h2 id="RESTful是什么？"><a href="#RESTful是什么？" class="headerlink" title="RESTful是什么？"></a>RESTful是什么？</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法-红黑树的思考</title>
      <link href="/2019/01/03/%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/01/03/%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>红黑树，一种自平衡的 二叉查找树，但在每个节点上有一个额外的存储位表示节点的颜色，可以是Red或者Black。这些颜色位用来确保红黑树在插入和删除操作后仍能近乎平衡。</p><h2 id="红黑树的应用场景"><a href="#红黑树的应用场景" class="headerlink" title="红黑树的应用场景"></a>红黑树的应用场景</h2><p>到此，我们可能已经对红黑树有了一点初步的认识了，但是我们却不知道为什么要有红黑树，红黑树是为了解决什么问题被提出来的呢？<br>我们知道，二叉查找树在大多数情况下查找和插入在效率上是没有问题的，但是在最坏的情况下效率比较低，但是平衡二叉树能够保证在最坏的情况下也能达到lgN，要实现这一目标，我们就要保证在插入完成后始终保持平衡状态。在一棵具有N个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以就出现一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。而我们所讲的红黑树就属于此新的数据结构之一，除此之外还有B树等数据结构。</p><h2 id="红黑树与其他结构对比"><a href="#红黑树与其他结构对比" class="headerlink" title="红黑树与其他结构对比"></a>红黑树与其他结构对比</h2><p><strong>红黑树 vs 普通二叉树</strong><br>红黑树再插入或者删除节点后，会对操作后的树进行重新平衡操作。使得最坏情况下，对节点的查询效率还是高。而普通二叉树，有可能会引起树倾斜的问题，这时在查找树中节点，效率可能变成了O(1)。<br><strong>红黑树 vs AVL平衡二叉树</strong><br>AVL树需要严格维护二叉树平衡。而红黑树通过节点颜色来维护一个相对平衡的二叉树。</p><ul><li>在搜索上，AVL效率为log(O)，而红黑树平均效率为log(O)，最大情况下是2log(O)。</li><li>在插入上，红黑树和AVL树，节点旋转次数都是O(1)。</li><li>在删除上，红黑树在删除时节点旋转次数是O(1)，AVL树在删除时节点旋转次数是O(logn)。</li></ul><p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。<br>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p><h2 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h2><p>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><h2 id="关于时间复杂度的证明"><a href="#关于时间复杂度的证明" class="headerlink" title="关于时间复杂度的证明"></a>关于时间复杂度的证明</h2><blockquote><p>红黑树的时间复杂度为: O(lgn)<br>下面通过“数学归纳法”对红黑树的时间复杂度进行证明。<br>定理：一棵含有n个节点的红黑树的高度至多为2log(n+1).<br>证明：<br>“一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的逆否命题是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。<br>我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。<br>从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x’s black height)，记为bh(x)。关于bh(x)有两点需要说明：<br>第1点：根据红黑树的”特性(5) ，即从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点”可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。这也就意味着，bh(x)的值是唯一的！<br>第2点：根据红黑色的”特性(4)，即如果一个节点是红色的，则它的子节点必须是黑色的”可知，从节点x出发达到叶节点”所经历的黑节点数目”&gt;= “所经历的红节点的数目”。假设x是根节点，则可以得出结论”bh(x) &gt;= h/2”。进而，我们只需证明 “高度为h的红黑树，它的包含的黑节点个数至少为 2bh(x)-1个”即可。<br>到这里，我们将需要证明的定理已经由<br>“一棵含有n个节点的红黑树的高度至多为2log(n+1)”<br>转变成只需要证明<br>“高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。<br>下面通过”数学归纳法”开始论证高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。<br>(01) 当树的高度h=0时，<br>内节点个数是0，bh(x) 为0，2bh(x)-1 也为 0。显然，原命题成立。<br>(02) 当h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2bh(x)-1-1。这个是根据(01)推断出来的！<br>下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2bh(x)-1”。<br>当树的高度为 h 时，<br>对于节点x(x为根节点)，其黑高度为bh(x)。<br>对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br>根据(02)的已知条件，我们已知 “x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2bh(x)-1-1 个”；<br>所以，节点x所包含的节点至少为 ( 2bh(x)-1-1 ) + ( 2bh(x)-1-1 ) + 1 = 2^bh(x)-1。即节点x所包含的节点至少为 2bh(x)-1。<br>因此，原命题成立。<br>由(01)、(02)得出，”高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)-1个”。<br>因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。</p></blockquote><h2 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h2><p>时间复杂度： O(1)<br>左旋和右旋是相互对称的<br>图示：<br><img src="/image/base_rbtree_1.png" alt=""></p><h2 id="红黑树插入节点后矫正情况"><a href="#红黑树插入节点后矫正情况" class="headerlink" title="红黑树插入节点后矫正情况"></a>红黑树插入节点后矫正情况</h2><p>矫正的时间复杂度为O(1)。在单次矫正情况中，旋转从不超过2次，因为只要执行了情况2和情况3，while循环就结束了。插件节点，插入的是红色节点。并且是插入到树的叶节点上的。因此只会破坏（“如果一个节点是红色的，则它的子节点必须是黑色的”）特性。处理逻辑如下：</p><h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><p>当前节点的父节点是红色，且叔叔节点也是红色</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>通过调整颜色，在不改变红黑树5个特性的情况下，将红色节点上移。</p><h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将“父节点”设为黑色</li><li>将“叔叔节点”设为黑色</li><li>将“祖父节点”设为“红色”</li><li>将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作<br><img src="/image/base_rbtree_2.png" alt=""></li></ul><h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><p>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是父节点的右孩子</p><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>通过旋转，在不改变当前树原有特点的情况下（红节点的子节点还是红色），将情况2转变成情况3</p><h4 id="处理策略-1"><a href="#处理策略-1" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将“父节点”作为“新的当前节点”</li><li>以“新的当前节点”为支点进行左旋<br><img src="/image/base_rbtree_3.png" alt=""></li></ul><h3 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h3><p>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p><h4 id="处理策略-2"><a href="#处理策略-2" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将“父节点”设为“黑色”。</li><li>将“祖父节点”设为“红色”。</li><li>以“祖父节点”为支点进行右旋。<br><img src="/image/base_rbtree_4.png" alt=""></li></ul><h2 id="红黑树删除节点后矫正情况"><a href="#红黑树删除节点后矫正情况" class="headerlink" title="红黑树删除节点后矫正情况"></a>红黑树删除节点后矫正情况</h2><p>矫正的时间复杂度为O(1)。单次矫正，旋转从不超过3次。到情况2或者情况4就终止了。移除节点，如果移除的是红色节点，则直接删除即可。如果移除的是黑色节点，会破坏（“如果一个节点是红色的，则它的子节点必须是黑色的”和“每个节点或者是黑色，或者是红色”）特性。处理逻辑如下：</p><h3 id="情况1-1"><a href="#情况1-1" class="headerlink" title="情况1"></a>情况1</h3><p>x是”黑+黑”节点，x的兄弟节点是红色。</p><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>将当前模式转化为后续三种模式</p><h4 id="处理策略-3"><a href="#处理策略-3" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x的兄弟节点设为“黑色”。</li><li>将x的父节点设为“红色”。</li><li>对x的父节点进行左旋。</li><li>左旋后，重新设置x的兄弟节点。<br><img src="/image/base_rbtree_5.png" alt=""></li></ul><h3 id="情况2-1"><a href="#情况2-1" class="headerlink" title="情况2"></a>情况2</h3><p>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p><h4 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h4><p>将“黑+黑”节点，中的其中一个黑色属性消除，并上移。</p><h4 id="处理策略-4"><a href="#处理策略-4" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x的兄弟节点设为“红色”。</li><li>设置“x的父节点”为“新的x节点”，原来为红色，现在就是“黑+红”节点，将红色移除后，“新的x节点”为黑色，平衡结束。如果原来是黑色，现在就是“黑+黑”节点，根据情况执行处理策略。<br><img src="/image/base_rbtree_6.png" alt=""></li></ul><h3 id="情况3-1"><a href="#情况3-1" class="headerlink" title="情况3"></a>情况3</h3><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p><h4 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h4><p>将当前状态转化为情况4</p><h4 id="处理策略-5"><a href="#处理策略-5" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x兄弟节点的左孩子设为“黑色”。</li><li>将x兄弟节点设为“红色”。</li><li>对x的兄弟节点进行右旋。</li><li>右旋后，重新设置x的兄弟节点。<br><img src="/image/base_rbtree_7.png" alt=""></li></ul><h3 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h3><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p><h4 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h4><p>为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：</p><ul><li>第一，“同时经过根节点和S的分支的黑色节点个数不变”。<ul><li>若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。</li></ul></li><li>第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<ul><li>若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。</li></ul></li><li>第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<ul><li>在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。</li></ul></li></ul><p>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p><h4 id="处理策略-6"><a href="#处理策略-6" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x父节点颜色 赋值给 x的兄弟节点。</li><li>将x父节点设为“黑色”。</li><li>将x兄弟节点的右子节设为“黑色”。</li><li>对x的父节点进行左旋。</li><li>设置“x”为“根节点”。<br><img src="/image/base_rbtree_8.png" alt=""></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/redblack_tree.html" target="_blank" rel="noopener">https://tech.meituan.com/redblack_tree.html</a><br><a href="https://zhuanlan.zhihu.com/p/34840762" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34840762</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中的EventEmitter订阅发布</title>
      <link href="/2019/01/01/Node-JS%E4%B8%AD%E7%9A%84EventEmitter%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83/"/>
      <url>/2019/01/01/Node-JS%E4%B8%AD%E7%9A%84EventEmitter%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Node 中的许多核心 API 都是通过事件驱动的异步架构实现的，具体来说就是当 emitters 发送事件后，相应的响应函数（ listeners ）会被执行。例如：net.Server 会在每次收到连接时发出事件，fs.ReadStram 会在文件打开时发出事件，stram会在有数据可读时发出事件。 所有这些对象都是 EventEmitter 的实例，它们通过向外暴露的 eventEmitter.on() 接口从而让不同的事件响应函数得以执行。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h4 id="on-和-emit-方法"><a href="#on-和-emit-方法" class="headerlink" title="on 和 emit 方法"></a>on 和 emit 方法</h4><p>events 模块有且只有一个对象 events.EventEmitter，它的核心功能就是事件的触发（emit）和事件的监听（on），一个简单的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hi, my name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br></pre></td></tr></table></figure><p>在上述的例子中，我们通过 emitter.on(‘hi’, func) 的方式注册了 hi 事件的监听函数，通过 emitter.emit(‘hi’, ‘elvin’) 的方式触发了 hi 事件，且会向事件处理函数传递参数 ‘elvin’，所以最后的执行结果为 hi, my name is elvin!。 这里需要说明的时，EventEmitter 还有一个 addeListener 的方法，它只不过是 on 方法的别名，两者没有任何区别。</p><h4 id="once-方法"><a href="#once-方法" class="headerlink" title="once 方法"></a>once 方法</h4><p>有些时候，我们希望某些事件响应函数只被执行一次，这个时候就可以使用 once() 方法，它会和 on() 一样注册事件的响应函数，不过当响应函数执行一次之后，就会将其移除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">emitter.once(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hi, my name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'leonard'</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中只会输出 hi, my name is elvin!（leonard 很高冷，不屑于向你打招呼┗( ▔, ▔ )┛）。</p><h4 id="prependListener-方法"><a href="#prependListener-方法" class="headerlink" title="prependListener 方法"></a>prependListener 方法</h4><p>当一个事件绑定了多个响应函数时，会按照函数绑定的顺序依次执行，除非响应函数是通过 prependListener() 方法绑定的，它使用的方式和 on() 类似，不过会将响应函数插到当前该事件处理函数队列的头部，具体的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I\'m from Wuhan.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.prependListener(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nice to meet you!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'What\'s your name?'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// nice to meet you!</span></span><br><span class="line"><span class="comment">// my name is elvin.</span></span><br><span class="line"><span class="comment">// I'm from Wuhan.</span></span><br><span class="line"><span class="comment">// What\'s your name?</span></span><br></pre></td></tr></table></figure><h4 id="响应函数的数量"><a href="#响应函数的数量" class="headerlink" title="响应函数的数量"></a>响应函数的数量</h4><p>因为绑定过多的响应函数会消耗大量的内存，所以为了避免内存泄漏，在 Event.EventEmitter中一个事件可以绑定的响应函数数量是存在限制的，相关的属性和方法如下：</p><ul><li><strong>EventEmitter.defaultMaxListeners</strong>： 默认值为10， 表示每个事件的最多可以绑定的响应函数数量。需要注意的是，当修改它时，会影响所有 EventEmitter 的实例。</li><li><strong>emitter.listenerCount(eventName)</strong>：获取事件 eventName 已绑定的响应函数个数。</li><li><strong>emitter.setMaxListeners(n)</strong>：修改 emitter 的每个事件最多可以绑定的响应函数数量，该方法会修改 emitter._maxListeners 的值，其优先级大于 EventEmitter.defaultMaxListeners 。</li><li><strong>emitter.getMaxListeners()</strong>：获取 emitter 每个事件最多可以绑定的响应函数数量。</li></ul><h4 id="其他相关方法"><a href="#其他相关方法" class="headerlink" title="其他相关方法"></a>其他相关方法</h4><p>EventEmitter 还有一些其他的方法和属性，这里就不做具体介绍，简要地说一下。</p><ul><li><strong>emitter.eventNames()</strong>：返回当前已经绑定响应函数的事件名组成的数组。</li><li><strong>emitter.listeners(eventName)</strong>：返回 eventName 事件的响应函数组成的数组。</li><li><strong>emitter.prependOnceListener(eventName, listener)</strong>：类似于 once()，不过会将响应函数插到当前该事件处理函数队列的头部。</li><li><strong>emitter.removeAllListeners([eventName])</strong>：移除 eventName 事件所有的响应函数。当未传入 eventName 参数时，所有事件的响应函数都会被移除。</li><li><strong>emitter.removeListener(eventName, listener)</strong>：移除 eventName 事件的响应函数 listener。</li></ul><h4 id="newListener-和-removeListener-事件"><a href="#newListener-和-removeListener-事件" class="headerlink" title="newListener 和 removeListener 事件"></a>newListener 和 removeListener 事件</h4><p>当 emitter 被注册响应函数时，会触发 newListener 事件；被移除响应函数时，会触发 removeListener 事件。两个事件的响应函数会被传入两个参数：注册的事件名和响应的响应函数。具体的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：此处使用 emitter.on 方法的话会陷入循环调用，导致栈溢出</span></span><br><span class="line">emitter.once(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (event === <span class="string">'hi'</span>) &#123;</span><br><span class="line">        emitter.on(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Nice to meet you.'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br></pre></td></tr></table></figure><p>运行结果为 Nice to meet you. My name is elvin.。实际上， newListener 事件被触发时，响应函数还未被注册至 emitter，因而我们就可以在在目标响应函数之前插入其他响应函数，例如上面的例子中 Nice to meet you. 就在 My name is elvin. 之前进行输出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://imweb.io/topic/5973722452e1c21811630609" target="_blank" rel="noopener">https://imweb.io/topic/5973722452e1c21811630609</a></p>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中的事件循环机制</title>
      <link href="/2018/12/31/Node-JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/12/31/Node-JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Node.js的单线程含义，实际上说的是执行同步代码的主线程。一个Node程序的启动，不止是分配了一个线程，而是我们只能在一个线程执行代码。当出现I/O资源调用，TCP连接等外部资源申请的时候，不会阻塞主线程，而是委托给I/O线程进行处理，并且进入等待队列。一旦主线程执行完成，将会消费事件队列(Event Queue)。因为只有一个主线程，只占用CPU内核处理逻辑计算，因此不适合在CPU密集型进行使用。EventLoop 是一种常用的机制，通过对内部或外部的事件提供者发出请求，如文件读写，网络连接 等异步操作，完成后调用事件处理程序。整个过程都是异步阶段。</p><h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br><span class="line">   </span><br><span class="line">注：模型中的每一个方块代表事件循环的一个阶段</span><br></pre></td></tr></table></figure><ul><li>timers 阶段: 这个阶段执行通过setTimeout(callback)和setInterval(callback)设置的callback;</li><li>i/o 阶段: 执行除了close事件，和setTimeout，setInterval，setImmediate方法设定的callbacks之外的callbacks;</li><li>idle, prepare 阶段: 仅node内部使用;</li><li>poll 阶段: 轮询，不断检查有没有新的I/O事件，事件环可能会在这里阻塞;</li><li>check 阶段: 执行setImmediate(callback)设置的callbacks;</li><li>close 阶段: 执行close事件的callback，例如socket.on(‘close’, callback)的callbacks;</li></ul><h2 id="各阶段详细介绍"><a href="#各阶段详细介绍" class="headerlink" title="各阶段详细介绍"></a>各阶段详细介绍</h2><p>下面，我们来针对Node事件循环的每个阶段进行详细说明。</p><h4 id="timers-阶段"><a href="#timers-阶段" class="headerlink" title="timers 阶段"></a>timers 阶段</h4><p>这个阶段主要用来处理定时器相关的回调，当一个定时器超时后，一个事件就会加入到队列中，事件循环跳转至这个阶段执行对应的回调函数。定时器的回调会在触发后尽可能早地被调用，这表示实际的延时可能会比定时器规定的时间要长。如果事件循环，此时正在执行一个比较耗时的callback，例如处理一个比较耗时的循环，那么定时器的回调只能等到当前回调执行结束了才能被执行，即被阻塞。事实上，timers阶段的执行受到poll阶段的控制，后面会讲到。</p><h4 id="IO-callbacks-阶段"><a href="#IO-callbacks-阶段" class="headerlink" title="IO callbacks 阶段"></a>IO callbacks 阶段</h4><p>Nodejs官网文档对这个阶段的解释为：除了timers、setImmediate，以及close操作之外的大多数的回调方法都位于这个阶段执行。但是，一些常见的回调，例如fs.readFile的回调是放在poll阶段来执行的。根据libuv的文档，一些应该在上轮事件循环poll阶段执行的callback，因为某些原因不能执行，就会被延迟到这一轮的事件循环的I/O callbacks阶段执行。换句话说这个阶段执行的callbacks是上轮残留的。</p><h4 id="poll-阶段"><a href="#poll-阶段" class="headerlink" title="poll 阶段"></a>poll 阶段</h4><p>poll阶段的主要任务是等待新的事件的出现（该阶段使用epoll来获取新的事件），如果没有，事件循环可能会在此阻塞。这些事件对应的回调方法可能位于timers阶段（如果定义了定时器），也可能是check阶段（如果设置了setImmediate方法）。poll阶段主要有两个步骤如下：</p><p>（1）如果有到期的定时器，那么就执行定时器的回调方法。<br>（2）处理poll阶段对应的事件队列（以下简称poll队列）里的事件。<br>当事件循环到达poll阶段时，如果这时没有要处理的定时器的回调方法，则会进行下面的判断：<br>（1）如果poll队列不为空，则事件循环会按照顺序遍历执行队列中的回调函数，这个过程是同步的。<br>（2）如果poll队列为空，会接着进行如下的判断：①如果当前代码定义了setImmediate方法，事件循环会离开poll阶段，然后进入check阶段去执行setImmediate方法定义的回调方法。②如果当前代码并没有定义setImmediate方法，那么事件循环可能会进入等待状态，并等待新的事件出现，这也是该阶段为什么会被命名为poll（轮询）的原因。此外，还会不断检查是否有相关的定时器超时，如果有，就会跳转到timers阶段，然后执行对应的回调。</p><h4 id="check-阶段"><a href="#check-阶段" class="headerlink" title="check 阶段"></a>check 阶段</h4><p>setImmediate是一个特殊的定时器方法，它占据了事件循环的一个阶段，整个check阶段就是为setImmediate方法而设置的。一般情况下，当事件循环到达poll阶段后，就会检查当前代码是否调用了setImmediate，但如果一个回调函数是被setImmediate方法调用的，事件循环就会跳出poll阶段而进入check阶段。</p><h4 id="close-阶段"><a href="#close-阶段" class="headerlink" title="close 阶段"></a>close 阶段</h4><p>如果一个socket或者一个句柄被关闭，那么就会产生一个close事件，该事件会被加入到对应的队列中。close阶段执行完毕后，本轮事件循环结束，循环进入到下一轮。</p>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java-反向代理的思考</title>
      <link href="/2018/12/18/Java-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/12/18/Java-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="动态代理使用介绍"><a href="#动态代理使用介绍" class="headerlink" title="动态代理使用介绍"></a>动态代理使用介绍</h2><p>动态代理，利用Java的反射技术，在运行时创建一个实现某些给定接口的新类及其实例。代理的是接口，不是类，更不是抽象类。演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现动态代理</span></span><br><span class="line">        IHello iHello = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;IHello.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"before"</span>);</span><br><span class="line">                Object rs = method.invoke(<span class="keyword">new</span> Hello(), args);</span><br><span class="line">                System.out.println(<span class="string">"after"</span>);</span><br><span class="line">                <span class="keyword">return</span> rs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        iHello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print:</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态创建一个代理对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader 定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces 表示的是我将要给我需要代理的对象提供一组什么接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 代理对象的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用代理方法</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface InvocationHandler </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 指代我们所代理的那个真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 指代的是我们所要调用真实对象的方法的Method对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 指代的是调用真实对象某个方法时接受的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的Object是指真实对象方法的返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP的场景思考"><a href="#AOP的场景思考" class="headerlink" title="AOP的场景思考"></a>AOP的场景思考</h2><p>java中的注解用于描述代码辅助信息。注解的好处是在不影响代码逻辑，插入代码描述信息。<br>如何让代码更好的解耦，应该是很重要的问题。尤其是现在组件化开发模式盛行，如何让组件之间减少依赖关系，变得越来越重要了。下面讲解下，我所认为的组件间通讯的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑中使用登录功能</span></span><br><span class="line">Login l = AOPHelper.get(<span class="string">"login"</span>);</span><br><span class="line">l.login();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录模块接口描述</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Interface</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录模块实现类，注意这个实现可能是在登录组件中的，所以最好不要将业务逻辑和LoginImpl实现直接耦合在一起</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Impl</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.e(<span class="string">"test"</span>, <span class="string">"登录成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过AOPHelper类，将实现和接口之间通过注解的方式连接起来。</span></span><br><span class="line"><span class="comment">// 通过这种方式，既做到了组件和业务的解耦，也做到了具体实现的调用连接。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AOPHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集注解信息，然后将接口和实现关联起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/techyc/p/3455950.html" target="_blank" rel="noopener">https://www.cnblogs.com/techyc/p/3455950.html</a><br><a href="https://zhuanlan.zhihu.com/p/29188162" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29188162</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中模块管理介绍</title>
      <link href="/2018/12/16/Node-JS%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/12/16/Node-JS%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="exports、module-exports、require的使用介绍"><a href="#exports、module-exports、require的使用介绍" class="headerlink" title="exports、module.exports、require的使用介绍"></a>exports、module.exports、require的使用介绍</h2><p>exports和module.exports都是用来指定js文件需要导出的属性值。本质上，exports只是module.exports的引用，辅助后者添加内容用的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下方等价，因为exports相当于module.exports的引用</span></span><br><span class="line">exports.func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line"><span class="built_in">module</span>.exports.func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方代码不等价，因为对exports进行直接复制，相当于将exports的内存指向改变了。所以不再是module.exports的引用</span></span><br><span class="line">exports = &#123;</span><br><span class="line">func1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">func1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>require方法按照下面顺序，查找模块并导出模块对象。</p><blockquote><p><strong>缓存模块：</strong>如果X存在于内存缓存中，则直接从内存缓存中读取文件<br><strong>核心模块：</strong>如果 X 是内置模块（比如 require(‘http’）)<br>　　1. 返回该模块<br>　　2. 不再继续执行<br><strong>文件模块：</strong>如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　1. 根据 X 所在的父模块，确定 X 的绝对路径<br>　　2. 将 X 当成文件，依次查找 X ， X.js ， X.json， X.node ，只要其中有一个存在，就返回该文件，不再继续执行<br>　　3. 将 X 当成目录，依次查找 X/package.json（main字段）， X/index.js， X/index.json， X/index.node， 只要其中有一个存在，就返回该文件，不再继续执行<br><strong>自定义模块：</strong>. 如果 X 不带路径，根据 X 所在的父模块，确定 X 可能的安装目录。 依次在每个目录中，将 X 当成文件名或目录名加载<br><strong>未找到模块：</strong> 抛出 “not found”</p></blockquote><h2 id="js中的默认变量"><a href="#js中的默认变量" class="headerlink" title="js中的默认变量"></a>js中的默认变量</h2><ul><li>exports：声明导出对象属性</li><li>require：导入模块方法</li><li>module：模块对象</li><li>__filename：js文件名</li><li>__dirname：js目录名</li></ul><p>这些默认属性是在js编译时，通过对js文件内容进行了头尾包装设置进去的。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头尾包装伪代码</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;\n 文件内容 \n&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// js文件内容</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">radius</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时的头尾包装</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">radius</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius; </span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="js中的包结构"><a href="#js中的包结构" class="headerlink" title="js中的包结构"></a>js中的包结构</h2><ul><li>package.json：包描述文件</li><li>bin：存放可执行二进制文件的目录</li><li>lib：存放js代码的目录</li><li>doc：存放文档的目录</li><li>test：存放单元测试用例代码的目录</li></ul><p>包描述信息介绍<br>package.json位于包的根目录，是对于包的描述信息的配置文件。字段规范如下：</p><table><thead><tr><th>key</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>名</td></tr><tr><td>description</td><td>简介</td></tr><tr><td>version</td><td>版本号</td></tr><tr><td>keywords</td><td>关键词数组</td></tr><tr><td>maintainers</td><td>维护者列表</td></tr><tr><td>contributors</td><td>贡献者列表</td></tr><tr><td>bugs</td><td>可以反馈bug的网页或邮箱地址</td></tr><tr><td>licenses</td><td>许可证列表</td></tr><tr><td>respositories</td><td>托管源码的位置列表</td></tr><tr><td>dependencies</td><td>依赖项列表</td></tr><tr><td>homepage</td><td>网站地址</td></tr><tr><td>os</td><td>操作系统支持列表</td></tr><tr><td>cpu</td><td>CPU架构支持列表</td></tr><tr><td>engine</td><td>支持的JS引擎列表</td></tr><tr><td>builten</td><td>是否内建在底层系统的标准组件</td></tr><tr><td>directories</td><td>目录说明</td></tr><tr><td>implements</td><td>实现规范的列表</td></tr><tr><td>scripts</td><td>脚本说明对象</td></tr><tr><td>authoer</td><td>作者</td></tr><tr><td>bin</td><td>配置为命令行工具</td></tr><tr><td>main</td><td>入口文件</td></tr><tr><td>devDependencies</td><td>开发依赖项列表</td></tr></tbody></table><h2 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令"></a>npm命令</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>$ npm</td><td>查看NPM帮助说明</td></tr><tr><td>$ npm -v</td><td>查看当前NPM版本</td></tr><tr><td>$ npm init</td><td>初始化包(配置package.json)</td></tr><tr><td>$ npm <command></td><td>查看具体命令帮助说明</td></tr><tr><td>$ npm install <package></package></td><td>安装第三方包</td></tr><tr><td>$ npm uninstall <package></package></td><td>卸载包</td></tr><tr><td>$ npm install <package> –save-dev</package></td><td>安装包并将安装信息写入package.json(devDependencies)</td></tr><tr><td>$ npm install <package> –dev</package></td><td>安装第包并将安装信息写入package.json(dependencies)</td></tr><tr><td>$ npm install <package> -g</package></td><td>全局安装第三方包</td></tr><tr><td>$ npm install <file-url></file-url></td><td>安装本地包</td></tr><tr><td>$ npm adduser</td><td>注册npm账号</td></tr><tr><td>$ npm publish <folder></folder></td><td>上传包</td></tr><tr><td>$ npm owner ls <package-name></package-name></td><td>查看包拥有者</td></tr><tr><td>$ npm owner add <user> <package-name></package-name></user></td><td>添加包拥有者</td></tr><tr><td>$ npm owner rm <user> <package-name></package-name></user></td><td>删除包拥有者</td></tr><tr><td>$ npm ls</td><td>分析包</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/05/require.html</a><br><a href="https://blog.csdn.net/q1056843325/article/details/54948719" target="_blank" rel="noopener">https://blog.csdn.net/q1056843325/article/details/54948719</a></p>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中声明属性和方法</title>
      <link href="/2018/12/09/Node-JS%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/09/Node-JS%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h1><p>es6中的class关键字，其实只是一个语法糖，本质上是对原型链的一个封装。</p><h1 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h1><p>截止es6，声明属性的最佳实践如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明类</span><br><span class="line">class Clazz &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // 建议将静态属性和对象属性的声明的初始化都放在构造函数中进行</span><br><span class="line">    // 声明对象属性</span><br><span class="line">    this.field = &quot;对象属性&quot;;</span><br><span class="line">    // 声明静态属性</span><br><span class="line">    Test.sField = &quot;静态属性&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本质说明"><a href="#本质说明" class="headerlink" title="本质说明"></a>本质说明</h3><ul><li>静态属性的本质就是在类上挂在对象，而类本质上就是构造函数function，所以静态属性就是直接在构造函数上挂在对象。</li><li>对象属性的本质就是在对象上挂在对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 实现对象属性的效果</span><br><span class="line">let clazz = new Clazz();</span><br><span class="line">clazz.field =  &quot;对象属性“;</span><br><span class="line"></span><br><span class="line">// 实现静态属性的效果</span><br><span class="line">Clazz.sField = &quot;静态属性&quot;;</span><br></pre></td></tr></table></figure><h2 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h2><p>截止es6，声明方法的最佳实践如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 声明类</span><br><span class="line">class Clazz &#123;</span><br><span class="line">  </span><br><span class="line">  func()&#123;</span><br><span class="line">    console.log(&quot;声明对象方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static sFunc()&#123;</span><br><span class="line">    console.log(&quot;声明静态方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用对象方法</span><br><span class="line">let clazz = new Clazz();</span><br><span class="line">clazz.func();</span><br><span class="line">// 调用静态方法</span><br><span class="line">Clazz.sFunc();</span><br></pre></td></tr></table></figure><h3 id="本质说明-1"><a href="#本质说明-1" class="headerlink" title="本质说明"></a>本质说明</h3><ul><li>静态方法本质和静态属性类似，就是在构造函数上挂在方法。</li><li>对象方法本质是在构造函数的原型链上挂在对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 声明类</span><br><span class="line">class Clazz &#123;</span><br><span class="line">  </span><br><span class="line">  func()&#123;</span><br><span class="line">    console.log(&quot;声明对象方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static sFunc()&#123;</span><br><span class="line">    console.log(&quot;声明静态方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">function Clazz()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Clazz.prototype.func = &#123;</span><br><span class="line">  console.log(&quot;声明对象方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clazz.sFunc = &#123;</span><br><span class="line">  console.log(&quot;声明静态方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中Promise的理解</title>
      <link href="/2018/11/25/Node-JS%E4%B8%ADPromise%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/11/25/Node-JS%E4%B8%ADPromise%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h1><p>Promise对象代表一个异步操作，里面保存着某个未来才会结束的事件的结果。对象的状态不受外界影响。</p><ul><li>Promise对象有三种状态：pending（进行中）、resolve（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li><li>Promise对象的状态改变，只有两种可能：从pending变为resolve和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</li><li>Promise对象的回调，可以暂存状态。即，如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</li></ul><h1 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h1><h3 id="基础语法介绍"><a href="#基础语法介绍" class="headerlink" title="基础语法介绍"></a>基础语法介绍</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明操作</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行异步操作，例如setTimeout方法</span></span><br><span class="line">  <span class="comment">// 但当前位置代码还是在主线程上操作的</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'do something'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Date</span>.now() % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    resolve(<span class="string">'success value'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 失败回调</span></span><br><span class="line">    reject(<span class="string">'failed value'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用操作</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 成功回调</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 失败回调，是可选的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise代码执行顺序"><a href="#Promise代码执行顺序" class="headerlink" title="Promise代码执行顺序"></a>Promise代码执行顺序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new Promise() 本质上是调用构造函数的操作</span></span><br><span class="line">  <span class="comment">// 因此，下面代码会在函数执行时，就被调用</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用resolved函数，将Promise中的resolved</span></span><br><span class="line">  <span class="comment">// 状态保存起来，待then时出发resolved状态</span></span><br><span class="line">  resolved();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在下一个事件循环中被调用</span></span><br><span class="line">  <span class="comment">// 当前脚本所有同步任务执行完才会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前脚本的同步执行任务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><h3 id="Promise返回一个Promise结果"><a href="#Promise返回一个Promise结果" class="headerlink" title="Promise返回一个Promise结果"></a>Promise返回一个Promise结果</h3><p>p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 构造p1时，开始3s计时操作</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造p1时，开始1s计时操作</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1s后，将p1结果保存下来</span></span><br><span class="line">  <span class="comment">// 由于p1是Promise对象，因此p1当前的状态确定了p2的状态，当前为pending状态</span></span><br><span class="line">  <span class="comment">// 2s后，p1返回reject状态，于是p2也返回了reject状态</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><h1 id="Promise特性介绍"><a href="#Promise特性介绍" class="headerlink" title="Promise特性介绍"></a>Promise特性介绍</h1><h3 id="Promise-prototype-then-介绍"><a href="#Promise-prototype-then-介绍" class="headerlink" title="Promise.prototype.then()介绍"></a>Promise.prototype.then()介绍</h3><p>then返回的作用是为 Promise 实例添加状态改变时的回调函数。</p><ul><li>then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</li><li>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then函数，将返回一个新的Promise实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造Promise对象</span></span><br><span class="line">  resolved(<span class="string">'first'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'second'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 相当于 Promise.reject('third');</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'third'</span></span><br><span class="line">&#125;).then(<span class="literal">null</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 相当于 Promise.resolved('fourth');</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'fourth'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch-介绍"><a href="#Promise-prototype-catch-介绍" class="headerlink" title="Promise.prototype.catch()介绍"></a>Promise.prototype.catch()介绍</h3><ul><li>Promise.prototype.catch方法是Promise.prototype.then(null, rejection)的别名，用于指定发生错误时的回调函数。</li><li>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</li></ul><p>一般在使用promise时，最好在后面添加catch操作。用catch来替代then(resolved, reject)的处理范式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐，在promise最后统一处理error情况</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally-介绍"><a href="#Promise-prototype-finally-介绍" class="headerlink" title="Promise.prototype.finally()介绍"></a>Promise.prototype.finally()介绍</h3><ul><li>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</li><li>finally方法的回调函数不接受任何参数，因此没有办法知道前面 Promise 状态到底是resolved还是rejected。</li></ul><p>finally方法的本质如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="常用静态方法"><a href="#常用静态方法" class="headerlink" title="常用静态方法"></a>常用静态方法</h1><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><p>p的状态由p1、p2、p3决定，分成两种情况。</p><ul><li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li></ul><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><p>p的状态由以下条件决定。</p><ul><li>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</li></ul><h3 id="Promise-resolve-amp-Promise-reject"><a href="#Promise-resolve-amp-Promise-reject" class="headerlink" title="Promise.resolve() &amp; Promise.reject()"></a>Promise.resolve() &amp; Promise.reject()</h3><p>Promise.resolve()的本质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/** p 为 Promise实例 **/</span>) &#123;</span><br><span class="line"><span class="comment">// 直接返回Promise实例</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/** p 中存在有thenable属性 **/</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">resolved(p.thenable());</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/** p 存在 **/</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">resolved(p);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/** p 不存在 **/</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">resolved();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.reject()的本质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-then" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-then</a></p>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中原型的理解</title>
      <link href="/2018/11/10/Node-JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/11/10/Node-JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="prototype与-proto-的区别"><a href="#prototype与-proto-的区别" class="headerlink" title="prototype与__proto__的区别"></a>prototype与__proto__的区别</h1><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ol><li>所有对象都具有__proto__属性。在JS中，一切皆对象。方法（Function）是对象，方法的原型(Function.prototype)也是对象，因此它们都有__proto__属性。</li><li>方法(Function)是一个特殊的对象，它除了有__proto__属性之外，还有自己特有的prototype属性。prototype属性指向一个所有实例共享的原型对象。原型对象中有一个constructor属性，指回到原函数。</li><li>对象的__proto__属性指向该对象的构造函数的prototype属性，这保证了对象能够访问构造函数的prototype属性中定义的属性和方法。</li></ol><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><p><img src="/image/js_prototype.jpg" alt="原型链图"></p><ol><li>构造函数（Foo()）<ul><li>构造函数的Foo.prototype属性指向了原型对象，在原型对象里有共有方法，所有构造函数声明的实例（f1，f2）都可以共享这些共用方法。</li><li>构造函数也是对象，也有__proto__属性。指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。</li></ul></li><li>原型对象（Foo.prototype）<ul><li>原型对象Foo.prototype保存着实例共享的方法，还有属性constructor指回构造函数。</li></ul></li><li>实例（f1，f2）<ul><li>f1，f2是Foo的两个实例，这两个对象有属性__proto__，指向构造函数的原型对象，这样就可以访问原型对象的所有方法啦。</li></ul></li></ol><p><strong>总结</strong></p><ol><li>对象有属性__proto__，指向该对象的构造函数的原型对象。</li><li>方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。</li></ol><h1 id="new操作到底做了什么？"><a href="#new操作到底做了什么？" class="headerlink" title="new操作到底做了什么？"></a>new操作到底做了什么？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Base();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上等价于</span></span><br><span class="line"><span class="comment">// 我们创建了一个空对象obj</span></span><br><span class="line"><span class="keyword">let</span> obj  = &#123;&#125;; </span><br><span class="line"><span class="comment">// 我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象</span></span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"><span class="comment">// 我们将Base函数对象的this指针替换成obj，并调用Base方法对obj进行初始化</span></span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h1 id="为啥constructor指向会错乱"><a href="#为啥constructor指向会错乱" class="headerlink" title="为啥constructor指向会错乱?"></a>为啥constructor指向会错乱?</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> F();</span><br><span class="line">F.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor)<span class="comment">//F</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor)<span class="comment">//Object</span></span><br></pre></td></tr></table></figure><p>首先你要明白，F.prototype 是对一个实例对象的引用，这个实例对象在你创建函数 F( ) 的时候同时被生成，如果我们给这个对象起个名字叫做 A，那么我们可以简单的理解为：A 是一个被存储在内存中的一个实例对象，而 F.prototype 是指向 A 的一个指针。</p><p>同时，A 对象内也有一个指针 constructor ，它指向了函数 F()。</p><p>那么当你第一次使用 new F( ) 时，生成了一个新对象 a ，p1 是对象 a 的一个引用（即p是指向a的一个指针），而 a 的 __proto__ 属性在此时也已经被指向为 A。</p><p>即目前，指向对象实例 A 的指针有两个，分别是 a.__proto__ 和 F.prototype。</p><p>之后你对 F.prototype 进行赋值时，实际上改变了 F.prototype 的指向，试他指向了另一个个实例对象{}，我们管这个实例对象叫 B 好了，对于这个实例对象 B，它的 constructor 的属性指向了 Object。</p><p>请注意，此时 a 的 __proto__ 的指向并没有改变，仍是指向了实例对象A。</p><p>那么当你第二次调用 new F( ) 的时候，实际上生成了另一个新的实例对象 b, b 的 __proto__ 属性指向的是B。</p><p>所以在 p1.constructor 的背后其实是相当于:<br>p1 -&gt; a, a.__proto__ -&gt; A, A.constructor -&gt; F( )</p><p>而在 p2.constructor 的背后则为：<br>p2 -&gt; b, b.__proto__ -&gt; B, B.constructor -&gt; Object( )</p><p><img src="/image/js_construct.png" alt="Construct指向图"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/q/1010000006918070" target="_blank" rel="noopener">https://segmentfault.com/q/1010000006918070</a></li><li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-对于《Socket心跳包》的思考</title>
      <link href="/2018/11/04/%E7%BD%91%E7%BB%9C-%E5%AF%B9%E4%BA%8E%E3%80%8ASocket%E5%BF%83%E8%B7%B3%E5%8C%85%E3%80%8B%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/11/04/%E7%BD%91%E7%BB%9C-%E5%AF%B9%E4%BA%8E%E3%80%8ASocket%E5%BF%83%E8%B7%B3%E5%8C%85%E3%80%8B%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要-Socket-心跳包"><a href="#为什么需要-Socket-心跳包" class="headerlink" title="为什么需要 Socket 心跳包"></a>为什么需要 Socket 心跳包</h2><p>实现方式上，TCP keepalive 和 Socket 心跳包机制类似。TCP keepalive 机制通过，在进行 TCP 连接时，发送 keepalive 数据包，来判断当前 TCP 连接是否仍然有效。问题来了，既然已经有了 TCP keepalive，为什么还需要 Socket 心跳机制呢？</p><p>个人认为，需要 Socket 心跳机制的原因如下：</p><ol><li>真实网路环境中，TCP keepalive 消息，可能会被中继设备和路由设备终结。</li><li>自己实现 Socket 心跳机制，处理断线重连的灵活性更高。</li><li>TCP keepalive 本身是 OSI 模型中的传输层处理逻辑，由操作系统负责探查，即便服务进程死锁或阻塞，操作系统也会如常处理 TCP keepalive 消息，因此 TCP keepalive 的目标是保证传输层的网路通畅。而 Socket 心跳机制，是 OSI 模型中的应用层处理逻辑，由服务程序负责探查，不但能保证应用程序存活，网络通畅，更重要的是能够保证应用程序仍在正常工作。</li></ol><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><ul><li>单工：只允许甲方向乙方传送信息，而乙方不能向甲方传送，例如汽车的单行道。</li><li>全双工：允许数据在两个方向上同时进行传送操作，例如汽车的双行道。</li><li>半双工：允许数据在两个方向上进行传送操作，但是两端不能同时传送。例如一条窄窄的马路，同时只能有一辆车通过，当目前有两辆车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开。</li></ul><h2 id="WebSocket-是什么？"><a href="#WebSocket-是什么？" class="headerlink" title="WebSocket 是什么？"></a>WebSocket 是什么？</h2><p>中文翻译</p><ul><li><a href="https://www.jianshu.com/p/867274a5e054" target="_blank" rel="noopener">https://www.jianshu.com/p/867274a5e054</a></li><li><a href="https://www.jianshu.com/p/fc09b0899141" target="_blank" rel="noopener">https://www.jianshu.com/p/fc09b0899141</a></li></ul><p>英文原文</p><ul><li><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455</a></li></ul><h2 id="OkHttp3-中-WebSocket-心跳设计"><a href="#OkHttp3-中-WebSocket-心跳设计" class="headerlink" title="OkHttp3 中 WebSocket 心跳设计"></a>OkHttp3 中 WebSocket 心跳设计</h2><p>OkHttp3 在 3.5 版本之后，对 WebSocket 进行了支持。</p><p>OkHttp3:3.5~3.10</p><ul><li>没有做心跳失效操作，手机端只负责发送 ping 操作，不管 pong 是否有收到。</li></ul><p>OkHttp3:3.11.0~之后</p><ul><li>做了简单的心跳失效操作，当发送第二次 ping 时，第一次 ping 的服务端 pong 还没有得到回应，则说明心跳失效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-大搜车的注解收集器</title>
      <link href="/2018/10/30/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2018/10/30/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是对编译时注解展开讨论。Android端对自定义注解的应用程度远没有达到Java Web端的那种程度，而且市面上也没有一个专注于抽象编译时注解底层技术的库。</p><p>在真实开发场景中，如果想要实现一个利用编译时注解的功能，往往需要花大量精力来处理APT这块的繁琐逻辑。例如，遍历所有注解相关类然后生成一定规律的代码。这些繁琐操作阻碍了大家使用注解的热情。设想一下，如果使用编译时注解只需要增加一两行代码，那你会不会更愿意使用注解呢？</p><p>所以，我们在想是否能够对编译时注解做进一步的抽象，帮助开发者将重点放在具体的功能实现上，而不是处理编译时注解的繁琐操作上？</p><h1 id="Nara的诞生"><a href="#Nara的诞生" class="headerlink" title="Nara的诞生"></a>Nara的诞生</h1><p>在动手之前，需要先弄清楚大家利用注解都做了哪些事情。清楚注解的使用场景，能帮助我们抽象出一个更好用的注解框架。于是，我们调研了Android端上常用的注解框架，看看他们利用注解都做了什么事情？</p><ul><li><p>ButterKnife：例如@BindViews，ButterKnife在编译期，利用@BindView将控件ID和类属性建立对应关系。然后在页面启动时，根据控件ID通过findViewById方法将控件赋值到类属性上。</p></li><li><p>EventBus：通过@Subscribe对普通方法进行标记。然后，EventBus在编译期通过@Subscribe将这些方法收集起来，作为EventBus的订阅方法。</p></li><li><p>Retrofit：通过反射方式处理注解，不再本文范畴。</p></li></ul><p>编译时注解的主要用途在于，收集注解并通过注解信息生成一些有规律的代码。</p><p>而这些有规律的代码，一般都是可以通过其他方式来间接实现的。比如说，ButterKnife的属性赋值可以通过反射来实现，EventBus的方法收集可以直接换个写法。所以，如果要对编译时注解做进一步抽象，我们认为可以从注解收集方面入手。由此，Nara注解收集器诞生了。</p><h2 id="API的设计"><a href="#API的设计" class="headerlink" title="API的设计"></a>API的设计</h2><p>对于底层库而言，设计一套好用的API是很重要的。从库的使用者角度看，希望注解收集器能够帮助我们实现哪些功能呢？</p><ul><li>注解的作用范围：通过分析市面上编译时注解的使用场景，发现对注解的应用主要在于类，方法和属性上。</li><li>自定义注解：作为注解抽象库，如果无法支持自定义注解，那对可扩展性简直就是致命的打击。所以需要提供自定义注解功能。</li><li>注解收集：注解收集作为核心功能，必须要提供一套好用的收集操作。我们考虑用链式Builder来完成注解收集功能。</li></ul><p>最终设计的API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解API</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE, ElementType.METHOD, ElementType.FIELD)</span><br><span class="line"><span class="meta">@ShadowBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解的使用API</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationClass</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">AnnotationMethod</span><span class="params">(<span class="keyword">int</span> p1, String p2, AnnotationClass p3, T p4)</span></span>&#123;</span><br><span class="line">    Log.e(<span class="string">"souche"</span>, <span class="string">"test2("</span> + <span class="string">"p1("</span> + p1 + <span class="string">"),p2("</span> + p2 + <span class="string">"),p3("</span> + p3 + <span class="string">"),p4("</span> + p4 + <span class="string">"));"</span>);</span><br><span class="line">    <span class="keyword">return</span> p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 成员属性</span></span><br><span class="line"><span class="keyword">public</span> List&lt;AnnotationClass&gt; annotationField;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集注解的使用API，以Class的收集举例</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">List&lt;ClassDesc&gt; listClass = Nara</span><br><span class="line">                .findClass(CustomAnnotation.class) <span class="comment">// 查找类，参数为其所在注解</span></span><br><span class="line">                .withExtends(Activity.class) <span class="comment">// 筛选条件：查找的类，需要继承Activity类</span></span><br><span class="line">                .withAnnotations(Collect.class) <span class="comment">// 筛选条件：查找的类，需要被@Collect注解</span></span><br><span class="line">                .filter(<span class="keyword">new</span> AnnotationFilter&lt;ClassDesc&gt;() &#123; <span class="comment">// 自定义筛选条件：return true 表示过滤掉当前类</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(ClassDesc obj)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .list(); <span class="comment">// 返回符合条件的类集合</span></span><br></pre></td></tr></table></figure><h1 id="实现的痛点"><a href="#实现的痛点" class="headerlink" title="实现的痛点"></a>实现的痛点</h1><p>一个优秀的底层库，应该将复杂实现隐藏起来，并且做到实现对于上层使用者透明。下面简单分享下实现Nara时，遇到的几个技术痛点。</p><h3 id="对泛型的支持"><a href="#对泛型的支持" class="headerlink" title="对泛型的支持"></a>对泛型的支持</h3><p>在收集注解信息时，会遇到方法参数或者属性中带有泛型信息的情况。为了收集这些泛型信息，我们利用了Gson实现的TypeToken泛型Type转化工具。将TypeToken的相关代码拷贝到了Nara内部。Gson获取Type的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">new</span> TypeToken&lt;clazz&gt;() &#123;&#125;.getType();</span><br></pre></td></tr></table></figure><h2 id="被注解对象的包级作用域问题"><a href="#被注解对象的包级作用域问题" class="headerlink" title="被注解对象的包级作用域问题"></a>被注解对象的包级作用域问题</h2><p>Nara注解收集是支持包级作用域的信息收集的。这里就存在一个问题，包作用域的类，方法和属性是不允许跨包访问的。那么，如何在不同包下获取包级作用域下的信息呢？我们采取的方式是利用编译时注解生成被注解类的同包名下的类，然后将包级作用域的信息用public的形式暴露出来。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 例如包级作用域的属性</span></span><br><span class="line"><span class="keyword">package</span> com.example.souche.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span></span><br><span class="line">String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将People.name的get和set方法的作用域暴露出来</span></span><br><span class="line"><span class="comment">// 我们在编译时，生成了public作用域的get和set方法</span></span><br><span class="line"><span class="keyword">package</span> com.example.souche.annotation;</span><br><span class="line"><span class="comment">/** This class is generated by SouChe Annotation Collection, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerCollection</span>$<span class="title">AdaptableClass1540292058755_29</span> </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">com</span>.<span class="title">souche</span>.<span class="title">android</span>.<span class="title">annotation</span>.<span class="title">core</span>.<span class="title">FieldDesc</span>.<span class="title">BeanMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object... params)</span></span>&#123; </span><br><span class="line">                <span class="keyword">if</span> (params.length != <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"set argument format error!"</span>);</span><br><span class="line">                com.example.souche.annotation.People.name = (java.lang.String)params[<span class="number">0</span>];</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object... params)</span></span>&#123; </span><br><span class="line">                <span class="keyword">if</span> (params.length != <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"get argument format error!"</span>);</span><br><span class="line">                <span class="keyword">return</span> com.example.souche.annotation.People.name;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件化下的编译时注解问题"><a href="#组件化下的编译时注解问题" class="headerlink" title="组件化下的编译时注解问题"></a>组件化下的编译时注解问题</h2><p>我们团队是采用的是模块化的开发形式，模块将代码将aar包上传到maven仓库，主工程再通过gradle来依赖模块aar包。这样就会存在一个问题，由于编译时注解的作用范围是源码级别的，所以无法对aar包中的注解进行收集。</p><p>我们的解决思路是，如果模块需要使用Nara注解收集器，在模块打包时，就将Nara相关代码打进aar包，然后在主工程打包时，通过gradle插件扫描整个app的字节码，找到Nara相关代码，将这些代码整合起来，生成一个Nara初始化主类。总体打包流程如下：</p><p><img src="/image/nara_compile_flowchat.png" alt="编译流程图"></p><h1 id="框架愿景"><a href="#框架愿景" class="headerlink" title="框架愿景"></a>框架愿景</h1><p>Nara是对编译时注解的上层抽象，我们希望通过Nara来降低编译时注解的开发成本。让使用者把精力放在逻辑实现上，而不是在注解信息收集上。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-OSI 七层通讯</title>
      <link href="/2018/10/11/%E7%BD%91%E7%BB%9C-OSI-%E4%B8%83%E5%B1%82%E9%80%9A%E8%AE%AF/"/>
      <url>/2018/10/11/%E7%BD%91%E7%BB%9C-OSI-%E4%B8%83%E5%B1%82%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<style>table th:nth-of-type(1) {    width: 100px;}</style><h2 id="OSI七层通讯"><a href="#OSI七层通讯" class="headerlink" title="OSI七层通讯"></a>OSI七层通讯</h2><table><thead><tr><th>通讯层</th><th>作用说明</th></tr></thead><tbody><tr><td>应用层</td><td>它的作用fancybox是为应用程序提供服务并规定应用程序中通讯相关的细节。是最贴近应用开发人员的网络层。常见的协议有 HTTP，FTP，TELNET、SMTP 等。</td></tr><tr><td>表示层</td><td>它的作用是将应用层处理的信息从主机特有的格式转换为网络标准传输格式</td></tr><tr><td>会话层</td><td>它的作用是确定建立和断开网络的时机，并管理网络连接</td></tr><tr><td>传输层</td><td>它的作用是建立网络连接，创建逻辑上的通信连接，从逻辑上将数据发送到目标对象</td></tr><tr><td>网络层</td><td>它的作用是将数据传输到目标地址，重点在于寻找目标地址。可能需要通过多个路由器连接才能到达目标地址。</td></tr><tr><td>数据链路层</td><td>它的作用是物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。</td></tr><tr><td>物理层</td><td>它的作用是将0、1比特流（0、1序列）与电信号和光信号进行转化。实现物理层面上的数据传输。</td></tr></tbody></table><h2 id="网络设备对应的OSI通讯层"><a href="#网络设备对应的OSI通讯层" class="headerlink" title="网络设备对应的OSI通讯层"></a>网络设备对应的OSI通讯层</h2><ul><li><p>物理层：中继器<br><img src="/image/network_中继器.png" alt="网络设备图"></p></li><li><p>数据链路层：网桥<br><img src="/image/network_网桥.png" alt="网络设备图"></p></li><li><p>网络层：路由器<br><img src="/image/network_路由器.png" alt="网络设备图"></p></li><li><p>上层应用：网关<br><img src="/image/network_网关.png" alt="网络设备图"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 同步</title>
      <link href="/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><p>当多线程共享可变数据时，每个读或者写数据的线程都必须执行同步。同步方式可以是加锁，也可以是volatile。如果没有同步，就无法确保一个线程所做的修改可以被另一个线程获知。</p><h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><ul><li>在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。过度的帮助类进行同步操作，会带来性能上的损耗</li><li><p>为了避免不可控性，千万不要在同步区域中调用外来方法。要把同步操作的控制权牢牢抓在自己手中</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet set, Object element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&gt; observers</span><br><span class="line">                        = <span class="keyword">new</span> ArrayList&lt;SetObserver&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误通知示范：</span></span><br><span class="line">    <span class="comment">// 如果在SetObserver的added()方法中调用复杂的addObserver()方法，</span></span><br><span class="line">    <span class="comment">// 会导致ConcurrentModificationException异常，相当于外部调用方法</span></span><br><span class="line">    <span class="comment">// 来影响同步代码块中的操作逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SetObserver observer : observers)</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确通知示范：</span></span><br><span class="line">    <span class="comment">// 将外来调用方法放到同步块外面，同步块中只做极少的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        List&lt;SetObserver&gt; tempObservers;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            tempObservers = <span class="keyword">new</span> ArrayList(observers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SetObserver observer : tempObservers)</span><br><span class="line">            observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加数据步骤省略</span></span><br><span class="line">        <span class="comment">// 通知所有观察者对象</span></span><br><span class="line">        <span class="keyword">if</span> (added)</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="executor和task优先于线程"><a href="#executor和task优先于线程" class="headerlink" title="executor和task优先于线程"></a>executor和task优先于线程</h2><p>Executor Framework提供了灵活的任务执行工具，支持各种类型的线程池。引导开发者将线程工作拆分成了独立任务单元(Runnable)。因此，推荐开发者使用Executor解决问题，而不是自己创建线程。</p><h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><ul><li>大多数域应该正常地进行初始化，而不是延迟初始化。延迟初始化会带来同步问题，产生不必要的错误</li><li><p>某些场景必须要使用延迟初始化，有如下建议：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于静态作用域，建议使用Class Holder初始化模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于实例域，则建议使用双重检查模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function">FieldValue <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">    field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于可以接受重复初始化的实例域，则考虑使用单重检测模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><p>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移殖的。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 异常</title>
      <link href="/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="只针对异常情况才使用异常"><a href="#只针对异常情况才使用异常" class="headerlink" title="只针对异常情况才使用异常"></a>只针对异常情况才使用异常</h2><p>控制正常流程时不应该使用异常，只有当程序发生异常时才应该抛出Exception。Exception就是来描述程序发生异常的，不要职责不清地让异常来处理非异常的事情。例如下面的for-each循环，不应该用异常来控制循环，而应该用状态测试来控制循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范，通过异常来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.next()的NoSuchElementException来判断循环是否结束</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line">    <span class="comment">// 终止循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示范，通过状态测试方法来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.hasNext()方法来判断循环是否结束</span></span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"><a href="#对于可恢复的情况使用受检异常，对于编程错误使用运行时异常" class="headerlink" title="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"></a>对于可恢复的情况使用受检异常，对于编程错误使用运行时异常</h2><ul><li>受检异常：如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。例如文件操作后，文件流的关闭操作。</li><li>非受检异常：如果程序抛出未受检异常或者错误，往往就属于不可恢复的情形，继续执行下去有害无益。例如List.get()的数据越界操作。</li></ul><h2 id="避免不必要地使用受检异常"><a href="#避免不必要地使用受检异常" class="headerlink" title="避免不必要地使用受检异常"></a>避免不必要地使用受检异常</h2><p>当方法存在受检异常时，会给API调用者增加使用成本，例如每次调用该方法时，都要加try-catch代码块。应当少用受检异常。</p><p>使用受检异常的原则</p><ul><li>正确地使用API并不能阻止这种异常条件的产生。参考文件操作，无法保证文件操作不会抛出异常。</li><li>产生异常后，API调用者可以立即采用有效操作。参考文件操作，文件操作抛出异常后，马上关闭文件，然后执行文件处理失败逻辑。</li></ul><h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><p>利用Java提供的标准异常，相当于站在了巨人的肩膀上。可以使你的API更加易于学习，易于使用，更加可读。</p><h2 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h2><p>方法抛出的异常，应该与当前方法有联系。上层实现应该捕获下层异常，同时抛出符合上层语义的异常。例如集合中的异常处理示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将NoSuchElementException改为IndexOutOfBoundException</span></span><br><span class="line"><span class="comment">// 使方法抛出的异常更符合语义，提高了代码的可读性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">ListIterator&lt;E&gt; i = listIterator(index);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.next();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundException(<span class="string">"Index:"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常中包含能捕获失败的信息"><a href="#异常中包含能捕获失败的信息" class="headerlink" title="异常中包含能捕获失败的信息"></a>异常中包含能捕获失败的信息</h2><p>异常面向的用户是开发者，异常信息的内容，应该提供异常堆栈信息，异常信息描述的详细内容等。因为异常面向开发者，所以描述信息最好为英文。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 通用程序设计</title>
      <link href="/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><p>将局部变量的作用域最小化，使代码减少出错，更加可读。</p><ul><li><p>降低出错的可能性</p><blockquote><p>如果变量在它的目标使用区域之前或者之后被意外地使用的话，会产生意想不到的错误。示例如下：</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">Iterator&lt;Element&gt; i = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator();</span><br><span class="line"><span class="comment">// BUG，误将i2写成了i，导致不必要的错误</span></span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomethingElse(i2.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供作用域的最小范围，可以避免此类错误的发生</span></span><br><span class="line">;</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c2.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomethingElse(i.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强可读性</p><blockquote><p>将变量放在使用之前声明，会分散读者注意力。等到用到该变量的时候，读者可能已经记不起该变量的类型和初始值了。</p></blockquote></li></ul><h2 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h2><p>能用for-each循环实现功能的情况下，尽量使用for-each循环。</p><ul><li>for-each循环内部帮你维护了迭代器，降低了自己维护迭代器产生错误的风险。</li><li>for-each循环让代码变得尽量简洁，提高代码可读性。</li></ul><h2 id="如果需要精确的数值，请避免使用float和double"><a href="#如果需要精确的数值，请避免使用float和double" class="headerlink" title="如果需要精确的数值，请避免使用float和double"></a>如果需要精确的数值，请避免使用float和double</h2><ul><li>float和double类型，并没有提供完全精确的结果。所以不应该被用于需要精确结果的场合。尤其不适合用于货币计算，最好用int，long或BigDecimal代替。</li></ul><h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><p>能用基本类型就尽量使用基本类型。装箱基本类型存在以下缺点：</p><ul><li>两个装箱基本类型，存在相同的数值，却只想不同的内存对象。进行比较时，需要调用equil，同时还需考虑NullPointException异常。提高了使用的成本，加大了在开发中出错的风险。</li><li>基本类型比装箱基本类型更节省内存空间，在进行运算操作时也更节省运行时间。装箱基本类型可能会存在频繁的装箱和拆箱。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-规划与迭代</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第八章 成长：规划与迭代》的内容摘要。</p><p>规划是战略布局，是定方向，做正确的事；迭代是战术实施，是定走法，正确地做事。规划的重点在于想，迭代的重点在于动手实现。</p><ul><li>规划，是以自我为中心，以公司为中心的，是生产驱动的。</li><li>迭代，是需求驱动的，是对用户反馈的不断响应，需要根据市场信息的变化一步步的调整。</li></ul><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>由于互联网处于快速变化的大环境中，因此会存在规划更不上变化的情况。最好只做两个规划，最长规划和最短规划。最短规划指最近1个月到3个月，最多6个月的时间段里，要做什么，其实更像是一个项目计划。长计划是这个产品的终极目标，比如3到5年，甚至10年以后会是什么样子，要思考那个时候我们能处于产业链的什么位置。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代的重点在于实现，建议使用敏捷开发的方式，敏捷开发有一下几个关键点。</p><ul><li>沟通，团队之间要进行快速沟通，建立相互信任相互认可的团队氛围。</li><li>简单，做最简单的事，实现想要的目的。</li><li>反馈，拥抱变化，用包容的心态去面对多方反馈，来自同事，用户等。</li><li>勇气，不怕犯错，用于尝试新事物，用于创新。</li><li>谦逊，承认自己的片面性，虚心接受来自多方的建议，善于借助多方的优势。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-确定功能的价值</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第六章 功能：细化与打包》的内容摘要。</p><h2 id="功能评估"><a href="#功能评估" class="headerlink" title="功能评估"></a>功能评估</h2><p>在动手之前，应该先对功能进行评估。功能的评估，主要从价值，成本，功能定位三个角度进行考量。参考一个性价比公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 价值最好分为6个等级（1，2，3，4，5，无限高） 成本最好按照 人/天 为单位</span></span><br><span class="line">性价比 = 价值/成本</span><br></pre></td></tr></table></figure><p>从理论上讲，性价比高的功能优先级也就高，应该先做。不过还应该考虑功能的定位，如果是基础功能，例如支付宝的支付功能，不管代价多大都要做了。</p><h2 id="功能的价值判断"><a href="#功能的价值判断" class="headerlink" title="功能的价值判断"></a>功能的价值判断</h2><p>从三个角度来判断功能的价值，分别是广度，频度，强度。</p><ul><li>广度：潜在用户数 * 单用户价值 可以用来判断功能对应的市场容量及广度。<ul><li>例如打车软件，潜在用户可能是几亿人的打车需求，因为用户使用基数大，所以价值高。</li><li>例如私人银行业务，虽然潜在用户比较少，但每个潜在用户都会有几个亿的存款，因为单用户价值高，所以价值高。</li></ul></li><li>频度：用户使用功能的频率 * 每次使用的转化率。<ul><li>例如外卖软件，用户可能一天要用好几次，每次可以从中转化几元钱，因为用户使用频度大，所以价值高。</li><li>例如结婚软件，用户可能一辈子用一次，但每次可以从中转化几万甚至是几十万，因为使用转化率大，所以价值高。</li></ul></li><li>强度：强度可以理解为用户刚需。可以从不可替代性，紧急程度，持久程度这几方面来看功能的强度。<ul><li>例如，当前功能是否可以被其他功能间接替代。</li><li>例如当前功能是否十分紧急，可能是政府要求等。</li><li>例如当前功能做出来之后是否可以长久投入使用，广告页需求不能持久投入使用。</li></ul></li></ul><h2 id="功能的实现成本"><a href="#功能的实现成本" class="headerlink" title="功能的实现成本"></a>功能的实现成本</h2><p>确定功能之后，粗粒度的评估出完成该功能需要花费的人力成本为多少，以 人/天 为单位。</p><h2 id="功能的定位"><a href="#功能的定位" class="headerlink" title="功能的定位"></a>功能的定位</h2><p>确定一个功能的定位，同样是非常重要的。帮助我们在评估功能的时候，了解该功能的重要程度。</p><ul><li>基础功能：基础功能是每个软件的核心功能，是必不可少的功能。例如支付宝的支付功能，淘宝的购物功能等。</li><li>亮点功能：亮点功能是提升用户忠诚度和口碑传播的功能。一个没有亮点的产品，用户也许偶尔会用，但不会建立正向感情连接，更不会主动帮我们传播。算是应用吸引客户的加分项。例如Chrome的404页面，iPhone5s的指纹识别</li><li>期望功能：期望功能是部分用户期望实现的功能。这类功能属于有则更好的类型，锦上添花。例如网易云音乐的音乐闹钟。</li><li>反向功能：反向功能是出现了会让用户讨厌但是又有利可图的功能。例如，软件广告，迅雷非会员限速功能等。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在确定功能时，首先应该确定功能定位；然后从广度，频度和强度三个方面进行评估功能的价值；最后确定开发成本。最后根据性价比公式，把功能的性价比算出来。然后参考性价比来实现优先实现简单且重要的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>人人都是产品经理 第二版</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Google I/O&#39; 2018 摘要</title>
      <link href="/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/"/>
      <url>/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是了解下未来的趋势，开阔眼界。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>今年大会的重点之一，感觉这方面是未来的大势所趋。降低生产力成本，改善生活。</p><ul><li><p>Google为了推广TensorFlow，作出了很多努力。在社区上积极帮助开发者解决机器学习遇到的各种问题，希望将TensorFlow推广到各个领域。</p></li><li><p>介绍了TensorFlow应用于医学的案例，希望通过机器学习为更多人提供医疗支持。举例在糖尿病眼球病变检测专业，已经做到了专家级的准确率。</p></li><li><p>介绍TensorFlow高层API，帮助开发者快速高效的搭建和训练模型。</p></li><li><p>TensorFlow支持Swift和JavaScript语言。JavaScript支持浏览器和Node环境。希望将TensorFlow和更多的开发体系相融合。</p></li><li><p>移动端的TensorFlow Lite方案，TensorFlow在移动设备上运行机器学习的终端解决方案，具备低延迟，runtime和小体积的特点。通过利用移动端硬件，提升解析速度。</p></li></ul><h3 id="闲鱼TensorFlow-Lite的应用："><a href="#闲鱼TensorFlow-Lite的应用：" class="headerlink" title="闲鱼TensorFlow Lite的应用："></a>闲鱼TensorFlow Lite的应用：</h3><ul><li><p>从节省人工成本角度：做了视频封面的抽取功能，做到自动提取视频预览页</p></li><li><p>从缓解服务端计算压力角度：做了视频指纹，去除重复上传的视频</p></li><li><p>从交互智能化角度：做了AI版房租信息发布页面，提供了用户操作的AI交互方式</p></li></ul><h3 id="端侧AI优势"><a href="#端侧AI优势" class="headerlink" title="端侧AI优势"></a>端侧AI优势</h3><ul><li><p>无网络延时</p></li><li><p>更高稳定性</p></li><li><p>数据隐私性</p></li><li><p>响应实时性</p></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>因为Flutter介绍，找不到视频，所以摘录了闲鱼的总结</p><ul><li><p>Flutter 与 原生混合开发的支持方式</p></li><li><p>如何在混合开发时，更好的利用hot reload机制</p></li><li><p>Flutter和原生组件的组合使用可行性介绍</p></li><li><p>Flutter 渲染原理层介绍<br><img src="/image/flutter_draw.png" alt="Flutter渲染原理图"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Flutter相关：<a href="https://yq.aliyun.com/articles/643698" target="_blank" rel="noopener">https://yq.aliyun.com/articles/643698</a></p><p>AI视频：<a href="https://live.iqiyi.com/s/19rqqzqp9v.html" target="_blank" rel="noopener">https://live.iqiyi.com/s/19rqqzqp9v.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 方法设计</title>
      <link href="/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="检验参数的有效性"><a href="#检验参数的有效性" class="headerlink" title="检验参数的有效性"></a>检验参数的有效性</h2><ul><li><p>应该在方法开头就检验参数的有效性，及时报出参数错误。</p><blockquote><p>传递无效参数给方法，这个方法在执行之前先对参数进行检验，那么他很快就会失败，并且清楚地呈现出适当的异常。如果这个方法没有检查他的参数，就有可能发生以下几种情景。该方法可能在处理过程中失败，并且产生令人费解的异常。更糟糕的是，该方法可以正常方法，但是会悄悄地计算出错误结果。最糟糕的是，该方法可以正常返回，但是却使得某个对象处于被破坏的状态，将来在某个不确定的时候，在某个不相关的点上会引发错误。</p></blockquote></li><li><p>public方法的参数校验直接抛出异常，包内方法则使用assert断言校验参数。</p><blockquote><p>对于未被导出方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。因此，非公有的方法通常应该使用断言来检查它们的参数。</p></blockquote></li></ul><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><ul><li><p>方法的入参和出参都需要考虑保护性拷贝。防止外部方法对其进行破坏性操作。这里的外部方法是指使用类的第三方方法。保护性拷贝不是必须的，但是每次在代码的时候，都应该考虑到这一步操作。尤其是写底层库的时候。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">newClass</span><span class="params">(List&lt;String&gt; args)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;String&gt;(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><ul><li><p>方法名称很重要，在设计方法名时，应该始终遵守标准的命名习惯。</p><blockquote><p>尽量让自己的方法名看起来像一句话一样。在定好自己的方法名之后，最后写伪代码调用自己的方法，验证方法的可读性。设计底层库时很重要。</p></blockquote></li><li><p>避免过长的方法参数列表。</p><blockquote><p>方法的参数最好不超过4个。如果方法参数真的很长，可以考虑Build模式，让使用者优雅的设值，或者考虑外观类，给复杂的实现方法套一层简单的壳。</p></blockquote></li><li><p>boolean类型参数最好用枚举替代。</p><blockquote><p>这是boolean类型参数的小小建议。如果要在参数中使用boolean类型，最好用枚举类型进行替代。首先枚举更具有可读性，其次枚举更利于以后的扩展。</p></blockquote></li></ul><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><ul><li><p>Java语言要调用哪个重载方法是在编译时做出决定的。这一点不符合Java语言的运行时特性。一般情况下，我们认为覆盖操作比较符合Java标准的运行时特性。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载了classify方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection&lt;?&gt;[] collections = &#123; <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, String&gt;().values() &#125;;</span><br><span class="line"><span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</span><br><span class="line">System.out.println(classify(c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期是打印出Set，List，Unknown Collection。但是实际上是打印出Unknown Collection，</span></span><br><span class="line"><span class="comment">// Unknown Collection，Unknown Collection。因为重载是根据编译时决定要调用的是哪个方法。</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于重载容易引起编程时的想法和运行结果不一致。所以，在使用重载编写设计API的时候，应该尽量避免使用。防止API使用者引起误会。如果重载方法的参数的类型有继承关系，例如parse(String content)和parse(Object content)，最好用方法名区分开，paeseString(String content)和parseObject(Object content)。<strong>总之，方法参数数目相同的方法，应该尽量避免重载。</strong></p></blockquote></li></ul><h2 id="返回零长度的集合，而不是null"><a href="#返回零长度的集合，而不是null" class="headerlink" title="返回零长度的集合，而不是null"></a>返回零长度的集合，而不是null</h2><ul><li><p>方法返回集合时，如果集合内容为空，则返回一个空的集合对象，而不是null。</p><blockquote><p>因为对于返回null而不是零长度集合的方法来说，每次调用该方法时都需要判断下返回对象是都为null，从而防止NullPointerException，对于方法使用者很不友好。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>建站初衷</title>
      <link href="/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/"/>
      <url>/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>工作角色逐渐从客户端开发者转变为独立开发者。之前读大学的时候，还有写博客的习惯，后来慢慢转变为做笔记，最近变成了只看书不做笔记了。感觉在学习过程中，缺乏了深度思考的过程。于是，打算搭建个人博客，逼着自己做些深度思考的事情吧。将博客产出作为学习的考核标准。贵在坚持，持之以恒~</p><blockquote><p>博客地址: <a href="http://blog.daiyibo.cn">http://blog.daiyibo.cn</a></p></blockquote><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>Hexo搭建，算是比较简单了。在安装好git开发环境和node开发环境的情况下。需要做的事情如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 安装Hexo</span><br><span class="line"></span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">// 新建博客目录</span><br><span class="line"></span><br><span class="line">mkdir blog</span><br><span class="line"></span><br><span class="line">// 初始化Hexo模板</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">// 启动4000端口，运行博客，主要是本地测试用</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新建博客，下面命令会新建一个XXX.md的文件</span><br><span class="line"></span><br><span class="line">hexo new XXX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 全栈 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
