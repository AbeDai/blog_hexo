<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Node-#转：koa-route路由源码解析</title>
      <link href="/2019/02/03/Node-%E8%BD%AC%EF%BC%9Akoa-route%E8%B7%AF%E7%94%B1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/02/03/Node-%E8%BD%AC%EF%BC%9Akoa-route%E8%B7%AF%E7%94%B1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>koa-route在koa中负责路由分发，是很重要的一环。本打算自己写篇文章总结下的，但在<code>segmentfault</code>上看到了一篇总结得很到位的文章。感觉自己写也就只能写成这样了，所以直接转载了😂</p><blockquote><p>文章地址：<a href="https://segmentfault.com/a/1190000007468233" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007468233</a></p></blockquote><hr><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="/image/koa_router_method_struct.png" alt=""></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/image/koa_route_method_flow.png" alt=""></p><blockquote><p>上面两张图主要将koa-router的整体代码结构和大概的执行流程画了出来，画的不够具体。那下面主要讲koa-router中的几处的关键代码解读一下。</p></blockquote><p>读代码首先要找到入口文件，那几乎所有的node模块的入口文件都会在package.json文件中的main属性指明了。koa-router的入口文件就是lib/router.js。</p><h2 id="第三方模块说明"><a href="#第三方模块说明" class="headerlink" title="第三方模块说明"></a>第三方模块说明</h2><p>首先先讲几个第三方的node模块了解一下，因为后面的代码讲解中会用到，不去看具体实现，只要知道其功能就行： </p><ul><li><strong><a href="https://github.com/koajs/compose" target="_blank" rel="noopener">koa-compose</a></strong>： 提供给它一个中间件数组， 返回一个顺序执行所有中间件的执行函数</li><li><strong><a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a></strong>： node中支持的http动词，就是http.METHODS，可以在终端输出看看</li><li><strong><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a></strong>： 将路径字符串转换成强大的正则表达式，还可以输出路径参数</li></ul><h2 id="Router-amp-Layer"><a href="#Router-amp-Layer" class="headerlink" title="Router &amp; Layer"></a>Router &amp; Layer</h2><p><img src="/image/koa_route_route_and_layer.png" alt=""></p><p>Router 和 Layer 分别是两个构造函数，分别在router.js 和 layer.js中，koa-router的所有代码也就在这两个文件中，可以知道它的代码量并不是很多。</p><h4 id="Router-创建管理整个路由模块的实例"><a href="#Router-创建管理整个路由模块的实例" class="headerlink" title="Router: 创建管理整个路由模块的实例"></a>Router: 创建管理整个路由模块的实例</h4><ul><li><strong>this.methods</strong>: 在后面要讲的allowedMethods方法中要用到的，目的是响应options请求和请求出错的处理</li><li><strong>this.params</strong>: 全局的路由参数处理的中间件组成的对象</li><li><strong>this.stack</strong>: 其实就是各个路由(Layer)实例组成的数组。每次处理请求时都需要循环这个数组找到匹配的路由</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 常用的 去new 方式</span></span><br><span class="line">  <span class="comment">// 初始化Router只需要调用require('koa-router')()，而不需要调用new require('koa-router')()方法</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Router)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Router(opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.methods = <span class="keyword">this</span>.opts.methods || [</span><br><span class="line">    <span class="string">'HEAD'</span>,</span><br><span class="line">    <span class="string">'OPTIONS'</span>,</span><br><span class="line">    <span class="string">'GET'</span>,</span><br><span class="line">    <span class="string">'PUT'</span>,</span><br><span class="line">    <span class="string">'PATCH'</span>,</span><br><span class="line">    <span class="string">'POST'</span>,</span><br><span class="line">    <span class="string">'DELETE'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.params = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.stack = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Layer-创建各个路由实例"><a href="#Layer-创建各个路由实例" class="headerlink" title="Layer: 创建各个路由实例"></a>Layer: 创建各个路由实例</h4><p>这里的this.stack和Router中的不同，这里的是路由所有的中间件的数组。（一个路由可以有多个中间件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layer</span>(<span class="params">path, methods, middleware, opts</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.stack = <span class="built_in">Array</span>.isArray(middleware) ? middleware : [middleware];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为给后面的allowedMthods处理</span></span><br><span class="line">  methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="keyword">this</span>.methods.push(method.toUpperCase());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.methods[l<span class="number">-1</span>] === <span class="string">'GET'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是get请求，则支持head请求</span></span><br><span class="line">      <span class="keyword">this</span>.methods.unshift(<span class="string">'HEAD'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保路由的每个中间件都是函数</span></span><br><span class="line">  <span class="keyword">this</span>.stack.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type = (<span class="keyword">typeof</span> fn);</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        methods.toString() + <span class="string">" `"</span> + (<span class="keyword">this</span>.opts.name || path) +<span class="string">"`: `middleware` "</span></span><br><span class="line">        + <span class="string">"must be a function, not `"</span> + type + <span class="string">"`"</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.path = path;</span><br><span class="line">  <span class="comment">// 利用path-to-rege模块生产的路径的正则表达式</span></span><br><span class="line">  <span class="keyword">this</span>.regexp = pathToRegExp(path, <span class="keyword">this</span>.paramNames, <span class="keyword">this</span>.opts);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="router-register-注册路由"><a href="#router-register-注册路由" class="headerlink" title="router.register() 注册路由"></a>router.register() 注册路由</h2><p>从上一篇的代码结构图中可以看出，Router的几个实例方法都直接或间接地调用了register方法，可见，它应该是比较核心的函数, 代码不长，我们一行行看一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.register = <span class="function"><span class="keyword">function</span> (<span class="params">path, methods, middleware, opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全部路由</span></span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.stack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 说明路由的path是支持数组的</span></span><br><span class="line">  <span class="comment">// 如果是数组的话，需要递归调用register来注册路由</span></span><br><span class="line">  <span class="comment">// 因为一个path对应一个路由</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(path)) &#123;</span><br><span class="line">    path.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">      router.register.call(router, p, methods, middleware, opts);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建路由，路由就是Layer的实例</span></span><br><span class="line">  <span class="comment">// methods 是路由处理的http方法</span></span><br><span class="line">  <span class="comment">// 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的</span></span><br><span class="line">  <span class="keyword">var</span> route = <span class="keyword">new</span> Layer(path, methods, middleware, &#123;</span><br><span class="line">    end: opts.end === <span class="literal">false</span> ? opts.end : <span class="literal">true</span>,</span><br><span class="line">    name: opts.name,</span><br><span class="line">    sensitive: opts.sensitive || <span class="keyword">this</span>.opts.sensitive || <span class="literal">false</span>,</span><br><span class="line">    strict: opts.strict || <span class="keyword">this</span>.opts.strict || <span class="literal">false</span>,</span><br><span class="line">    prefix: opts.prefix || <span class="keyword">this</span>.opts.prefix || <span class="string">""</span>,</span><br><span class="line">    ignoreCaptures: opts.ignoreCaptures</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理路径前缀</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.opts.prefix) &#123;</span><br><span class="line">    route.setPrefix(<span class="keyword">this</span>.opts.prefix);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将全局的路由参数添加到每个路由中</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.params).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    route.param(param, <span class="keyword">this</span>.params[param]);</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往路由数组中添加新创建的路由</span></span><br><span class="line">  stack.push(route);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="router-verb-注册路由"><a href="#router-verb-注册路由" class="headerlink" title="router.verb() 注册路由"></a>router.verb() 注册路由</h2><blockquote><p>verb =&gt; get|put|post|patch|delete </p></blockquote><p>这是koa-router提供的直接注册相应http方法的路由，但最终还是会调用register方法如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><p>和下面利用register方法等价：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(<span class="string">'/user'</span>, [<span class="string">'get'</span>], [<span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;...&#125;])</span><br></pre></td></tr></table></figure><p>可以看到直接使用router.verb注册路由会方便很多。来看看代码，你会发现router.js的代码里并没有Router.prototype.get的代码出现，原因是它还依赖了上面提到的methods模块来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的methods就是上面的methods模块提供的数组</span></span><br><span class="line">methods.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Router.prototype[method] = <span class="function"><span class="keyword">function</span> (<span class="params">name, path, middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> middleware;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段代码做了两件事：</span></span><br><span class="line">    <span class="comment">// 1.name 参数是可选的，所以要做一些参数置换的处理</span></span><br><span class="line">    <span class="comment">// 2.将所有路由中间件合并成一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span> || path <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">      middleware = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      middleware = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      path = name;</span><br><span class="line">      name = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用register方法</span></span><br><span class="line">    <span class="keyword">this</span>.register(path, [method], middleware, &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="router-routes-启动路由"><a href="#router-routes-启动路由" class="headerlink" title="router.routes() 启动路由"></a>router.routes() 启动路由</h2><p>这是在koa中配置路由的重要一步：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line">...</span><br><span class="line">app.use(router.routes())</span><br></pre></td></tr></table></figure></p><p>就这样，koa-router就启动了，所以我们也一定会很好奇这个routes函数到底做了什么,但可以肯定router.routes()返回了一个中间件函数。<br>函数体长了一点，简化一下看下整体轮廓：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.routes = Router.prototype.middleware = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch.router = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> dispatch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里形成了一个闭包，在routes函数内部返回了一个dispatch函数作为中间件。<br>接下来看下dispatch函数的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> path = router.opts.routerPath || ctx.routerPath || ctx.path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// router.match函数内部遍历所有路由（this.stach）,</span></span><br><span class="line">    <span class="comment">// 根据路径和请求方法找到对应的路由</span></span><br><span class="line">    <span class="comment">// 返回的matched对象为： </span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      var matched = &#123;</span></span><br><span class="line"><span class="comment">        path: [], // 保存了path匹配的路由数组</span></span><br><span class="line"><span class="comment">        pathAndMethod: [], // 保存了path和methods都匹配的路由数组</span></span><br><span class="line"><span class="comment">        route: false // 是否有对应的路由</span></span><br><span class="line"><span class="comment">      &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> matched = router.match(path, ctx.method);</span><br><span class="line">    <span class="keyword">var</span> layerChain, layer, i;</span><br><span class="line">    <span class="keyword">if</span> (ctx.matched) &#123;</span><br><span class="line">      ctx.matched.push.apply(ctx.matched, matched.path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.matched = matched.path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有对应的路由，则直接进入下一个中间件</span></span><br><span class="line">    <span class="keyword">if</span> (!matched.route) <span class="keyword">return</span> next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到正确的路由的path</span></span><br><span class="line">    <span class="keyword">var</span> mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - <span class="number">1</span>].path;</span><br><span class="line">    ctx._matchedRoute = mostSpecificPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用reduce方法将路由的所有中间件形成一条链</span></span><br><span class="line">    layerChain = matched.pathAndMethod.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">memo, layer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params</span></span><br><span class="line">      <span class="comment">// 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了</span></span><br><span class="line">      memo.push(<span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回路由的参数的key </span></span><br><span class="line">        ctx.captures = layer.captures(path, ctx.captures);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回参数的key和对应的value组成的对象</span></span><br><span class="line">        ctx.params = layer.params(path, ctx.captures, ctx.params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行下一个中间件</span></span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将上面另外加的中间件和已有的路由中间件合并到一起</span></span><br><span class="line">      <span class="comment">// 所以最终 layerChain 将会是一个中间件的数组</span></span><br><span class="line">      <span class="keyword">return</span> memo.concat(layer.stack);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后调用上面提到的 compose 模块提供的方法，返回将 layerChain (中间件的数组) </span></span><br><span class="line">    <span class="comment">// 顺序执行所有中间件的执行函数， 并立即执行。</span></span><br><span class="line">    <span class="keyword">return</span> compose(layerChain)(ctx, next);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="router-allowMethods-处理请求出错逻辑"><a href="#router-allowMethods-处理请求出错逻辑" class="headerlink" title="router.allowMethods() 处理请求出错逻辑"></a>router.allowMethods() 处理请求出错逻辑</h2><p>同样也是koa中配置路由的中一步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)();</span><br><span class="line">...</span><br><span class="line">app.use(router.routes())</span><br><span class="line">app.use(router.allowMethods())</span><br></pre></td></tr></table></figure><p>可以看出，该方法也是闭包内返回了中间件函数。我们将代码简化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.allowedMethods = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> implemented = <span class="keyword">this</span>.methods;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">allowedMethods</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> allowed = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ctx.status || ctx.status === <span class="number">404</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!~implemented.indexOf(ctx.method)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (options.throw) &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.status = <span class="number">501</span>;</span><br><span class="line">            ctx.set(<span class="string">'Allow'</span>, allowedArr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedArr.length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ctx.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">            ctx.status = <span class="number">204</span>;</span><br><span class="line">            ctx.set(<span class="string">'Allow'</span>, allowedArr);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowed[ctx.method]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.throw) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              ctx.status = <span class="number">405</span>;</span><br><span class="line">              ctx.set(<span class="string">'Allow'</span>, allowedArr);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>眼尖的同学可能会看到一些http code ： 404, 501, 204, 405<br>那这个函数其实就是当所有中间件函数执行完了，并且请求出错了进行相应的处理：</p><ul><li>如果请求的方法koa-router不支持并且没有设置throw选项，则返回 501(未实现)</li><li>如果是options请求，则返回 204(无内容)</li><li>如果请求的方法支持但没有设置throw选项，则返回 405(不允许此方法 )</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Node-Koa中间件的洋葱圈模型</title>
      <link href="/2019/01/29/Node-koa-compose%E6%B4%8B%E8%91%B1%E5%9C%88%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/01/29/Node-koa-compose%E6%B4%8B%E8%91%B1%E5%9C%88%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Koa洋葱圈模型"><a href="#Koa洋葱圈模型" class="headerlink" title="Koa洋葱圈模型"></a>Koa洋葱圈模型</h2><p>Koa的中间件选择了洋葱圈模型。中间件结构如下所示：<br><img src="/image/koa_middleware.png" alt=""></p><p>所有的请求经过一个中间件的时候都会执行两次，Koa 的洋葱圈模型可以非常方便的实现后置处理逻辑。</p><h2 id="Koa洋葱圈实例"><a href="#Koa洋葱圈实例" class="headerlink" title="Koa洋葱圈实例"></a>Koa洋葱圈实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建koa实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1-start'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1-end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2-start'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2-end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3-start'</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3-end'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">----&gt; 打印结果：</span><br><span class="line">----&gt; <span class="number">1</span>-start</span><br><span class="line">----&gt; <span class="number">2</span>-start</span><br><span class="line">----&gt; <span class="number">3</span>-start</span><br><span class="line">----&gt; <span class="number">3</span>-end</span><br><span class="line">----&gt; <span class="number">2</span>-end</span><br><span class="line">----&gt; <span class="number">1</span>-end</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>本文重点在于讲解koa中间件的洋葱圈模型。因此，会省略部分无关代码。</p><h4 id="koa-use方法"><a href="#koa-use方法" class="headerlink" title="koa.use方法"></a>koa.use方法</h4><p>use方法，为声明中间件的方法，将中间件存储在middleware数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line"></span><br><span class="line">    debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="koa-listen方法"><a href="#koa-listen方法" class="headerlink" title="koa.listen方法"></a>koa.listen方法</h4><p>listen方法，为启动http-server的简便操作。关键操作还是在callback方法上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="koa-callback方法"><a href="#koa-callback方法" class="headerlink" title="koa.callback方法"></a>koa.callback方法</h4><p>callback方法，返回参数为(req, res)的方法，每次http-server发生回调时，都会调用callback方法。因此，callback方法才是真正的koa执行http-server的源头。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line"><span class="comment">// 实现洋葱圈的关键代码，从use方法可知，我们将中间件push到了middleware数组中。那么compose方法如何将middleware的数组转换为了洋葱圈模型的方法fn。就是实现洋葱圈模型的关键了。</span></span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="koa-compose的compose方法"><a href="#koa-compose的compose方法" class="headerlink" title="koa-compose的compose方法"></a>koa-compose的compose方法</h4><p>compose方法，主要作用是将中间件数组，包装成了洋葱圈模型中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 校验middleware格式，必须为数组，子元素必须为方法</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; context</span></span><br><span class="line"><span class="comment">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">   * @api public</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 正常情况下， index 永远小于 i，除非next()被多次调用。</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="comment">// 如果next参数存在，则next方法在最后调用。</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 递归调用dispatch方法实现从中间件数组到洋葱圈模型中间件的转变。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="koa-handleRequest方法"><a href="#koa-handleRequest方法" class="headerlink" title="koa.handleRequest方法"></a>koa.handleRequest方法</h4><p>handleRequest方法，消费洋葱圈模型中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="comment">// 洋葱圈模型中间件，返回的都是Promise，通过下面代码消费中间件</span></span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://eggjs.org/zh-cn/intro/egg-and-koa.html" target="_blank" rel="noopener">https://eggjs.org/zh-cn/intro/egg-and-koa.html</a><br><a href="https://www.jianshu.com/p/5d0f1d9ef746" target="_blank" rel="noopener">https://www.jianshu.com/p/5d0f1d9ef746</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库-MySql操作大全</title>
      <link href="/2019/01/24/%E6%95%B0%E6%8D%AE%E5%BA%93-MySql%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/01/24/%E6%95%B0%E6%8D%AE%E5%BA%93-MySql%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>详情</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 字节</td><td>有符号:(-128，127) <br>无符号:(0，255)</td><td>极小整数值</td></tr><tr><td>SMALLINT</td><td>2 字节</td><td>有符号:(-32 768，32 767) <br>无符号:(0，65 535)</td><td>小整数值</td></tr><tr><td>MEDIUMINT</td><td>3 字节</td><td>有符号:(-8 388 608，8 388 607) <br>无符号:(0，16 777 215)</td><td>中等整数值</td></tr><tr><td>INT或INTEGER</td><td>4 字节</td><td>有符号:(-2 147 483 648，2 147 483 647) <br>无符号:(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 字节</td><td>有符号:(-9,223,372,036,854,775,808，9 223 372 036 854 775 807) <br>无符号:(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 字节</td><td>有符号:(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) <br>无符号:0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>有符号:(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) <br>无符号:0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>详情</th></tr></thead><tbody><tr><td>DATE</td><td>3字节</td><td>1000-01-01 到 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3字节</td><td>-838:59:59 到 838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1字节</td><td>1901 到 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8字节</td><td>1000-01-01 00:00:00 到 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4字节</td><td>1970-01-01 00:00:00 到 2038年1月19日 凌晨 03:14:07（格林尼治时间）</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>详情</th></tr></thead><tbody><tr><td>CHAR</td><td>0 到 255B</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0 到 64K</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0 到 255B</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0 到 255B</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0 到 64K</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0 到 64K</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0 到 16K</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0 到 16K</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0 到 4GB</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0 到 4GB</td><td>极大文本数据</td></tr></tbody></table><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接到数据库</span></span><br><span class="line">mysql -uroot -ppassword -hlocalhost -P3306;</span><br></pre></td></tr></table></figure><h2 id="切换数据库操作"><a href="#切换数据库操作" class="headerlink" title="切换数据库操作"></a>切换数据库操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| daiyibo_test       |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| pakun              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用数据库</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><h2 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示表单</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| Tables_in_daiyibo_test |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| test_1                 |</span><br><span class="line">| test_2                 |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示表单列信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> tablename;</span><br><span class="line"><span class="keyword">describe</span> tablename;</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| name  | varchar(19) | YES  |     | NULL    |       |</span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| value | varchar(10) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找所有信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete with handy hook                  |</span><br><span class="line">| ANV02   |    1001 | 1 ton anvil    |       9.99 | 1 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| ANV03   |    1001 | 2 ton anvil    |      14.99 | 2 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| DTNTR   |    1003 | Detonator      |      13.00 | Detonator (plunger powered), fuses not included                |</span><br><span class="line">| FB      |    1003 | Bird seed      |      10.00 | Large bag (suitable for road runners)                          |</span><br><span class="line">| FC      |    1003 | Carrots        |       2.50 | Carrots (rabbit hunting season only)                           |</span><br><span class="line">| FU1     |    1002 | Fuses          |       3.42 | 1 dozen, extra long                                            |</span><br><span class="line">| JP1000  |    1005 | JetPack 1000   |      35.00 | JetPack 1000, intended for single <span class="keyword">use</span>                          |</span><br><span class="line">| JP2000  |    <span class="number">1005</span> | JetPack <span class="number">2000</span>   |      <span class="number">55.00</span> | JetPack <span class="number">2000</span>, multi-<span class="keyword">use</span>                                        |</span><br><span class="line">| OL1     |    <span class="number">1002</span> | Oil can        |       <span class="number">8.99</span> | Oil can, red                                                   |</span><br><span class="line">| <span class="keyword">SAFE</span>    |    <span class="number">1003</span> | <span class="keyword">Safe</span>           |      <span class="number">50.00</span> | <span class="keyword">Safe</span> <span class="keyword">with</span> combination <span class="keyword">lock</span>                                     |</span><br><span class="line">| SLING   |    <span class="number">1003</span> | Sling          |       <span class="number">4.49</span> | Sling, one <span class="keyword">size</span> fits all                                       |</span><br><span class="line">| TNT1    |    <span class="number">1003</span> | TNT (<span class="number">1</span> stick)  |       <span class="number">2.50</span> | TNT, red, single stick                                         |</span><br><span class="line">| TNT2    |    <span class="number">1003</span> | TNT (<span class="number">5</span> sticks) |      <span class="number">10.00</span> | TNT, red, pack <span class="keyword">of</span> <span class="number">10</span> sticks                                    |</span><br><span class="line">+<span class="comment">---------+---------+----------------+------------+----------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找指定列信息</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_name <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">| vend_id | prod_name      |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line">|    1001 | .5 ton anvil   |</span><br><span class="line">|    1001 | 1 ton anvil    |</span><br><span class="line">|    1001 | 2 ton anvil    |</span><br><span class="line">|    1003 | Detonator      |</span><br><span class="line">|    1003 | Bird seed      |</span><br><span class="line">|    1003 | Carrots        |</span><br><span class="line">|    1002 | Fuses          |</span><br><span class="line">|    1005 | JetPack 1000   |</span><br><span class="line">|    1005 | JetPack 2000   |</span><br><span class="line">|    1002 | Oil can        |</span><br><span class="line">|    1003 | Safe           |</span><br><span class="line">|    1003 | Sling          |</span><br><span class="line">|    1003 | TNT (1 stick)  |</span><br><span class="line">|    1003 | TNT (5 sticks) |</span><br><span class="line">+<span class="comment">---------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找去重后的指定列信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> vend_id <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| vend_id |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+<span class="comment">---------+</span></span><br></pre></td></tr></table></figure><h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顺序：1      2              3                 4              5                  6              7</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tablename <span class="keyword">where</span> value1 &gt; <span class="number">0</span> <span class="keyword">group</span> <span class="keyword">by</span> value2 <span class="keyword">having</span> value3 &gt; <span class="number">0</span> <span class="keyword">order</span> <span class="keyword">by</span> value4 <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="控制行数"><a href="#控制行数" class="headerlink" title="控制行数"></a>控制行数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找信息后指定检索行数</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">limit</span> <span class="number">5</span>;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| prod_name    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找信息后指定检索的开始行和行数</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">limit</span> <span class="number">1</span>, <span class="number">5</span>;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| prod_name   |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| 1 ton anvil |</span><br><span class="line">| 2 ton anvil |</span><br><span class="line">| Detonator   |</span><br><span class="line">| Bird seed   |</span><br><span class="line">| Carrots     |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找数据后进行排序</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> vend_id, prod_name <span class="keyword">desc</span>, prod_price <span class="keyword">desc</span>;</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br><span class="line">| vend_id | prod_name      | prod_price |</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br><span class="line">|    1001 | 2 ton anvil    |      14.99 |</span><br><span class="line">|    1001 | 1 ton anvil    |       9.99 |</span><br><span class="line">|    1001 | .5 ton anvil   |       5.99 |</span><br><span class="line">|    1002 | Oil can        |       8.99 |</span><br><span class="line">|    1002 | Fuses          |       3.42 |</span><br><span class="line">|    1003 | TNT (5 sticks) |      10.00 |</span><br><span class="line">|    1003 | TNT (1 stick)  |       2.50 |</span><br><span class="line">|    1003 | Sling          |       4.49 |</span><br><span class="line">|    1003 | Safe           |      50.00 |</span><br><span class="line">|    1003 | Detonator      |      13.00 |</span><br><span class="line">|    1003 | Carrots        |       2.50 |</span><br><span class="line">|    1003 | Bird seed      |      10.00 |</span><br><span class="line">|    1005 | JetPack 2000   |      55.00 |</span><br><span class="line">|    1005 | JetPack 1000   |      35.00 |</span><br><span class="line">+<span class="comment">---------+----------------+------------+</span></span><br></pre></td></tr></table></figure><h3 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h3><p>将查找后的数据，进行过滤操作。</p><blockquote><p>过滤操作的操作符如下：<br>=，&lt;&gt;，!=， &lt;， &lt;=， &gt;， &gt;=， between and，is null</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 过滤数据，普通操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name = <span class="string">"fuses"</span>;</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| prod_name | prod_price |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| Fuses     |       3.42 |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，between操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">14</span>;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，is null操作符示例</span></span><br><span class="line"><span class="keyword">select</span> cust_email <span class="keyword">from</span> customers <span class="keyword">where</span> cust_email <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| cust_email |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| NULL       |</span><br><span class="line">| NULL       |</span><br><span class="line">+<span class="comment">------------+</span></span><br></pre></td></tr></table></figure><h3 id="多条件过滤操作符"><a href="#多条件过滤操作符" class="headerlink" title="多条件过滤操作符"></a>多条件过滤操作符</h3><p>将多个条件操作符组合起来，进行多条件过滤操作。</p><ul><li>AND：就是条件“且”的意思</li><li>OR：就是条件“或”的意思</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 过滤数据，or 操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1002</span> <span class="keyword">or</span> vend_id=<span class="number">1003</span>;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Fuses          |       3.42 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Carrots        |       2.50 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，and 操作符示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1002</span> <span class="keyword">and</span> prod_price &gt; <span class="number">4</span>;</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| prod_name | prod_price |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line">| Oil can   |       8.99 |</span><br><span class="line">+<span class="comment">-----------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，or、and 操作符混合使用示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> (vend_id=<span class="number">1002</span> <span class="keyword">or</span> vend_id=<span class="number">1003</span>) <span class="keyword">and</span> prod_price &gt; <span class="number">4</span>;</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+<span class="comment">----------------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，in 表示只要允许其中()中的其中一个条件，操作符使用示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price, vend_id <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1002</span>, <span class="number">1003</span>);</span><br><span class="line">+<span class="comment">----------------+------------+---------+</span></span><br><span class="line">| prod_name      | prod_price | vend_id |</span><br><span class="line">+<span class="comment">----------------+------------+---------+</span></span><br><span class="line">| Fuses          |       3.42 |    1002 |</span><br><span class="line">| Oil can        |       8.99 |    1002 |</span><br><span class="line">| Detonator      |      13.00 |    1003 |</span><br><span class="line">| Bird seed      |      10.00 |    1003 |</span><br><span class="line">| Carrots        |       2.50 |    1003 |</span><br><span class="line">| Safe           |      50.00 |    1003 |</span><br><span class="line">| Sling          |       4.49 |    1003 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |    1003 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |    1003 |</span><br><span class="line">+<span class="comment">----------------+------------+---------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤数据，not 表示对前面操作取反，使用示例</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price, vend_id <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1002</span>, <span class="number">1003</span>);</span><br><span class="line">+<span class="comment">--------------+------------+---------+</span></span><br><span class="line">| prod_name    | prod_price | vend_id |</span><br><span class="line">+<span class="comment">--------------+------------+---------+</span></span><br><span class="line">| .5 ton anvil |       5.99 |    1001 |</span><br><span class="line">| 1 ton anvil  |       9.99 |    1001 |</span><br><span class="line">| 2 ton anvil  |      14.99 |    1001 |</span><br><span class="line">| JetPack 1000 |      35.00 |    1005 |</span><br><span class="line">| JetPack 2000 |      55.00 |    1005 |</span><br><span class="line">+<span class="comment">--------------+------------+---------+</span></span><br></pre></td></tr></table></figure><h3 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h3><p>通配符过滤操作，有点类似于模糊过滤操作。下面主要介绍%和_两个操作符。</p><ul><li>“%” 操作符，表示匹配出现任何次数的任意字符。</li><li>“_” 操作符，表示匹配任何出现的单个字符。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- “%” 操作符使用介绍</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">"%anvil"</span>;</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| prod_id | prod_name    |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line">| ANV01   | .5 ton anvil |</span><br><span class="line">| ANV02   | 1 ton anvil  |</span><br><span class="line">| ANV03   | 2 ton anvil  |</span><br><span class="line">+<span class="comment">---------+--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- “_” 操作符使用介绍</span></span><br><span class="line"><span class="keyword">select</span> cust_contact, cust_id <span class="keyword">from</span> customers <span class="keyword">where</span> cust_contact <span class="keyword">like</span> <span class="string">"___am"</span>;</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br><span class="line">| cust_contact | cust_id |</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br><span class="line">| Y Sam        |   10004 |</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式过滤"><a href="#正则表达式过滤" class="headerlink" title="正则表达式过滤"></a>正则表达式过滤</h3><p>mysql支持正则表达式。若要使用正则表达式，则用regexp作为操作符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> customers <span class="keyword">where</span> cust_address regexp <span class="string">"^2."</span>;</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+</span></span><br><span class="line">| cust_id | cust_name   | cust_address   | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email      |</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+</span></span><br><span class="line">|   10001 | Coyote Inc. | 200 Maple Lane | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com |</span><br><span class="line">+<span class="comment">---------+-------------+----------------+-----------+------------+----------+--------------+--------------+-----------------+</span></span><br></pre></td></tr></table></figure><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>可以通过concat方法对字段内容进行拼接操作。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>) <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| concat(vend_name, '(', vend_country, ')') |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br><span class="line">| ACME(USA)                                 |</span><br><span class="line">| Anvils R Us(USA)                          |</span><br><span class="line">| Furball Inc.(USA)                         |</span><br><span class="line">| Jet <span class="keyword">Set</span>(England)                          |</span><br><span class="line">| Jouets Et Ours(France)                    |</span><br><span class="line">| LT Supplies(USA)                          |</span><br><span class="line">+<span class="comment">-------------------------------------------+</span></span><br></pre></td></tr></table></figure></p><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>别名是一个字段或值的替代名。通过as关键字赋予别名。如果使用了别名，相当于可以对字段进行重新命名。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>) <span class="keyword">as</span> vend_title <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| vend_title             |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| ACME(USA)              |</span><br><span class="line">| Anvils R Us(USA)       |</span><br><span class="line">| Furball Inc.(USA)      |</span><br><span class="line">| Jet <span class="keyword">Set</span>(England)       |</span><br><span class="line">| Jouets Et Ours(France) |</span><br><span class="line">| LT Supplies(USA)       |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br></pre></td></tr></table></figure></p><h3 id="使用算数计算"><a href="#使用算数计算" class="headerlink" title="使用算数计算"></a>使用算数计算</h3><p>可以通过算数运算符对字段进行运算操作。支持的操作符有+，-，*，/。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, quantity, item_price, quantity*item_price <span class="keyword">as</span> expanded_price <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num = <span class="number">20005</span>;</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br><span class="line">| ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">| ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">| TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">+<span class="comment">---------+----------+------------+----------------+</span></span><br></pre></td></tr></table></figure></p><h3 id="文本处理内置函数"><a href="#文本处理内置函数" class="headerlink" title="文本处理内置函数"></a>文本处理内置函数</h3><ul><li>Left()： 返回串左边的字符</li><li>Length()：返回串的长度</li><li>Locate()：找出串的一个子串</li><li>Lower()：将串转换为小写</li><li>LTrim()：去掉串左边的空格</li><li>Right()：返回串右边的字符</li><li>RTrim()：去掉串右边的空格</li><li>Soundex()：返回串的SOUNDEX值</li><li>SubString()：返回子串的字符</li><li>Upper()：将串转换为大写</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">upper</span>(prod_name) <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| upper(prod_name) |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| .5 TON ANVIL     |</span><br><span class="line">| 1 TON ANVIL      |</span><br><span class="line">| 2 TON ANVIL      |</span><br><span class="line">| DETONATOR        |</span><br><span class="line">| BIRD SEED        |</span><br><span class="line">| CARROTS          |</span><br><span class="line">| FUSES            |</span><br><span class="line">| JETPACK 1000     |</span><br><span class="line">| JETPACK 2000     |</span><br><span class="line">| OIL CAN          |</span><br><span class="line">| SAFE             |</span><br><span class="line">| SLING            |</span><br><span class="line">| TNT (1 STICK)    |</span><br><span class="line">| TNT (5 STICKS)   |</span><br><span class="line">+<span class="comment">------------------+</span></span><br></pre></td></tr></table></figure><h3 id="时间处理内置函数"><a href="#时间处理内置函数" class="headerlink" title="时间处理内置函数"></a>时间处理内置函数</h3><ul><li>AddDate()：增加一个日期(天、周等)</li><li>AddTime()：增加一个时间(时、分等)</li><li>CurDate()：返回当前日期</li><li>CurTime()：返回当前时间</li><li>Date()：返回日期时间的日期部分 </li><li>DateDiff()：计算两个日期之差</li><li>Date_Add()：高度灵活的日期运算函数</li><li>Date_Format()：返回一个格式化的日期或时间串</li><li>Day()：返回一个日期的天数部分</li><li>DayOfWeek()：对于一个日期，返回对应的星期几</li><li>Hour()：返回一个时间的小时部分 </li><li>Minute()：返回一个时间的分钟部分</li><li>Month()：返回一个日期的月份部分</li><li>Now()：返回当前日期和时间</li><li>Second()：返回一个时间的秒部分</li><li>Time()：返回一个日期时间的时间部分</li><li>Year()：返回一个日期的年份部分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- month显示操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(order_date) <span class="keyword">as</span> <span class="keyword">month</span> <span class="keyword">from</span> orders;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| month |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     9 |</span><br><span class="line">|     9 |</span><br><span class="line">|     9 |</span><br><span class="line">|    10 |</span><br><span class="line">|    10 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- month比较操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(order_date) <span class="keyword">as</span> <span class="keyword">month</span> <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="keyword">month</span>(order_date)&gt;<span class="number">9</span>;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| month |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|    10 |</span><br><span class="line">|    10 |</span><br><span class="line">+<span class="comment">-------+</span></span><br></pre></td></tr></table></figure><h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><ul><li>Abs()：返回一个数的绝对值</li><li>Cos()：返回一个角度的余弦</li><li>Exp()：返回一个数的指数值 </li><li>Mod()：返回除操作的余数</li><li>Pi()：返回圆周率</li><li>Rand()：返回一个随机数</li><li>Sin()：返回一个角度的正弦</li><li>Sqrt()：返回一个数的平方根</li><li>Tan()：返回一个角度的正切</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">abs</span>(<span class="number">-1</span>);</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| abs(-1) |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">|       1 |</span><br><span class="line">+<span class="comment">---------+</span></span><br></pre></td></tr></table></figure><h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><ul><li>AVG()：返回某列的平均值 </li><li>COUNT()：返回某列的行数</li><li>MAX()：返回某列的最大值</li><li>MIN()：返回某列的最小值</li><li>SUM()：返回某列值之和</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 汇总操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(prod_price) <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| avg(prod_price) |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">|       16.133571 |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复杂汇总操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> num_items, <span class="keyword">min</span>(prod_price) <span class="keyword">as</span> price_min, <span class="keyword">max</span>(prod_price) <span class="keyword">as</span> price_max, <span class="keyword">avg</span>(prod_price) <span class="keyword">as</span> price_avg <span class="keyword">from</span> products;</span><br><span class="line">+<span class="comment">-----------+-----------+-----------+-----------+</span></span><br><span class="line">| num_items | price_min | price_max | price_avg |</span><br><span class="line">+<span class="comment">-----------+-----------+-----------+-----------+</span></span><br><span class="line">|        14 |      2.50 |     55.00 | 16.133571 |</span><br><span class="line">+<span class="comment">-----------+-----------+-----------+-----------+</span></span><br></pre></td></tr></table></figure><h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p>MySQL允许对数据进行分组操作，分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。</p><ul><li>“group by” 操作符，提供了对数据进行分组的能力。</li><li>“having” 操作符，提供了对分组数据进行过滤的能力。用法和“where”操作符无异，只是“where”操作对象为所有数据，“having”操作对象为分组后的数据。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分组查找数据</span></span><br><span class="line"><span class="keyword">select</span> vend_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|    1001 |         3 |</span><br><span class="line">|    1002 |         2 |</span><br><span class="line">|    1003 |         7 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line"><span class="comment">-- 对分组查找的数据进行过滤操作</span></span><br><span class="line"><span class="keyword">select</span> vend_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;=<span class="number">2</span>;</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br><span class="line">|    1001 |         3 |</span><br><span class="line">|    1002 |         2 |</span><br><span class="line">|    1003 |         7 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+<span class="comment">---------+-----------+</span></span><br></pre></td></tr></table></figure><h3 id="子句查询"><a href="#子句查询" class="headerlink" title="子句查询"></a>子句查询</h3><p>mysql支持子查询，就是将嵌套使用select操作。在复杂的数据库操作中，是非常有用的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 利用子查询进行过滤</span></span><br><span class="line"><span class="keyword">select</span> cust_name,  cust_contact <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id=<span class="string">'TNT2'</span>));</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+<span class="comment">----------------+--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 作为计算字段利用子查询</span></span><br><span class="line"><span class="keyword">select</span> cust_name, cust_state, (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> orders <span class="keyword">where</span> orders.cust_id=customers.cust_id) <span class="keyword">as</span> order_count</span><br><span class="line">    <span class="keyword">from</span> customers <span class="keyword">order</span> <span class="keyword">by</span> cust_name;</span><br><span class="line">+<span class="comment">----------------+------------+-------------+</span></span><br><span class="line">| cust_name      | cust_state | order_count |</span><br><span class="line">+<span class="comment">----------------+------------+-------------+</span></span><br><span class="line">| Coyote Inc.    | MI         |           2 |</span><br><span class="line">| E Fudd         | IL         |           1 |</span><br><span class="line">| Mouse House    | OH         |           0 |</span><br><span class="line">| Wascals        | IN         |           1 |</span><br><span class="line">| Yosemite Place | AZ         |           1 |</span><br><span class="line">+<span class="comment">----------------+------------+-------------+</span></span><br></pre></td></tr></table></figure><h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>关系型数据库，会将数据组合成多个关系表的形式。此时，如果想要一次性查找多个表中的数据，就需要用到联结。联结操作有如下几种形式：</p><ul><li>内部联结：此联结操作只展示相关联的行。将两个表之间的数据，通过联结操作将关联的数据过滤出来，并展示出来。</li><li>外部联结：此联结操作除了展示相关联的行以外，还会展示没有关联的那些行。将两个表之间的数据，通过联结操作将不相关的数据排除在外，并展示保留下来的数据。</li><li>多表联结：算是内部联结的一种，但他指的是多个表之间的联结操作。</li><li>自联结：算是内部联结的一种，但他指的是单个表自己对自己的联结操作。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内部联结，下面两个sql语句等价</span></span><br><span class="line"><span class="keyword">select</span> customers.cust_id, orders.* <span class="keyword">from</span> customers <span class="keyword">inner</span> <span class="keyword">join</span> orders <span class="keyword">on</span> customers.cust_id=orders.cust_id;</span><br><span class="line"><span class="keyword">select</span> customers.cust_id, orders.* <span class="keyword">from</span> customers, orders <span class="keyword">where</span> customers.cust_id=orders.cust_id;</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">| cust_id | order_num | order_date          | cust_id |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">|   10001 |     20005 | 2005-09-01 00:00:00 |   10001 |</span><br><span class="line">|   10003 |     20006 | 2005-09-12 00:00:00 |   10003 |</span><br><span class="line">|   10004 |     20007 | 2005-09-30 00:00:00 |   10004 |</span><br><span class="line">|   10005 |     20008 | 2005-10-03 00:00:00 |   10005 |</span><br><span class="line">|   10001 |     20009 | 2005-10-08 00:00:00 |   10001 |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外部级联</span></span><br><span class="line"><span class="keyword">select</span> customers.cust_id, orders.* <span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> orders <span class="keyword">on</span> customers.cust_id=orders.cust_id;</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">| cust_id | order_num | order_date          | cust_id |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line">|   10001 |     20005 | 2005-09-01 00:00:00 |   10001 |</span><br><span class="line">|   10001 |     20009 | 2005-10-08 00:00:00 |   10001 |</span><br><span class="line">|   10002 |      NULL | NULL                |    NULL |</span><br><span class="line">|   10003 |     20006 | 2005-09-12 00:00:00 |   10003 |</span><br><span class="line">|   10004 |     20007 | 2005-09-30 00:00:00 |   10004 |</span><br><span class="line">|   10005 |     20008 | 2005-10-03 00:00:00 |   10005 |</span><br><span class="line">+<span class="comment">---------+-----------+---------------------+---------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多表联结</span></span><br><span class="line"><span class="keyword">select</span> prod_name, vend_name, prod_price, quantity <span class="keyword">from</span> orderitems, products, vendors <span class="keyword">where</span> products.vend_id = vendors.vend_id <span class="keyword">and</span> orderitems.prod_id=products.prod_id <span class="keyword">and</span> order_num=<span class="number">20005</span>;</span><br><span class="line">+<span class="comment">----------------+-------------+------------+----------+</span></span><br><span class="line">| prod_name      | vend_name   | prod_price | quantity |</span><br><span class="line">+<span class="comment">----------------+-------------+------------+----------+</span></span><br><span class="line">| .5 ton anvil   | Anvils R Us |       5.99 |       10 |</span><br><span class="line">| 1 ton anvil    | Anvils R Us |       9.99 |        3 |</span><br><span class="line">| TNT (5 sticks) | ACME        |      10.00 |        5 |</span><br><span class="line">| Bird seed      | ACME        |      10.00 |        1 |</span><br><span class="line">+<span class="comment">----------------+-------------+------------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自联结</span></span><br><span class="line"><span class="keyword">select</span> p1.* <span class="keyword">from</span> products <span class="keyword">as</span> p1, products <span class="keyword">as</span> p2 <span class="keyword">where</span> p1.vend_id=p2.vend_id <span class="keyword">and</span> p1.prod_id=<span class="string">'DTNTR'</span>;</span><br><span class="line">+<span class="comment">---------+---------+-----------+------------+-------------------------------------------------+</span></span><br><span class="line">| prod_id | vend_id | prod_name | prod_price | prod_desc                                       |</span><br><span class="line">+<span class="comment">---------+---------+-----------+------------+-------------------------------------------------+</span></span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">| DTNTR   |    1003 | Detonator |      13.00 | Detonator (plunger powered), fuses not included |</span><br><span class="line">+<span class="comment">---------+---------+-----------+------------+-------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>组合查询通过union或union all关键字将多个查询条件组合起来。使用组合查询的规则如下：</p><ul><li>每条select语句之间，必须通过union隔离</li><li>每条select语句，必须包含相同的列数</li><li>union all，表示合并多条select语句的查询结果，但不对重复数据做额外处理</li><li>union，表示合并多条select语句的查询结果，并对重复数据去重</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- union组合操作</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price &lt;= <span class="number">5</span> <span class="keyword">union</span> <span class="keyword">select</span> vend_id,prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1001</span> <span class="keyword">or</span> vend_id=<span class="number">1002</span> <span class="keyword">order</span> <span class="keyword">by</span> vend_id;</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- union all 组合操作</span></span><br><span class="line"><span class="keyword">select</span> vend_id, prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price &lt;= <span class="number">5</span> <span class="keyword">union</span> all <span class="keyword">select</span> vend_id,prod_id, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1001</span> <span class="keyword">or</span> vend_id=<span class="number">1002</span> <span class="keyword">order</span> <span class="keyword">by</span> vend_id;</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">+<span class="comment">---------+---------+------------+</span></span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>插入数据，分为插入完整的行，插入部分的行，插入多行，插入查询结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入完整行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers <span class="keyword">values</span>(<span class="literal">null</span>, <span class="string">'Pep E. Lapew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90046'</span>, <span class="string">'USA'</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入部分行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) <span class="keyword">values</span>(<span class="string">'Pep E. LaPew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90090'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) <span class="keyword">values</span>(<span class="string">'Pep E. LaPew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90090'</span>), (<span class="string">'Pep E. LaPew'</span>, <span class="string">'100 Main Street'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'CA'</span>, <span class="string">'90091'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入查询结果</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers_new(cust_id, cust_name, cust_address) <span class="keyword">select</span> customers.cust_id, customers.cust_name, customers.cust_address <span class="keyword">from</span> customers;</span><br></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>更新数据操作，很简单，直接上代码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新单行数据</span></span><br><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_email=<span class="string">'elmer@fudd.com'</span> <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新多行数据</span></span><br><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_email=<span class="string">'elmer@fudd.com'</span>, cust_name=<span class="string">'The Fudds'</span> <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除数据操作，很简单，直接上代码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>使用create table来创建customers表单。在创建表单时，可以使用null，primary key，auto_increment，default关键字来对字段进行修饰操作。</p><ul><li>null：指定列是否允许null值，not null表示该列不允许存在null值。</li><li>primary key：指定表单的主键。</li><li>foreign key：指定外键。</li><li>auto_increment：指定主键是否自增。</li><li>default：指定字段的默认值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers (</span><br><span class="line">    cust_id      <span class="built_in">int</span>      <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    cust_name    <span class="built_in">char</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cust_address <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_city    <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_state   <span class="built_in">char</span>(<span class="number">5</span>)  <span class="literal">null</span>,</span><br><span class="line">    cust_zip     <span class="built_in">char</span>(<span class="number">10</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_country <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_contact <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    cust_email   <span class="built_in">char</span>(<span class="number">50</span>) <span class="literal">null</span>,</span><br><span class="line">    test_fk      <span class="built_in">int</span>      <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (cust_id)</span><br><span class="line">    foreign <span class="keyword">key</span> (test_fk) <span class="keyword">REFERENCES</span> TestTable(test_fk)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表操作</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> customers;</span><br></pre></td></tr></table></figure><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重命名表操作</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> customers2 <span class="keyword">to</span> customers;</span><br></pre></td></tr></table></figure><h4 id="更新字段"><a href="#更新字段" class="headerlink" title="更新字段"></a>更新字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">add</span> new_id <span class="built_in">INT</span>;</span><br><span class="line"><span class="comment">-- 删除字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">drop</span> new_id;</span><br><span class="line"><span class="comment">-- 修改字段（将类型调整为char(10)）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">modify</span> new_id <span class="built_in">char</span>(<span class="number">10</span>) </span><br><span class="line"><span class="comment">-- 修改字段（将字段名new_id改为new_id_2，将类型调整为INT）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> customers <span class="keyword">change</span> new_id new_id_2 <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure><h4 id="设置外键"><a href="#设置外键" class="headerlink" title="设置外键"></a>设置外键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders <span class="keyword">add</span> foreign <span class="keyword">key</span>(fk_id) <span class="keyword">references</span> TestTable(primary_id);</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders <span class="keyword">drop</span> foreign <span class="keyword">key</span> fk_id;</span><br></pre></td></tr></table></figure><h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。关键字介绍：</p><ul><li>begin：显式地开启一个事务</li><li>commit：也可以使用commit work，不过二者是等价的。commit会提交事务，并使已对数据库进行的所有修改成为永久性的</li><li>rollback：有可以使用rollback work，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改</li><li>savepoint identifier：savepoint允许在事务中创建一个保存点，一个事务中可以有多个savepoint</li><li>rollback to identifier：把事务回滚到标记点</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> runoob_transaction_test( <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">5</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_transaction_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- commit事务示例</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> runoob_transaction_test <span class="keyword">value</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> runoob_transaction_test <span class="keyword">value</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_transaction_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rollback事务示例</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> runoob_transaction_test <span class="keyword">values</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_transaction_test;</span><br></pre></td></tr></table></figure><h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><p><a href="http://www.forta.com/books/0672327120/mysql_scripts.zip" target="_blank" rel="noopener">Mysql必知必会-实现数据</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络-Https的理解</title>
      <link href="/2019/01/20/%E7%BD%91%E7%BB%9C-Https%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/01/20/%E7%BD%91%E7%BB%9C-Https%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Http有啥问题？"><a href="#Http有啥问题？" class="headerlink" title="Http有啥问题？"></a>Http有啥问题？</h2><blockquote><ul><li>窃听风险（eavesdropping）：第三方可以获知通信内容</li><li>篡改风险（tampering）：第三方可以修改通信内容</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信</li></ul></blockquote><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><blockquote><ul><li>所有信息都是加密传播，第三方无法窃听</li><li>具有校验机制，一旦被篡改，通信双方会立刻发现</li><li>配备身份证书，防止身份被冒充</li></ul></blockquote><h2 id="Https是个啥？"><a href="#Https是个啥？" class="headerlink" title="Https是个啥？"></a>Https是个啥？</h2><p>为了更好地理解 HTTPS，我们来观察一下 HTTPS 的通信步骤。</p><p><img src="/image/network_https.png" alt="ssl握手图"></p><h4 id="客户端发出请求（ClientHello）"><a href="#客户端发出请求（ClientHello）" class="headerlink" title="客户端发出请求（ClientHello）"></a>客户端发出请求（ClientHello）</h4><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。<br>在这一步，客户端主要向服务器提供以下信息。</p><blockquote><p>（1） 支持的协议版本，比如TLS 1.0版。<br>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。<br>（3） 支持的加密方法，比如RSA公钥加密。<br>（4） 支持的压缩方法。</p></blockquote><h4 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h4><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p><blockquote><p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。<br>（3） 确认使用的加密方法，比如RSA公钥加密。<br>（4） 服务器证书。</p></blockquote><h4 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h4><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><blockquote><p>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>至于为什么一定要用3个随机数，来生成”会话密钥”，dog250解释得很好(<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">参考出处</a>)：</p><blockquote><p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，3个随机数通过一个密钥导出器最终导出一个对称密钥。</p><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote><h4 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h4><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><blockquote><p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><h2 id="Https内容防篡改"><a href="#Https内容防篡改" class="headerlink" title="Https内容防篡改"></a>Https内容防篡改</h2><p>HTTPS可以防止中间人的篡改。加密算法的安全性主要分为两种，一种是保护信息不被泄露的能力（CPA安全），一种是保护信息不被篡改的能力（CCA安全）。<br>单纯的加密算法是不具备防止篡改的能力的。比如AES-CBC加密的某一个消息“早上10点20分发起进攻”，我不需要知道这条消息的具体内容是什么，却可以通过某种手段随意把它改成我指定的时间，比如“早上11点10分发起进攻”。只有结合消息验证机制的加密算法才能防止篡改。比如AES-CBC with HMAC-SHA256、AES-GCM、ChaCha20-Poly1305等等。(<a href="https://www.zhihu.com/question/65464646" target="_blank" rel="noopener">参考出处</a>)</p><h2 id="Https的延迟"><a href="#Https的延迟" class="headerlink" title="Https的延迟"></a>Https的延迟</h2><p>通过下面实验，可以看到ssl握手时间是tcp握手的3倍。(<a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="noopener">参考出处</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -w "TCP handshake: %&#123;time_connect&#125;, SSL handshake: %&#123;time_appconnect&#125;\n" -so /dev/null https://www.alipay.com</span><br><span class="line"></span><br><span class="line">TCP handshake: 0.022, SSL handshake: 0.064</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html</a><br><a href="https://blog.csdn.net/AloneSword/article/details/47059945" target="_blank" rel="noopener">https://blog.csdn.net/AloneSword/article/details/47059945</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中类型转换的整理</title>
      <link href="/2019/01/18/Node-JS%E4%B8%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%95%B4%E7%90%86/"/>
      <url>/2019/01/18/Node-JS%E4%B8%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>JS中取值类型非常灵活，在进行算数运算符或比较运算符操作时，常常会进行类型转换操作。最近对类型转换做了系统的梳理。原始值之间的转换规则如下：<br><img src="/image/js_type.png" alt="原始值类型转换"></p><h3 id="对象转换操作"><a href="#对象转换操作" class="headerlink" title="对象转换操作"></a>对象转换操作</h3><p>对象转换，相比于原始值相互转换要稍微复杂点。在讲解对象转换前，先说两个对象内置的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认情况下，toString() -&gt; "[object Object]"</span></span><br><span class="line"><span class="comment"> * 许多类都继承了toString()方法，例如数组：</span></span><br><span class="line"><span class="comment"> * [1].toString() -&gt; "1"</span></span><br><span class="line"><span class="comment"> * ['1'].toString() -&gt; "1"</span></span><br><span class="line"><span class="comment"> * [1, 2].toString() -&gt; "1, 2"</span></span><br><span class="line"><span class="comment"> * @return 返回一个反映这个对象的字符串</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">toString() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认情况下， valueOf() -&gt; 对象本身。因为对象是复合值，而且大多数对象无法真正的表示一个原始值</span></span><br><span class="line"><span class="comment"> * 许多类都继承了valueOf()方法，例如日期类：</span></span><br><span class="line"><span class="comment"> * (new Date()).valueOf() -&gt; 1548296513124</span></span><br><span class="line"><span class="comment"> * @return 如果存在任意原始值，它就默认将对象转换为表示它的原始值。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">valueOf() &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="对象到字符串的转换流程"><a href="#对象到字符串的转换流程" class="headerlink" title="对象到字符串的转换流程"></a>对象到字符串的转换流程</h4><ul><li>如果对象具有toString()方法，则调用这个方法。如果他返回一个原始值，JS将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。</li><li>如果对象没有toString()方法，或者这个方法并不返回这个原始值，那么JS会调用valueOf()方法。如果存在这个方法，则JS调用他。如果返回值是原始值，JS将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。</li><li>否则，JS无法从toString()或者valueOf()获取一个原始值，因此这时他将抛出一个类型错误异常。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象转字符串伪代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj2String</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">    temp = obj.toString();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">    temp = obj.valueOf();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'转化失败'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象到数值的转换流程"><a href="#对象到数值的转换流程" class="headerlink" title="对象到数值的转换流程"></a>对象到数值的转换流程</h4><ul><li>如果对象具有valueOf()方法，或者返回一个原始值，则JS将这个原始值转换为数字，并返回这个数字。</li><li>否则，如果对象具有toString()方法，后者返回一个原始值，则JS将其转换并返回</li><li>否则，JS抛出一个类型错误异常</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象转数值伪代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj2Number</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">    temp = obj.valueOf();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">    temp = obj.toString();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> temp === 原始值) &#123;</span><br><span class="line">      <span class="keyword">return</span> 原始值转化规则(temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'转化失败'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象到原始值的转换流程"><a href="#对象到原始值的转换流程" class="headerlink" title="对象到原始值的转换流程"></a>对象到原始值的转换流程</h4><p>在使用“+”，“==”，“!=”和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符。因为这些运算符不太清楚要将对象转成String还是Number。将对象转成原始值时，会首先尝试调用valueOf()，然后调用toString()。唯一例外的是Date类型，Date类型会首先尝试调用toString()，然后调用valueOf()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象转原始值伪代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj2OriginalValue</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj == <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.valueOf();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.valueOf) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.valueOf();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!!obj.toString) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="“-”-操作符功能简介"><a href="#“-”-操作符功能简介" class="headerlink" title="“+” 操作符功能简介"></a>“+” 操作符功能简介</h3><p>操作符的运算优先级为：string &gt; 其他类型</p><ul><li>存在string类型时，其他类型都会转换成string类型，然后进行字符串连接</li><li>不存在string类型时，会尝试将其他类型转换成数字，然后进行数字相加操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在string类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">undefined</span>);  <span class="comment">//str+undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">null</span>);  <span class="comment">//str+null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">false</span>);  <span class="comment">//str+false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="literal">true</span>);  <span class="comment">//str+true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str+'</span> + <span class="number">123</span>);  <span class="comment">//str+123</span></span><br><span class="line"><span class="comment">// 不存在string类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="number">123</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="literal">null</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="literal">false</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="literal">true</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> + <span class="literal">null</span>);  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> + <span class="literal">false</span>);  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> + <span class="literal">true</span>);  <span class="comment">//124</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> + <span class="literal">true</span>);  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> + <span class="literal">false</span>);  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="literal">false</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="“-”-操作符功能简介-1"><a href="#“-”-操作符功能简介-1" class="headerlink" title="“-” 操作符功能简介"></a>“-” 操作符功能简介</h3><p>基本类型进行“—”操作符运算时，将基本类型转换为数字，然后进行数字相减操作。“*”操作符和“/”操作符类似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">null</span>);  <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">undefined</span>);  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">false</span>); <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="literal">true</span>);  <span class="comment">//122</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> - <span class="string">'1'</span>);  <span class="comment">//122</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中多进程的应用</title>
      <link href="/2019/01/13/Node-JS%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/01/13/Node-JS%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-RESTful接口设计</title>
      <link href="/2019/01/07/%E7%BD%91%E7%BB%9C-RESTful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/01/07/%E7%BD%91%E7%BB%9C-RESTful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Http-Methods描述"><a href="#Http-Methods描述" class="headerlink" title="Http Methods描述"></a>Http Methods描述</h2><table><thead><tr><th>HTTP Methods</th><th>操作方式</th></tr></thead><tbody><tr><td>POST</td><td>创建数据 Create</td></tr><tr><td>GET</td><td>读取数据 Read</td></tr><tr><td>PUT</td><td>修改数据 Update 整条修改修改除ID外的所有属性</td></tr><tr><td>PATCH</td><td>修改数据 Update 部分修改 修改一条记录的部分属性</td></tr><tr><td>DELETE</td><td>删除数据 Delete</td></tr></tbody></table><h2 id="RESTful是什么？"><a href="#RESTful是什么？" class="headerlink" title="RESTful是什么？"></a>RESTful是什么？</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法-红黑树的思考</title>
      <link href="/2019/01/03/%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/01/03/%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>红黑树，一种自平衡的 二叉查找树，但在每个节点上有一个额外的存储位表示节点的颜色，可以是Red或者Black。这些颜色位用来确保红黑树在插入和删除操作后仍能近乎平衡。</p><h2 id="红黑树的应用场景"><a href="#红黑树的应用场景" class="headerlink" title="红黑树的应用场景"></a>红黑树的应用场景</h2><p>到此，我们可能已经对红黑树有了一点初步的认识了，但是我们却不知道为什么要有红黑树，红黑树是为了解决什么问题被提出来的呢？<br>我们知道，二叉查找树在大多数情况下查找和插入在效率上是没有问题的，但是在最坏的情况下效率比较低，但是平衡二叉树能够保证在最坏的情况下也能达到lgN，要实现这一目标，我们就要保证在插入完成后始终保持平衡状态。在一棵具有N个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以就出现一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。而我们所讲的红黑树就属于此新的数据结构之一，除此之外还有B树等数据结构。</p><h2 id="红黑树与其他结构对比"><a href="#红黑树与其他结构对比" class="headerlink" title="红黑树与其他结构对比"></a>红黑树与其他结构对比</h2><p><strong>红黑树 vs 普通二叉树</strong><br>红黑树再插入或者删除节点后，会对操作后的树进行重新平衡操作。使得最坏情况下，对节点的查询效率还是高。而普通二叉树，有可能会引起树倾斜的问题，这时在查找树中节点，效率可能变成了O(1)。<br><strong>红黑树 vs AVL平衡二叉树</strong><br>AVL树需要严格维护二叉树平衡。而红黑树通过节点颜色来维护一个相对平衡的二叉树。</p><ul><li>在搜索上，AVL效率为log(O)，而红黑树平均效率为log(O)，最大情况下是2log(O)。</li><li>在插入上，红黑树和AVL树，节点旋转次数都是O(1)。</li><li>在删除上，红黑树在删除时节点旋转次数是O(1)，AVL树在删除时节点旋转次数是O(logn)。</li></ul><p>红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。<br>RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p><h2 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h2><p>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><h2 id="关于时间复杂度的证明"><a href="#关于时间复杂度的证明" class="headerlink" title="关于时间复杂度的证明"></a>关于时间复杂度的证明</h2><blockquote><p>红黑树的时间复杂度为: O(lgn)<br>下面通过“数学归纳法”对红黑树的时间复杂度进行证明。<br>定理：一棵含有n个节点的红黑树的高度至多为2log(n+1).<br>证明：<br>“一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的逆否命题是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。<br>我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。<br>从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x’s black height)，记为bh(x)。关于bh(x)有两点需要说明：<br>第1点：根据红黑树的”特性(5) ，即从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点”可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。这也就意味着，bh(x)的值是唯一的！<br>第2点：根据红黑色的”特性(4)，即如果一个节点是红色的，则它的子节点必须是黑色的”可知，从节点x出发达到叶节点”所经历的黑节点数目”&gt;= “所经历的红节点的数目”。假设x是根节点，则可以得出结论”bh(x) &gt;= h/2”。进而，我们只需证明 “高度为h的红黑树，它的包含的黑节点个数至少为 2bh(x)-1个”即可。<br>到这里，我们将需要证明的定理已经由<br>“一棵含有n个节点的红黑树的高度至多为2log(n+1)”<br>转变成只需要证明<br>“高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。<br>下面通过”数学归纳法”开始论证高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。<br>(01) 当树的高度h=0时，<br>内节点个数是0，bh(x) 为0，2bh(x)-1 也为 0。显然，原命题成立。<br>(02) 当h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2bh(x)-1-1。这个是根据(01)推断出来的！<br>下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2bh(x)-1”。<br>当树的高度为 h 时，<br>对于节点x(x为根节点)，其黑高度为bh(x)。<br>对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br>根据(02)的已知条件，我们已知 “x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2bh(x)-1-1 个”；<br>所以，节点x所包含的节点至少为 ( 2bh(x)-1-1 ) + ( 2bh(x)-1-1 ) + 1 = 2^bh(x)-1。即节点x所包含的节点至少为 2bh(x)-1。<br>因此，原命题成立。<br>由(01)、(02)得出，”高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)-1个”。<br>因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。</p></blockquote><h2 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h2><p>时间复杂度： O(1)<br>左旋和右旋是相互对称的<br>图示：<br><img src="/image/base_rbtree_1.png" alt=""></p><h2 id="红黑树插入节点后矫正情况"><a href="#红黑树插入节点后矫正情况" class="headerlink" title="红黑树插入节点后矫正情况"></a>红黑树插入节点后矫正情况</h2><p>矫正的时间复杂度为O(1)。在单次矫正情况中，旋转从不超过2次，因为只要执行了情况2和情况3，while循环就结束了。插件节点，插入的是红色节点。并且是插入到树的叶节点上的。因此只会破坏（“如果一个节点是红色的，则它的子节点必须是黑色的”）特性。处理逻辑如下：</p><h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><p>当前节点的父节点是红色，且叔叔节点也是红色</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>通过调整颜色，在不改变红黑树5个特性的情况下，将红色节点上移。</p><h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将“父节点”设为黑色</li><li>将“叔叔节点”设为黑色</li><li>将“祖父节点”设为“红色”</li><li>将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作<br><img src="/image/base_rbtree_2.png" alt=""></li></ul><h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><p>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是父节点的右孩子</p><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>通过旋转，在不改变当前树原有特点的情况下（红节点的子节点还是红色），将情况2转变成情况3</p><h4 id="处理策略-1"><a href="#处理策略-1" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将“父节点”作为“新的当前节点”</li><li>以“新的当前节点”为支点进行左旋<br><img src="/image/base_rbtree_3.png" alt=""></li></ul><h3 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h3><p>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p><h4 id="处理策略-2"><a href="#处理策略-2" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将“父节点”设为“黑色”。</li><li>将“祖父节点”设为“红色”。</li><li>以“祖父节点”为支点进行右旋。<br><img src="/image/base_rbtree_4.png" alt=""></li></ul><h2 id="红黑树删除节点后矫正情况"><a href="#红黑树删除节点后矫正情况" class="headerlink" title="红黑树删除节点后矫正情况"></a>红黑树删除节点后矫正情况</h2><p>矫正的时间复杂度为O(1)。单次矫正，旋转从不超过3次。到情况2或者情况4就终止了。移除节点，如果移除的是红色节点，则直接删除即可。如果移除的是黑色节点，会破坏（“如果一个节点是红色的，则它的子节点必须是黑色的”和“每个节点或者是黑色，或者是红色”）特性。处理逻辑如下：</p><h3 id="情况1-1"><a href="#情况1-1" class="headerlink" title="情况1"></a>情况1</h3><p>x是”黑+黑”节点，x的兄弟节点是红色。</p><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>将当前模式转化为后续三种模式</p><h4 id="处理策略-3"><a href="#处理策略-3" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x的兄弟节点设为“黑色”。</li><li>将x的父节点设为“红色”。</li><li>对x的父节点进行左旋。</li><li>左旋后，重新设置x的兄弟节点。<br><img src="/image/base_rbtree_5.png" alt=""></li></ul><h3 id="情况2-1"><a href="#情况2-1" class="headerlink" title="情况2"></a>情况2</h3><p>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p><h4 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h4><p>将“黑+黑”节点，中的其中一个黑色属性消除，并上移。</p><h4 id="处理策略-4"><a href="#处理策略-4" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x的兄弟节点设为“红色”。</li><li>设置“x的父节点”为“新的x节点”，原来为红色，现在就是“黑+红”节点，将红色移除后，“新的x节点”为黑色，平衡结束。如果原来是黑色，现在就是“黑+黑”节点，根据情况执行处理策略。<br><img src="/image/base_rbtree_6.png" alt=""></li></ul><h3 id="情况3-1"><a href="#情况3-1" class="headerlink" title="情况3"></a>情况3</h3><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p><h4 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h4><p>将当前状态转化为情况4</p><h4 id="处理策略-5"><a href="#处理策略-5" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x兄弟节点的左孩子设为“黑色”。</li><li>将x兄弟节点设为“红色”。</li><li>对x的兄弟节点进行右旋。</li><li>右旋后，重新设置x的兄弟节点。<br><img src="/image/base_rbtree_7.png" alt=""></li></ul><h3 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h3><p>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p><h4 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h4><p>为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：</p><ul><li>第一，“同时经过根节点和S的分支的黑色节点个数不变”。<ul><li>若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。</li></ul></li><li>第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<ul><li>若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。</li></ul></li><li>第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<ul><li>在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。</li></ul></li></ul><p>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p><h4 id="处理策略-6"><a href="#处理策略-6" class="headerlink" title="处理策略"></a>处理策略</h4><ul><li>将x父节点颜色 赋值给 x的兄弟节点。</li><li>将x父节点设为“黑色”。</li><li>将x兄弟节点的右子节设为“黑色”。</li><li>对x的父节点进行左旋。</li><li>设置“x”为“根节点”。<br><img src="/image/base_rbtree_8.png" alt=""></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/redblack_tree.html" target="_blank" rel="noopener">https://tech.meituan.com/redblack_tree.html</a><br><a href="https://zhuanlan.zhihu.com/p/34840762" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34840762</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中的EventEmitter订阅发布</title>
      <link href="/2019/01/01/Node-JS%E4%B8%AD%E7%9A%84EventEmitter%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83/"/>
      <url>/2019/01/01/Node-JS%E4%B8%AD%E7%9A%84EventEmitter%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Node 中的许多核心 API 都是通过事件驱动的异步架构实现的，具体来说就是当 emitters 发送事件后，相应的响应函数（ listeners ）会被执行。例如：net.Server 会在每次收到连接时发出事件，fs.ReadStram 会在文件打开时发出事件，stram会在有数据可读时发出事件。 所有这些对象都是 EventEmitter 的实例，它们通过向外暴露的 eventEmitter.on() 接口从而让不同的事件响应函数得以执行。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h4 id="on-和-emit-方法"><a href="#on-和-emit-方法" class="headerlink" title="on 和 emit 方法"></a>on 和 emit 方法</h4><p>events 模块有且只有一个对象 events.EventEmitter，它的核心功能就是事件的触发（emit）和事件的监听（on），一个简单的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hi, my name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br></pre></td></tr></table></figure><p>在上述的例子中，我们通过 emitter.on(‘hi’, func) 的方式注册了 hi 事件的监听函数，通过 emitter.emit(‘hi’, ‘elvin’) 的方式触发了 hi 事件，且会向事件处理函数传递参数 ‘elvin’，所以最后的执行结果为 hi, my name is elvin!。 这里需要说明的时，EventEmitter 还有一个 addeListener 的方法，它只不过是 on 方法的别名，两者没有任何区别。</p><h4 id="once-方法"><a href="#once-方法" class="headerlink" title="once 方法"></a>once 方法</h4><p>有些时候，我们希望某些事件响应函数只被执行一次，这个时候就可以使用 once() 方法，它会和 on() 一样注册事件的响应函数，不过当响应函数执行一次之后，就会将其移除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">emitter.once(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hi, my name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'leonard'</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中只会输出 hi, my name is elvin!（leonard 很高冷，不屑于向你打招呼┗( ▔, ▔ )┛）。</p><h4 id="prependListener-方法"><a href="#prependListener-方法" class="headerlink" title="prependListener 方法"></a>prependListener 方法</h4><p>当一个事件绑定了多个响应函数时，会按照函数绑定的顺序依次执行，除非响应函数是通过 prependListener() 方法绑定的，它使用的方式和 on() 类似，不过会将响应函数插到当前该事件处理函数队列的头部，具体的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I\'m from Wuhan.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.prependListener(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nice to meet you!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'What\'s your name?'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// nice to meet you!</span></span><br><span class="line"><span class="comment">// my name is elvin.</span></span><br><span class="line"><span class="comment">// I'm from Wuhan.</span></span><br><span class="line"><span class="comment">// What\'s your name?</span></span><br></pre></td></tr></table></figure><h4 id="响应函数的数量"><a href="#响应函数的数量" class="headerlink" title="响应函数的数量"></a>响应函数的数量</h4><p>因为绑定过多的响应函数会消耗大量的内存，所以为了避免内存泄漏，在 Event.EventEmitter中一个事件可以绑定的响应函数数量是存在限制的，相关的属性和方法如下：</p><ul><li><strong>EventEmitter.defaultMaxListeners</strong>： 默认值为10， 表示每个事件的最多可以绑定的响应函数数量。需要注意的是，当修改它时，会影响所有 EventEmitter 的实例。</li><li><strong>emitter.listenerCount(eventName)</strong>：获取事件 eventName 已绑定的响应函数个数。</li><li><strong>emitter.setMaxListeners(n)</strong>：修改 emitter 的每个事件最多可以绑定的响应函数数量，该方法会修改 emitter._maxListeners 的值，其优先级大于 EventEmitter.defaultMaxListeners 。</li><li><strong>emitter.getMaxListeners()</strong>：获取 emitter 每个事件最多可以绑定的响应函数数量。</li></ul><h4 id="其他相关方法"><a href="#其他相关方法" class="headerlink" title="其他相关方法"></a>其他相关方法</h4><p>EventEmitter 还有一些其他的方法和属性，这里就不做具体介绍，简要地说一下。</p><ul><li><strong>emitter.eventNames()</strong>：返回当前已经绑定响应函数的事件名组成的数组。</li><li><strong>emitter.listeners(eventName)</strong>：返回 eventName 事件的响应函数组成的数组。</li><li><strong>emitter.prependOnceListener(eventName, listener)</strong>：类似于 once()，不过会将响应函数插到当前该事件处理函数队列的头部。</li><li><strong>emitter.removeAllListeners([eventName])</strong>：移除 eventName 事件所有的响应函数。当未传入 eventName 参数时，所有事件的响应函数都会被移除。</li><li><strong>emitter.removeListener(eventName, listener)</strong>：移除 eventName 事件的响应函数 listener。</li></ul><h4 id="newListener-和-removeListener-事件"><a href="#newListener-和-removeListener-事件" class="headerlink" title="newListener 和 removeListener 事件"></a>newListener 和 removeListener 事件</h4><p>当 emitter 被注册响应函数时，会触发 newListener 事件；被移除响应函数时，会触发 removeListener 事件。两个事件的响应函数会被传入两个参数：注册的事件名和响应的响应函数。具体的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：此处使用 emitter.on 方法的话会陷入循环调用，导致栈溢出</span></span><br><span class="line">emitter.once(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (event === <span class="string">'hi'</span>) &#123;</span><br><span class="line">        emitter.on(<span class="string">'hi'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Nice to meet you.'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'hi'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">'hi'</span>, <span class="string">'elvin'</span>);</span><br></pre></td></tr></table></figure><p>运行结果为 Nice to meet you. My name is elvin.。实际上， newListener 事件被触发时，响应函数还未被注册至 emitter，因而我们就可以在在目标响应函数之前插入其他响应函数，例如上面的例子中 Nice to meet you. 就在 My name is elvin. 之前进行输出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://imweb.io/topic/5973722452e1c21811630609" target="_blank" rel="noopener">https://imweb.io/topic/5973722452e1c21811630609</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中的事件循环机制</title>
      <link href="/2018/12/31/Node-JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/12/31/Node-JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Node.js的单线程含义，实际上说的是执行同步代码的主线程。一个Node程序的启动，不止是分配了一个线程，而是我们只能在一个线程执行代码。当出现I/O资源调用，TCP连接等外部资源申请的时候，不会阻塞主线程，而是委托给I/O线程进行处理，并且进入等待队列。一旦主线程执行完成，将会消费事件队列(Event Queue)。因为只有一个主线程，只占用CPU内核处理逻辑计算，因此不适合在CPU密集型进行使用。EventLoop 是一种常用的机制，通过对内部或外部的事件提供者发出请求，如文件读写，网络连接 等异步操作，完成后调用事件处理程序。整个过程都是异步阶段。</p><h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br><span class="line">   </span><br><span class="line">注：模型中的每一个方块代表事件循环的一个阶段</span><br></pre></td></tr></table></figure><ul><li>timers 阶段: 这个阶段执行通过setTimeout(callback)和setInterval(callback)设置的callback;</li><li>i/o 阶段: 执行除了close事件，和setTimeout，setInterval，setImmediate方法设定的callbacks之外的callbacks;</li><li>idle, prepare 阶段: 仅node内部使用;</li><li>poll 阶段: 轮询，不断检查有没有新的I/O事件，事件环可能会在这里阻塞;</li><li>check 阶段: 执行setImmediate(callback)设置的callbacks;</li><li>close 阶段: 执行close事件的callback，例如socket.on(‘close’, callback)的callbacks;</li></ul><h2 id="各阶段详细介绍"><a href="#各阶段详细介绍" class="headerlink" title="各阶段详细介绍"></a>各阶段详细介绍</h2><p>下面，我们来针对Node事件循环的每个阶段进行详细说明。</p><h4 id="timers-阶段"><a href="#timers-阶段" class="headerlink" title="timers 阶段"></a>timers 阶段</h4><p>这个阶段主要用来处理定时器相关的回调，当一个定时器超时后，一个事件就会加入到队列中，事件循环跳转至这个阶段执行对应的回调函数。定时器的回调会在触发后尽可能早地被调用，这表示实际的延时可能会比定时器规定的时间要长。如果事件循环，此时正在执行一个比较耗时的callback，例如处理一个比较耗时的循环，那么定时器的回调只能等到当前回调执行结束了才能被执行，即被阻塞。事实上，timers阶段的执行受到poll阶段的控制，后面会讲到。</p><h4 id="IO-callbacks-阶段"><a href="#IO-callbacks-阶段" class="headerlink" title="IO callbacks 阶段"></a>IO callbacks 阶段</h4><p>Nodejs官网文档对这个阶段的解释为：除了timers、setImmediate，以及close操作之外的大多数的回调方法都位于这个阶段执行。但是，一些常见的回调，例如fs.readFile的回调是放在poll阶段来执行的。根据libuv的文档，一些应该在上轮事件循环poll阶段执行的callback，因为某些原因不能执行，就会被延迟到这一轮的事件循环的I/O callbacks阶段执行。换句话说这个阶段执行的callbacks是上轮残留的。</p><h4 id="poll-阶段"><a href="#poll-阶段" class="headerlink" title="poll 阶段"></a>poll 阶段</h4><p>poll阶段的主要任务是等待新的事件的出现（该阶段使用epoll来获取新的事件），如果没有，事件循环可能会在此阻塞。这些事件对应的回调方法可能位于timers阶段（如果定义了定时器），也可能是check阶段（如果设置了setImmediate方法）。poll阶段主要有两个步骤如下：</p><p>（1）如果有到期的定时器，那么就执行定时器的回调方法。<br>（2）处理poll阶段对应的事件队列（以下简称poll队列）里的事件。<br>当事件循环到达poll阶段时，如果这时没有要处理的定时器的回调方法，则会进行下面的判断：<br>（1）如果poll队列不为空，则事件循环会按照顺序遍历执行队列中的回调函数，这个过程是同步的。<br>（2）如果poll队列为空，会接着进行如下的判断：①如果当前代码定义了setImmediate方法，事件循环会离开poll阶段，然后进入check阶段去执行setImmediate方法定义的回调方法。②如果当前代码并没有定义setImmediate方法，那么事件循环可能会进入等待状态，并等待新的事件出现，这也是该阶段为什么会被命名为poll（轮询）的原因。此外，还会不断检查是否有相关的定时器超时，如果有，就会跳转到timers阶段，然后执行对应的回调。</p><h4 id="check-阶段"><a href="#check-阶段" class="headerlink" title="check 阶段"></a>check 阶段</h4><p>setImmediate是一个特殊的定时器方法，它占据了事件循环的一个阶段，整个check阶段就是为setImmediate方法而设置的。一般情况下，当事件循环到达poll阶段后，就会检查当前代码是否调用了setImmediate，但如果一个回调函数是被setImmediate方法调用的，事件循环就会跳出poll阶段而进入check阶段。</p><h4 id="close-阶段"><a href="#close-阶段" class="headerlink" title="close 阶段"></a>close 阶段</h4><p>如果一个socket或者一个句柄被关闭，那么就会产生一个close事件，该事件会被加入到对应的队列中。close阶段执行完毕后，本轮事件循环结束，循环进入到下一轮。</p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java-反向代理的思考</title>
      <link href="/2018/12/18/Java-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/12/18/Java-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="动态代理使用介绍"><a href="#动态代理使用介绍" class="headerlink" title="动态代理使用介绍"></a>动态代理使用介绍</h2><p>动态代理，利用Java的反射技术，在运行时创建一个实现某些给定接口的新类及其实例。代理的是接口，不是类，更不是抽象类。演示代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现动态代理</span></span><br><span class="line">        IHello iHello = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;IHello.class&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"before"</span>);</span><br><span class="line">                Object rs = method.invoke(<span class="keyword">new</span> Hello(), args);</span><br><span class="line">                System.out.println(<span class="string">"after"</span>);</span><br><span class="line">                <span class="keyword">return</span> rs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        iHello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print:</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态创建一个代理对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader 定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces 表示的是我将要给我需要代理的对象提供一组什么接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 代理对象的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用代理方法</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface InvocationHandler </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 指代我们所代理的那个真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 指代的是我们所要调用真实对象的方法的Method对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 指代的是调用真实对象某个方法时接受的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的Object是指真实对象方法的返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP的场景思考"><a href="#AOP的场景思考" class="headerlink" title="AOP的场景思考"></a>AOP的场景思考</h2><p>java中的注解用于描述代码辅助信息。注解的好处是在不影响代码逻辑，插入代码描述信息。<br>如何让代码更好的解耦，应该是很重要的问题。尤其是现在组件化开发模式盛行，如何让组件之间减少依赖关系，变得越来越重要了。下面讲解下，我所认为的组件间通讯的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑中使用登录功能</span></span><br><span class="line">Login l = AOPHelper.get(<span class="string">"login"</span>);</span><br><span class="line">l.login();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录模块接口描述</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Interface</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录模块实现类，注意这个实现可能是在登录组件中的，所以最好不要将业务逻辑和LoginImpl实现直接耦合在一起</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Impl</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.e(<span class="string">"test"</span>, <span class="string">"登录成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过AOPHelper类，将实现和接口之间通过注解的方式连接起来。</span></span><br><span class="line"><span class="comment">// 通过这种方式，既做到了组件和业务的解耦，也做到了具体实现的调用连接。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AOPHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集注解信息，然后将接口和实现关联起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/techyc/p/3455950.html" target="_blank" rel="noopener">https://www.cnblogs.com/techyc/p/3455950.html</a><br><a href="https://zhuanlan.zhihu.com/p/29188162" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29188162</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中模块管理介绍</title>
      <link href="/2018/12/16/Node-JS%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/12/16/Node-JS%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="exports、module-exports、require的使用介绍"><a href="#exports、module-exports、require的使用介绍" class="headerlink" title="exports、module.exports、require的使用介绍"></a>exports、module.exports、require的使用介绍</h2><p>exports和module.exports都是用来指定js文件需要导出的属性值。本质上，exports只是module.exports的引用，辅助后者添加内容用的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下方等价，因为exports相当于module.exports的引用</span></span><br><span class="line">exports.func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line"><span class="built_in">module</span>.exports.func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下方代码不等价，因为对exports进行直接复制，相当于将exports的内存指向改变了。所以不再是module.exports的引用</span></span><br><span class="line">exports = &#123;</span><br><span class="line">func1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">func1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>require方法按照下面顺序，查找模块并导出模块对象。</p><blockquote><p><strong>缓存模块：</strong>如果X存在于内存缓存中，则直接从内存缓存中读取文件<br><strong>核心模块：</strong>如果 X 是内置模块（比如 require(‘http’）)<br>　　1. 返回该模块<br>　　2. 不再继续执行<br><strong>文件模块：</strong>如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　1. 根据 X 所在的父模块，确定 X 的绝对路径<br>　　2. 将 X 当成文件，依次查找 X ， X.js ， X.json， X.node ，只要其中有一个存在，就返回该文件，不再继续执行<br>　　3. 将 X 当成目录，依次查找 X/package.json（main字段）， X/index.js， X/index.json， X/index.node， 只要其中有一个存在，就返回该文件，不再继续执行<br><strong>自定义模块：</strong>. 如果 X 不带路径，根据 X 所在的父模块，确定 X 可能的安装目录。 依次在每个目录中，将 X 当成文件名或目录名加载<br><strong>未找到模块：</strong> 抛出 “not found”</p></blockquote><h2 id="js中的默认变量"><a href="#js中的默认变量" class="headerlink" title="js中的默认变量"></a>js中的默认变量</h2><ul><li>exports：声明导出对象属性</li><li>require：导入模块方法</li><li>module：模块对象</li><li>__filename：js文件名</li><li>__dirname：js目录名</li></ul><p>这些默认属性是在js编译时，通过对js文件内容进行了头尾包装设置进去的。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头尾包装伪代码</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;\n 文件内容 \n&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// js文件内容</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">radius</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时的头尾包装</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">radius</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius; </span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="js中的包结构"><a href="#js中的包结构" class="headerlink" title="js中的包结构"></a>js中的包结构</h2><ul><li>package.json：包描述文件</li><li>bin：存放可执行二进制文件的目录</li><li>lib：存放js代码的目录</li><li>doc：存放文档的目录</li><li>test：存放单元测试用例代码的目录</li></ul><p>包描述信息介绍<br>package.json位于包的根目录，是对于包的描述信息的配置文件。字段规范如下：</p><table><thead><tr><th>key</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>名</td></tr><tr><td>description</td><td>简介</td></tr><tr><td>version</td><td>版本号</td></tr><tr><td>keywords</td><td>关键词数组</td></tr><tr><td>maintainers</td><td>维护者列表</td></tr><tr><td>contributors</td><td>贡献者列表</td></tr><tr><td>bugs</td><td>可以反馈bug的网页或邮箱地址</td></tr><tr><td>licenses</td><td>许可证列表</td></tr><tr><td>respositories</td><td>托管源码的位置列表</td></tr><tr><td>dependencies</td><td>依赖项列表</td></tr><tr><td>homepage</td><td>网站地址</td></tr><tr><td>os</td><td>操作系统支持列表</td></tr><tr><td>cpu</td><td>CPU架构支持列表</td></tr><tr><td>engine</td><td>支持的JS引擎列表</td></tr><tr><td>builten</td><td>是否内建在底层系统的标准组件</td></tr><tr><td>directories</td><td>目录说明</td></tr><tr><td>implements</td><td>实现规范的列表</td></tr><tr><td>scripts</td><td>脚本说明对象</td></tr><tr><td>authoer</td><td>作者</td></tr><tr><td>bin</td><td>配置为命令行工具</td></tr><tr><td>main</td><td>入口文件</td></tr><tr><td>devDependencies</td><td>开发依赖项列表</td></tr></tbody></table><h2 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令"></a>npm命令</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>$ npm</td><td>查看NPM帮助说明</td></tr><tr><td>$ npm -v</td><td>查看当前NPM版本</td></tr><tr><td>$ npm init</td><td>初始化包(配置package.json)</td></tr><tr><td>$ npm <command></td><td>查看具体命令帮助说明</td></tr><tr><td>$ npm install <package></package></td><td>安装第三方包</td></tr><tr><td>$ npm uninstall <package></package></td><td>卸载包</td></tr><tr><td>$ npm install <package> –save-dev</package></td><td>安装包并将安装信息写入package.json(devDependencies)</td></tr><tr><td>$ npm install <package> –dev</package></td><td>安装第包并将安装信息写入package.json(dependencies)</td></tr><tr><td>$ npm install <package> -g</package></td><td>全局安装第三方包</td></tr><tr><td>$ npm install <file-url></file-url></td><td>安装本地包</td></tr><tr><td>$ npm adduser</td><td>注册npm账号</td></tr><tr><td>$ npm publish <folder></folder></td><td>上传包</td></tr><tr><td>$ npm owner ls <package-name></package-name></td><td>查看包拥有者</td></tr><tr><td>$ npm owner add <user> <package-name></package-name></user></td><td>添加包拥有者</td></tr><tr><td>$ npm owner rm <user> <package-name></package-name></user></td><td>删除包拥有者</td></tr><tr><td>$ npm ls</td><td>分析包</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/05/require.html</a><br><a href="https://blog.csdn.net/q1056843325/article/details/54948719" target="_blank" rel="noopener">https://blog.csdn.net/q1056843325/article/details/54948719</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中声明属性和方法</title>
      <link href="/2018/12/09/Node-JS%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/09/Node-JS%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h1><p>es6中的class关键字，其实只是一个语法糖，本质上是对原型链的一个封装。</p><h1 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h1><p>截止es6，声明属性的最佳实践如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明类</span><br><span class="line">class Clazz &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // 建议将静态属性和对象属性的声明的初始化都放在构造函数中进行</span><br><span class="line">    // 声明对象属性</span><br><span class="line">    this.field = &quot;对象属性&quot;;</span><br><span class="line">    // 声明静态属性</span><br><span class="line">    Test.sField = &quot;静态属性&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本质说明"><a href="#本质说明" class="headerlink" title="本质说明"></a>本质说明</h3><ul><li>静态属性的本质就是在类上挂在对象，而类本质上就是构造函数function，所以静态属性就是直接在构造函数上挂在对象。</li><li>对象属性的本质就是在对象上挂在对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 实现对象属性的效果</span><br><span class="line">let clazz = new Clazz();</span><br><span class="line">clazz.field =  &quot;对象属性“;</span><br><span class="line"></span><br><span class="line">// 实现静态属性的效果</span><br><span class="line">Clazz.sField = &quot;静态属性&quot;;</span><br></pre></td></tr></table></figure><h2 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h2><p>截止es6，声明方法的最佳实践如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 声明类</span><br><span class="line">class Clazz &#123;</span><br><span class="line">  </span><br><span class="line">  func()&#123;</span><br><span class="line">    console.log(&quot;声明对象方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static sFunc()&#123;</span><br><span class="line">    console.log(&quot;声明静态方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用对象方法</span><br><span class="line">let clazz = new Clazz();</span><br><span class="line">clazz.func();</span><br><span class="line">// 调用静态方法</span><br><span class="line">Clazz.sFunc();</span><br></pre></td></tr></table></figure><h3 id="本质说明-1"><a href="#本质说明-1" class="headerlink" title="本质说明"></a>本质说明</h3><ul><li>静态方法本质和静态属性类似，就是在构造函数上挂在方法。</li><li>对象方法本质是在构造函数的原型链上挂在对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 声明类</span><br><span class="line">class Clazz &#123;</span><br><span class="line">  </span><br><span class="line">  func()&#123;</span><br><span class="line">    console.log(&quot;声明对象方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static sFunc()&#123;</span><br><span class="line">    console.log(&quot;声明静态方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">function Clazz()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Clazz.prototype.func = &#123;</span><br><span class="line">  console.log(&quot;声明对象方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clazz.sFunc = &#123;</span><br><span class="line">  console.log(&quot;声明静态方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中Promise的理解</title>
      <link href="/2018/11/25/Node-JS%E4%B8%ADPromise%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/11/25/Node-JS%E4%B8%ADPromise%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h1><p>Promise对象代表一个异步操作，里面保存着某个未来才会结束的事件的结果。对象的状态不受外界影响。</p><ul><li>Promise对象有三种状态：pending（进行中）、resolve（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li><li>Promise对象的状态改变，只有两种可能：从pending变为resolve和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</li><li>Promise对象的回调，可以暂存状态。即，如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</li></ul><h1 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h1><h3 id="基础语法介绍"><a href="#基础语法介绍" class="headerlink" title="基础语法介绍"></a>基础语法介绍</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明操作</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行异步操作，例如setTimeout方法</span></span><br><span class="line">  <span class="comment">// 但当前位置代码还是在主线程上操作的</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'do something'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Date</span>.now() % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    resolve(<span class="string">'success value'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 失败回调</span></span><br><span class="line">    reject(<span class="string">'failed value'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用操作</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 成功回调</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 失败回调，是可选的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise代码执行顺序"><a href="#Promise代码执行顺序" class="headerlink" title="Promise代码执行顺序"></a>Promise代码执行顺序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new Promise() 本质上是调用构造函数的操作</span></span><br><span class="line">  <span class="comment">// 因此，下面代码会在函数执行时，就被调用</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用resolved函数，将Promise中的resolved</span></span><br><span class="line">  <span class="comment">// 状态保存起来，待then时出发resolved状态</span></span><br><span class="line">  resolved();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在下一个事件循环中被调用</span></span><br><span class="line">  <span class="comment">// 当前脚本所有同步任务执行完才会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前脚本的同步执行任务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><h3 id="Promise返回一个Promise结果"><a href="#Promise返回一个Promise结果" class="headerlink" title="Promise返回一个Promise结果"></a>Promise返回一个Promise结果</h3><p>p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 构造p1时，开始3s计时操作</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造p1时，开始1s计时操作</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1s后，将p1结果保存下来</span></span><br><span class="line">  <span class="comment">// 由于p1是Promise对象，因此p1当前的状态确定了p2的状态，当前为pending状态</span></span><br><span class="line">  <span class="comment">// 2s后，p1返回reject状态，于是p2也返回了reject状态</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><h1 id="Promise特性介绍"><a href="#Promise特性介绍" class="headerlink" title="Promise特性介绍"></a>Promise特性介绍</h1><h3 id="Promise-prototype-then-介绍"><a href="#Promise-prototype-then-介绍" class="headerlink" title="Promise.prototype.then()介绍"></a>Promise.prototype.then()介绍</h3><p>then返回的作用是为 Promise 实例添加状态改变时的回调函数。</p><ul><li>then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</li><li>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then函数，将返回一个新的Promise实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造Promise对象</span></span><br><span class="line">  resolved(<span class="string">'first'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'second'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 相当于 Promise.reject('third');</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'third'</span></span><br><span class="line">&#125;).then(<span class="literal">null</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 相当于 Promise.resolved('fourth');</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'fourth'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch-介绍"><a href="#Promise-prototype-catch-介绍" class="headerlink" title="Promise.prototype.catch()介绍"></a>Promise.prototype.catch()介绍</h3><ul><li>Promise.prototype.catch方法是Promise.prototype.then(null, rejection)的别名，用于指定发生错误时的回调函数。</li><li>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</li></ul><p>一般在使用promise时，最好在后面添加catch操作。用catch来替代then(resolved, reject)的处理范式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐，在promise最后统一处理error情况</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally-介绍"><a href="#Promise-prototype-finally-介绍" class="headerlink" title="Promise.prototype.finally()介绍"></a>Promise.prototype.finally()介绍</h3><ul><li>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</li><li>finally方法的回调函数不接受任何参数，因此没有办法知道前面 Promise 状态到底是resolved还是rejected。</li></ul><p>finally方法的本质如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="常用静态方法"><a href="#常用静态方法" class="headerlink" title="常用静态方法"></a>常用静态方法</h1><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><p>p的状态由p1、p2、p3决定，分成两种情况。</p><ul><li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li></ul><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p><p>p的状态由以下条件决定。</p><ul><li>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</li></ul><h3 id="Promise-resolve-amp-Promise-reject"><a href="#Promise-resolve-amp-Promise-reject" class="headerlink" title="Promise.resolve() &amp; Promise.reject()"></a>Promise.resolve() &amp; Promise.reject()</h3><p>Promise.resolve()的本质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/** p 为 Promise实例 **/</span>) &#123;</span><br><span class="line"><span class="comment">// 直接返回Promise实例</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/** p 中存在有thenable属性 **/</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">resolved(p.thenable());</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/** p 存在 **/</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">resolved(p);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/** p 不存在 **/</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolved, reject</span>) </span>&#123;</span><br><span class="line">resolved();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.reject()的本质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-then" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise#Promise-prototype-then</a></p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node-JS中原型的理解</title>
      <link href="/2018/11/10/Node-JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/11/10/Node-JS%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="prototype与-proto-的区别"><a href="#prototype与-proto-的区别" class="headerlink" title="prototype与__proto__的区别"></a>prototype与__proto__的区别</h1><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ol><li>所有对象都具有__proto__属性。在JS中，一切皆对象。方法（Function）是对象，方法的原型(Function.prototype)也是对象，因此它们都有__proto__属性。</li><li>方法(Function)是一个特殊的对象，它除了有__proto__属性之外，还有自己特有的prototype属性。prototype属性指向一个所有实例共享的原型对象。原型对象中有一个constructor属性，指回到原函数。</li><li>对象的__proto__属性指向该对象的构造函数的prototype属性，这保证了对象能够访问构造函数的prototype属性中定义的属性和方法。</li></ol><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><p><img src="/image/js_prototype.jpg" alt="原型链图"></p><ol><li>构造函数（Foo()）<ul><li>构造函数的Foo.prototype属性指向了原型对象，在原型对象里有共有方法，所有构造函数声明的实例（f1，f2）都可以共享这些共用方法。</li><li>构造函数也是对象，也有__proto__属性。指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。</li></ul></li><li>原型对象（Foo.prototype）<ul><li>原型对象Foo.prototype保存着实例共享的方法，还有属性constructor指回构造函数。</li></ul></li><li>实例（f1，f2）<ul><li>f1，f2是Foo的两个实例，这两个对象有属性__proto__，指向构造函数的原型对象，这样就可以访问原型对象的所有方法啦。</li></ul></li></ol><p><strong>总结</strong></p><ol><li>对象有属性__proto__，指向该对象的构造函数的原型对象。</li><li>方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。</li></ol><h1 id="new操作到底做了什么？"><a href="#new操作到底做了什么？" class="headerlink" title="new操作到底做了什么？"></a>new操作到底做了什么？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Base();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上等价于</span></span><br><span class="line"><span class="comment">// 我们创建了一个空对象obj</span></span><br><span class="line"><span class="keyword">let</span> obj  = &#123;&#125;; </span><br><span class="line"><span class="comment">// 我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象</span></span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"><span class="comment">// 我们将Base函数对象的this指针替换成obj，并调用Base方法对obj进行初始化</span></span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h1 id="为啥constructor指向会错乱"><a href="#为啥constructor指向会错乱" class="headerlink" title="为啥constructor指向会错乱?"></a>为啥constructor指向会错乱?</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> F();</span><br><span class="line">F.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor)<span class="comment">//F</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor)<span class="comment">//Object</span></span><br></pre></td></tr></table></figure><p>首先你要明白，F.prototype 是对一个实例对象的引用，这个实例对象在你创建函数 F( ) 的时候同时被生成，如果我们给这个对象起个名字叫做 A，那么我们可以简单的理解为：A 是一个被存储在内存中的一个实例对象，而 F.prototype 是指向 A 的一个指针。</p><p>同时，A 对象内也有一个指针 constructor ，它指向了函数 F()。</p><p>那么当你第一次使用 new F( ) 时，生成了一个新对象 a ，p1 是对象 a 的一个引用（即p是指向a的一个指针），而 a 的 __proto__ 属性在此时也已经被指向为 A。</p><p>即目前，指向对象实例 A 的指针有两个，分别是 a.__proto__ 和 F.prototype。</p><p>之后你对 F.prototype 进行赋值时，实际上改变了 F.prototype 的指向，试他指向了另一个个实例对象{}，我们管这个实例对象叫 B 好了，对于这个实例对象 B，它的 constructor 的属性指向了 Object。</p><p>请注意，此时 a 的 __proto__ 的指向并没有改变，仍是指向了实例对象A。</p><p>那么当你第二次调用 new F( ) 的时候，实际上生成了另一个新的实例对象 b, b 的 __proto__ 属性指向的是B。</p><p>所以在 p1.constructor 的背后其实是相当于:<br>p1 -&gt; a, a.__proto__ -&gt; A, A.constructor -&gt; F( )</p><p>而在 p2.constructor 的背后则为：<br>p2 -&gt; b, b.__proto__ -&gt; B, B.constructor -&gt; Object( )</p><p><img src="/image/js_construct.png" alt="Construct指向图"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/q/1010000006918070" target="_blank" rel="noopener">https://segmentfault.com/q/1010000006918070</a></li><li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">https://www.zhihu.com/question/34183746</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-对于《Socket心跳包》的思考</title>
      <link href="/2018/11/04/%E7%BD%91%E7%BB%9C-%E5%AF%B9%E4%BA%8E%E3%80%8ASocket%E5%BF%83%E8%B7%B3%E5%8C%85%E3%80%8B%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/11/04/%E7%BD%91%E7%BB%9C-%E5%AF%B9%E4%BA%8E%E3%80%8ASocket%E5%BF%83%E8%B7%B3%E5%8C%85%E3%80%8B%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要Socket心跳包"><a href="#为什么需要Socket心跳包" class="headerlink" title="为什么需要Socket心跳包"></a>为什么需要Socket心跳包</h2><p>实现方式上，TCP keepalive 和Socket心跳包机制类似。TCP keepalive 机制通过，在进行TCP连接时，发送keepalive数据包，来判断当前TCP连接是否仍然有效。问题来了，既然已经有了TCP keepalive，为什么还需要Socket心跳机制呢？</p><p>个人认为，需要Socket心跳机制的原因如下：</p><ol><li>真实网路环境中，TCP keepalive消息，可能会被中继设备和路由设备终结。</li><li>自己实现Socket心跳机制，处理断线重连的灵活性更高。</li><li>TCP keepalive本身是OSI模型中的传输层处理逻辑，由操作系统负责探查，即便服务进程死锁或阻塞，操作系统也会如常处理TCP keepalive消息，因此TCP keepalive的目标是保证传输层的网路通畅。而Socket心跳机制，是OSI模型中的应用层处理逻辑，由服务程序负责探查，不但能保证应用程序存活，网络通畅，更重要的是能够保证应用程序仍在正常工作。</li></ol><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><ul><li>单工：只允许甲方向乙方传送信息，而乙方不能向甲方传送，例如汽车的单行道。</li><li>全双工：允许数据在两个方向上同时进行传送操作，例如汽车的双行道。</li><li>半双工：允许数据在两个方向上进行传送操作，但是两端不能同时传送。例如一条窄窄的马路，同时只能有一辆车通过，当目前有两辆车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开。</li></ul><h2 id="WebSocket是什么？"><a href="#WebSocket是什么？" class="headerlink" title="WebSocket是什么？"></a>WebSocket是什么？</h2><p>中文翻译</p><ul><li><a href="https://www.jianshu.com/p/867274a5e054" target="_blank" rel="noopener">https://www.jianshu.com/p/867274a5e054</a></li><li><a href="https://www.jianshu.com/p/fc09b0899141" target="_blank" rel="noopener">https://www.jianshu.com/p/fc09b0899141</a></li></ul><p>英文原文</p><ul><li><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455</a></li></ul><h2 id="OkHttp3中WebSocket心跳设计"><a href="#OkHttp3中WebSocket心跳设计" class="headerlink" title="OkHttp3中WebSocket心跳设计"></a>OkHttp3中WebSocket心跳设计</h2><p>OkHttp3在3.5版本之后，对WebSocket进行了支持。</p><p>OkHttp3:3.5~3.10</p><ul><li>没有做心跳失效操作，手机端只负责发送ping操作，不管pong是否有收到。</li></ul><p>OkHttp3:3.11.0~之后</p><ul><li>做了简单的心跳失效操作，当发送第二次ping时，第一次ping的服务端pong还没有得到回应，则说明心跳失效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android-大搜车的注解收集器</title>
      <link href="/2018/10/30/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2018/10/30/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是对编译时注解展开讨论。Android端对自定义注解的应用程度远没有达到Java Web端的那种程度，而且市面上也没有一个专注于抽象编译时注解底层技术的库。</p><p>在真实开发场景中，如果想要实现一个利用编译时注解的功能，往往需要花大量精力来处理APT这块的繁琐逻辑。例如，遍历所有注解相关类然后生成一定规律的代码。这些繁琐操作阻碍了大家使用注解的热情。设想一下，如果使用编译时注解只需要增加一两行代码，那你会不会更愿意使用注解呢？</p><p>所以，我们在想是否能够对编译时注解做进一步的抽象，帮助开发者将重点放在具体的功能实现上，而不是处理编译时注解的繁琐操作上？</p><h1 id="Nara的诞生"><a href="#Nara的诞生" class="headerlink" title="Nara的诞生"></a>Nara的诞生</h1><p>在动手之前，需要先弄清楚大家利用注解都做了哪些事情。清楚注解的使用场景，能帮助我们抽象出一个更好用的注解框架。于是，我们调研了Android端上常用的注解框架，看看他们利用注解都做了什么事情？</p><ul><li><p>ButterKnife：例如@BindViews，ButterKnife在编译期，利用@BindView将控件ID和类属性建立对应关系。然后在页面启动时，根据控件ID通过findViewById方法将控件赋值到类属性上。</p></li><li><p>EventBus：通过@Subscribe对普通方法进行标记。然后，EventBus在编译期通过@Subscribe将这些方法收集起来，作为EventBus的订阅方法。</p></li><li><p>Retrofit：通过反射方式处理注解，不再本文范畴。</p></li></ul><p>编译时注解的主要用途在于，收集注解并通过注解信息生成一些有规律的代码。</p><p>而这些有规律的代码，一般都是可以通过其他方式来间接实现的。比如说，ButterKnife的属性赋值可以通过反射来实现，EventBus的方法收集可以直接换个写法。所以，如果要对编译时注解做进一步抽象，我们认为可以从注解收集方面入手。由此，Nara注解收集器诞生了。</p><h2 id="API的设计"><a href="#API的设计" class="headerlink" title="API的设计"></a>API的设计</h2><p>对于底层库而言，设计一套好用的API是很重要的。从库的使用者角度看，希望注解收集器能够帮助我们实现哪些功能呢？</p><ul><li>注解的作用范围：通过分析市面上编译时注解的使用场景，发现对注解的应用主要在于类，方法和属性上。</li><li>自定义注解：作为注解抽象库，如果无法支持自定义注解，那对可扩展性简直就是致命的打击。所以需要提供自定义注解功能。</li><li>注解收集：注解收集作为核心功能，必须要提供一套好用的收集操作。我们考虑用链式Builder来完成注解收集功能。</li></ul><p>最终设计的API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解API</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE, ElementType.METHOD, ElementType.FIELD)</span><br><span class="line"><span class="meta">@ShadowBinding</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解的使用API</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationClass</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">AnnotationMethod</span><span class="params">(<span class="keyword">int</span> p1, String p2, AnnotationClass p3, T p4)</span></span>&#123;</span><br><span class="line">    Log.e(<span class="string">"souche"</span>, <span class="string">"test2("</span> + <span class="string">"p1("</span> + p1 + <span class="string">"),p2("</span> + p2 + <span class="string">"),p3("</span> + p3 + <span class="string">"),p4("</span> + p4 + <span class="string">"));"</span>);</span><br><span class="line">    <span class="keyword">return</span> p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span> <span class="comment">// 成员属性</span></span><br><span class="line"><span class="keyword">public</span> List&lt;AnnotationClass&gt; annotationField;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收集注解的使用API，以Class的收集举例</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">List&lt;ClassDesc&gt; listClass = Nara</span><br><span class="line">                .findClass(CustomAnnotation.class) <span class="comment">// 查找类，参数为其所在注解</span></span><br><span class="line">                .withExtends(Activity.class) <span class="comment">// 筛选条件：查找的类，需要继承Activity类</span></span><br><span class="line">                .withAnnotations(Collect.class) <span class="comment">// 筛选条件：查找的类，需要被@Collect注解</span></span><br><span class="line">                .filter(<span class="keyword">new</span> AnnotationFilter&lt;ClassDesc&gt;() &#123; <span class="comment">// 自定义筛选条件：return true 表示过滤掉当前类</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(ClassDesc obj)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .list(); <span class="comment">// 返回符合条件的类集合</span></span><br></pre></td></tr></table></figure><h1 id="实现的痛点"><a href="#实现的痛点" class="headerlink" title="实现的痛点"></a>实现的痛点</h1><p>一个优秀的底层库，应该将复杂实现隐藏起来，并且做到实现对于上层使用者透明。下面简单分享下实现Nara时，遇到的几个技术痛点。</p><h3 id="对泛型的支持"><a href="#对泛型的支持" class="headerlink" title="对泛型的支持"></a>对泛型的支持</h3><p>在收集注解信息时，会遇到方法参数或者属性中带有泛型信息的情况。为了收集这些泛型信息，我们利用了Gson实现的TypeToken泛型Type转化工具。将TypeToken的相关代码拷贝到了Nara内部。Gson获取Type的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = <span class="keyword">new</span> TypeToken&lt;clazz&gt;() &#123;&#125;.getType();</span><br></pre></td></tr></table></figure><h2 id="被注解对象的包级作用域问题"><a href="#被注解对象的包级作用域问题" class="headerlink" title="被注解对象的包级作用域问题"></a>被注解对象的包级作用域问题</h2><p>Nara注解收集是支持包级作用域的信息收集的。这里就存在一个问题，包作用域的类，方法和属性是不允许跨包访问的。那么，如何在不同包下获取包级作用域下的信息呢？我们采取的方式是利用编译时注解生成被注解类的同包名下的类，然后将包级作用域的信息用public的形式暴露出来。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 例如包级作用域的属性</span></span><br><span class="line"><span class="keyword">package</span> com.example.souche.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CustomAnnotation</span></span><br><span class="line">String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将People.name的get和set方法的作用域暴露出来</span></span><br><span class="line"><span class="comment">// 我们在编译时，生成了public作用域的get和set方法</span></span><br><span class="line"><span class="keyword">package</span> com.example.souche.annotation;</span><br><span class="line"><span class="comment">/** This class is generated by SouChe Annotation Collection, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerCollection</span>$<span class="title">AdaptableClass1540292058755_29</span> </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">com</span>.<span class="title">souche</span>.<span class="title">android</span>.<span class="title">annotation</span>.<span class="title">core</span>.<span class="title">FieldDesc</span>.<span class="title">BeanMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object... params)</span></span>&#123; </span><br><span class="line">                <span class="keyword">if</span> (params.length != <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"set argument format error!"</span>);</span><br><span class="line">                com.example.souche.annotation.People.name = (java.lang.String)params[<span class="number">0</span>];</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object... params)</span></span>&#123; </span><br><span class="line">                <span class="keyword">if</span> (params.length != <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"get argument format error!"</span>);</span><br><span class="line">                <span class="keyword">return</span> com.example.souche.annotation.People.name;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件化下的编译时注解问题"><a href="#组件化下的编译时注解问题" class="headerlink" title="组件化下的编译时注解问题"></a>组件化下的编译时注解问题</h2><p>我们团队是采用的是模块化的开发形式，模块将代码将aar包上传到maven仓库，主工程再通过gradle来依赖模块aar包。这样就会存在一个问题，由于编译时注解的作用范围是源码级别的，所以无法对aar包中的注解进行收集。</p><p>我们的解决思路是，如果模块需要使用Nara注解收集器，在模块打包时，就将Nara相关代码打进aar包，然后在主工程打包时，通过gradle插件扫描整个app的字节码，找到Nara相关代码，将这些代码整合起来，生成一个Nara初始化主类。总体打包流程如下：</p><p><img src="/image/nara_compile_flowchat.png" alt="编译流程图"></p><h1 id="框架愿景"><a href="#框架愿景" class="headerlink" title="框架愿景"></a>框架愿景</h1><p>Nara是对编译时注解的上层抽象，我们希望通过Nara来降低编译时注解的开发成本。让使用者把精力放在逻辑实现上，而不是在注解信息收集上。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络-OSI 七层通讯</title>
      <link href="/2018/10/11/%E7%BD%91%E7%BB%9C-OSI-%E4%B8%83%E5%B1%82%E9%80%9A%E8%AE%AF/"/>
      <url>/2018/10/11/%E7%BD%91%E7%BB%9C-OSI-%E4%B8%83%E5%B1%82%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<style>table th:nth-of-type(1) {    width: 100px;}</style><h2 id="OSI七层通讯"><a href="#OSI七层通讯" class="headerlink" title="OSI七层通讯"></a>OSI七层通讯</h2><table><thead><tr><th>通讯层</th><th>作用说明</th></tr></thead><tbody><tr><td>应用层</td><td>它的作用fancybox是为应用程序提供服务并规定应用程序中通讯相关的细节。是最贴近应用开发人员的网络层。常见的协议有 HTTP，FTP，TELNET、SMTP 等。</td></tr><tr><td>表示层</td><td>它的作用是将应用层处理的信息从主机特有的格式转换为网络标准传输格式</td></tr><tr><td>会话层</td><td>它的作用是确定建立和断开网络的时机，并管理网络连接</td></tr><tr><td>传输层</td><td>它的作用是建立网络连接，创建逻辑上的通信连接，从逻辑上将数据发送到目标对象</td></tr><tr><td>网络层</td><td>它的作用是将数据传输到目标地址，重点在于寻找目标地址。可能需要通过多个路由器连接才能到达目标地址。</td></tr><tr><td>数据链路层</td><td>它的作用是物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。</td></tr><tr><td>物理层</td><td>它的作用是将0、1比特流（0、1序列）与电信号和光信号进行转化。实现物理层面上的数据传输。</td></tr></tbody></table><h2 id="网络设备对应的OSI通讯层"><a href="#网络设备对应的OSI通讯层" class="headerlink" title="网络设备对应的OSI通讯层"></a>网络设备对应的OSI通讯层</h2><ul><li><p>物理层：中继器<br><img src="/image/network_中继器.png" alt="网络设备图"></p></li><li><p>数据链路层：网桥<br><img src="/image/network_网桥.png" alt="网络设备图"></p></li><li><p>网络层：路由器<br><img src="/image/network_路由器.png" alt="网络设备图"></p></li><li><p>上层应用：网关<br><img src="/image/network_网关.png" alt="网络设备图"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 同步</title>
      <link href="/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><p>当多线程共享可变数据时，每个读或者写数据的线程都必须执行同步。同步方式可以是加锁，也可以是volatile。如果没有同步，就无法确保一个线程所做的修改可以被另一个线程获知。</p><h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><ul><li>在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。过度的帮助类进行同步操作，会带来性能上的损耗</li><li><p>为了避免不可控性，千万不要在同步区域中调用外来方法。要把同步操作的控制权牢牢抓在自己手中</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet set, Object element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&gt; observers</span><br><span class="line">                        = <span class="keyword">new</span> ArrayList&lt;SetObserver&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误通知示范：</span></span><br><span class="line">    <span class="comment">// 如果在SetObserver的added()方法中调用复杂的addObserver()方法，</span></span><br><span class="line">    <span class="comment">// 会导致ConcurrentModificationException异常，相当于外部调用方法</span></span><br><span class="line">    <span class="comment">// 来影响同步代码块中的操作逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SetObserver observer : observers)</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确通知示范：</span></span><br><span class="line">    <span class="comment">// 将外来调用方法放到同步块外面，同步块中只做极少的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        List&lt;SetObserver&gt; tempObservers;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            tempObservers = <span class="keyword">new</span> ArrayList(observers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SetObserver observer : tempObservers)</span><br><span class="line">            observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加数据步骤省略</span></span><br><span class="line">        <span class="comment">// 通知所有观察者对象</span></span><br><span class="line">        <span class="keyword">if</span> (added)</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="executor和task优先于线程"><a href="#executor和task优先于线程" class="headerlink" title="executor和task优先于线程"></a>executor和task优先于线程</h2><p>Executor Framework提供了灵活的任务执行工具，支持各种类型的线程池。引导开发者将线程工作拆分成了独立任务单元(Runnable)。因此，推荐开发者使用Executor解决问题，而不是自己创建线程。</p><h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><ul><li>大多数域应该正常地进行初始化，而不是延迟初始化。延迟初始化会带来同步问题，产生不必要的错误</li><li><p>某些场景必须要使用延迟初始化，有如下建议：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于静态作用域，建议使用Class Holder初始化模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于实例域，则建议使用双重检查模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function">FieldValue <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">    field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于可以接受重复初始化的实例域，则考虑使用单重检测模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><p>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移殖的。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 异常</title>
      <link href="/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="只针对异常情况才使用异常"><a href="#只针对异常情况才使用异常" class="headerlink" title="只针对异常情况才使用异常"></a>只针对异常情况才使用异常</h2><p>控制正常流程时不应该使用异常，只有当程序发生异常时才应该抛出Exception。Exception就是来描述程序发生异常的，不要职责不清地让异常来处理非异常的事情。例如下面的for-each循环，不应该用异常来控制循环，而应该用状态测试来控制循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范，通过异常来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.next()的NoSuchElementException来判断循环是否结束</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line">    <span class="comment">// 终止循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示范，通过状态测试方法来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.hasNext()方法来判断循环是否结束</span></span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"><a href="#对于可恢复的情况使用受检异常，对于编程错误使用运行时异常" class="headerlink" title="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"></a>对于可恢复的情况使用受检异常，对于编程错误使用运行时异常</h2><ul><li>受检异常：如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。例如文件操作后，文件流的关闭操作。</li><li>非受检异常：如果程序抛出未受检异常或者错误，往往就属于不可恢复的情形，继续执行下去有害无益。例如List.get()的数据越界操作。</li></ul><h2 id="避免不必要地使用受检异常"><a href="#避免不必要地使用受检异常" class="headerlink" title="避免不必要地使用受检异常"></a>避免不必要地使用受检异常</h2><p>当方法存在受检异常时，会给API调用者增加使用成本，例如每次调用该方法时，都要加try-catch代码块。应当少用受检异常。</p><p>使用受检异常的原则</p><ul><li>正确地使用API并不能阻止这种异常条件的产生。参考文件操作，无法保证文件操作不会抛出异常。</li><li>产生异常后，API调用者可以立即采用有效操作。参考文件操作，文件操作抛出异常后，马上关闭文件，然后执行文件处理失败逻辑。</li></ul><h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><p>利用Java提供的标准异常，相当于站在了巨人的肩膀上。可以使你的API更加易于学习，易于使用，更加可读。</p><h2 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h2><p>方法抛出的异常，应该与当前方法有联系。上层实现应该捕获下层异常，同时抛出符合上层语义的异常。例如集合中的异常处理示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将NoSuchElementException改为IndexOutOfBoundException</span></span><br><span class="line"><span class="comment">// 使方法抛出的异常更符合语义，提高了代码的可读性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">ListIterator&lt;E&gt; i = listIterator(index);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.next();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundException(<span class="string">"Index:"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常中包含能捕获失败的信息"><a href="#异常中包含能捕获失败的信息" class="headerlink" title="异常中包含能捕获失败的信息"></a>异常中包含能捕获失败的信息</h2><p>异常面向的用户是开发者，异常信息的内容，应该提供异常堆栈信息，异常信息描述的详细内容等。因为异常面向开发者，所以描述信息最好为英文。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 通用程序设计</title>
      <link href="/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><p>将局部变量的作用域最小化，使代码减少出错，更加可读。</p><ul><li><p>降低出错的可能性</p><blockquote><p>如果变量在它的目标使用区域之前或者之后被意外地使用的话，会产生意想不到的错误。示例如下：</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">Iterator&lt;Element&gt; i = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator();</span><br><span class="line"><span class="comment">// BUG，误将i2写成了i，导致不必要的错误</span></span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomethingElse(i2.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供作用域的最小范围，可以避免此类错误的发生</span></span><br><span class="line">;</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c2.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomethingElse(i.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强可读性</p><blockquote><p>将变量放在使用之前声明，会分散读者注意力。等到用到该变量的时候，读者可能已经记不起该变量的类型和初始值了。</p></blockquote></li></ul><h2 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h2><p>能用for-each循环实现功能的情况下，尽量使用for-each循环。</p><ul><li>for-each循环内部帮你维护了迭代器，降低了自己维护迭代器产生错误的风险。</li><li>for-each循环让代码变得尽量简洁，提高代码可读性。</li></ul><h2 id="如果需要精确的数值，请避免使用float和double"><a href="#如果需要精确的数值，请避免使用float和double" class="headerlink" title="如果需要精确的数值，请避免使用float和double"></a>如果需要精确的数值，请避免使用float和double</h2><ul><li>float和double类型，并没有提供完全精确的结果。所以不应该被用于需要精确结果的场合。尤其不适合用于货币计算，最好用int，long或BigDecimal代替。</li></ul><h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><p>能用基本类型就尽量使用基本类型。装箱基本类型存在以下缺点：</p><ul><li>两个装箱基本类型，存在相同的数值，却只想不同的内存对象。进行比较时，需要调用equil，同时还需考虑NullPointException异常。提高了使用的成本，加大了在开发中出错的风险。</li><li>基本类型比装箱基本类型更节省内存空间，在进行运算操作时也更节省运行时间。装箱基本类型可能会存在频繁的装箱和拆箱。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-规划与迭代</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第八章 成长：规划与迭代》的内容摘要。</p><p>规划是战略布局，是定方向，做正确的事；迭代是战术实施，是定走法，正确地做事。规划的重点在于想，迭代的重点在于动手实现。</p><ul><li>规划，是以自我为中心，以公司为中心的，是生产驱动的。</li><li>迭代，是需求驱动的，是对用户反馈的不断响应，需要根据市场信息的变化一步步的调整。</li></ul><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>由于互联网处于快速变化的大环境中，因此会存在规划更不上变化的情况。最好只做两个规划，最长规划和最短规划。最短规划指最近1个月到3个月，最多6个月的时间段里，要做什么，其实更像是一个项目计划。长计划是这个产品的终极目标，比如3到5年，甚至10年以后会是什么样子，要思考那个时候我们能处于产业链的什么位置。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代的重点在于实现，建议使用敏捷开发的方式，敏捷开发有一下几个关键点。</p><ul><li>沟通，团队之间要进行快速沟通，建立相互信任相互认可的团队氛围。</li><li>简单，做最简单的事，实现想要的目的。</li><li>反馈，拥抱变化，用包容的心态去面对多方反馈，来自同事，用户等。</li><li>勇气，不怕犯错，用于尝试新事物，用于创新。</li><li>谦逊，承认自己的片面性，虚心接受来自多方的建议，善于借助多方的优势。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-确定功能的价值</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第六章 功能：细化与打包》的内容摘要。</p><h2 id="功能评估"><a href="#功能评估" class="headerlink" title="功能评估"></a>功能评估</h2><p>在动手之前，应该先对功能进行评估。功能的评估，主要从价值，成本，功能定位三个角度进行考量。参考一个性价比公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 价值最好分为6个等级（1，2，3，4，5，无限高） 成本最好按照 人/天 为单位</span></span><br><span class="line">性价比 = 价值/成本</span><br></pre></td></tr></table></figure><p>从理论上讲，性价比高的功能优先级也就高，应该先做。不过还应该考虑功能的定位，如果是基础功能，例如支付宝的支付功能，不管代价多大都要做了。</p><h2 id="功能的价值判断"><a href="#功能的价值判断" class="headerlink" title="功能的价值判断"></a>功能的价值判断</h2><p>从三个角度来判断功能的价值，分别是广度，频度，强度。</p><ul><li>广度：潜在用户数 * 单用户价值 可以用来判断功能对应的市场容量及广度。<ul><li>例如打车软件，潜在用户可能是几亿人的打车需求，因为用户使用基数大，所以价值高。</li><li>例如私人银行业务，虽然潜在用户比较少，但每个潜在用户都会有几个亿的存款，因为单用户价值高，所以价值高。</li></ul></li><li>频度：用户使用功能的频率 * 每次使用的转化率。<ul><li>例如外卖软件，用户可能一天要用好几次，每次可以从中转化几元钱，因为用户使用频度大，所以价值高。</li><li>例如结婚软件，用户可能一辈子用一次，但每次可以从中转化几万甚至是几十万，因为使用转化率大，所以价值高。</li></ul></li><li>强度：强度可以理解为用户刚需。可以从不可替代性，紧急程度，持久程度这几方面来看功能的强度。<ul><li>例如，当前功能是否可以被其他功能间接替代。</li><li>例如当前功能是否十分紧急，可能是政府要求等。</li><li>例如当前功能做出来之后是否可以长久投入使用，广告页需求不能持久投入使用。</li></ul></li></ul><h2 id="功能的实现成本"><a href="#功能的实现成本" class="headerlink" title="功能的实现成本"></a>功能的实现成本</h2><p>确定功能之后，粗粒度的评估出完成该功能需要花费的人力成本为多少，以 人/天 为单位。</p><h2 id="功能的定位"><a href="#功能的定位" class="headerlink" title="功能的定位"></a>功能的定位</h2><p>确定一个功能的定位，同样是非常重要的。帮助我们在评估功能的时候，了解该功能的重要程度。</p><ul><li>基础功能：基础功能是每个软件的核心功能，是必不可少的功能。例如支付宝的支付功能，淘宝的购物功能等。</li><li>亮点功能：亮点功能是提升用户忠诚度和口碑传播的功能。一个没有亮点的产品，用户也许偶尔会用，但不会建立正向感情连接，更不会主动帮我们传播。算是应用吸引客户的加分项。例如Chrome的404页面，iPhone5s的指纹识别</li><li>期望功能：期望功能是部分用户期望实现的功能。这类功能属于有则更好的类型，锦上添花。例如网易云音乐的音乐闹钟。</li><li>反向功能：反向功能是出现了会让用户讨厌但是又有利可图的功能。例如，软件广告，迅雷非会员限速功能等。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在确定功能时，首先应该确定功能定位；然后从广度，频度和强度三个方面进行评估功能的价值；最后确定开发成本。最后根据性价比公式，把功能的性价比算出来。然后参考性价比来实现优先实现简单且重要的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>人人都是产品经理 第二版</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Google I/O&#39; 2018 摘要</title>
      <link href="/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/"/>
      <url>/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是了解下未来的趋势，开阔眼界。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>今年大会的重点之一，感觉这方面是未来的大势所趋。降低生产力成本，改善生活。</p><ul><li><p>Google为了推广TensorFlow，作出了很多努力。在社区上积极帮助开发者解决机器学习遇到的各种问题，希望将TensorFlow推广到各个领域。</p></li><li><p>介绍了TensorFlow应用于医学的案例，希望通过机器学习为更多人提供医疗支持。举例在糖尿病眼球病变检测专业，已经做到了专家级的准确率。</p></li><li><p>介绍TensorFlow高层API，帮助开发者快速高效的搭建和训练模型。</p></li><li><p>TensorFlow支持Swift和JavaScript语言。JavaScript支持浏览器和Node环境。希望将TensorFlow和更多的开发体系相融合。</p></li><li><p>移动端的TensorFlow Lite方案，TensorFlow在移动设备上运行机器学习的终端解决方案，具备低延迟，runtime和小体积的特点。通过利用移动端硬件，提升解析速度。</p></li></ul><h3 id="闲鱼TensorFlow-Lite的应用："><a href="#闲鱼TensorFlow-Lite的应用：" class="headerlink" title="闲鱼TensorFlow Lite的应用："></a>闲鱼TensorFlow Lite的应用：</h3><ul><li><p>从节省人工成本角度：做了视频封面的抽取功能，做到自动提取视频预览页</p></li><li><p>从缓解服务端计算压力角度：做了视频指纹，去除重复上传的视频</p></li><li><p>从交互智能化角度：做了AI版房租信息发布页面，提供了用户操作的AI交互方式</p></li></ul><h3 id="端侧AI优势"><a href="#端侧AI优势" class="headerlink" title="端侧AI优势"></a>端侧AI优势</h3><ul><li><p>无网络延时</p></li><li><p>更高稳定性</p></li><li><p>数据隐私性</p></li><li><p>响应实时性</p></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>因为Flutter介绍，找不到视频，所以摘录了闲鱼的总结</p><ul><li><p>Flutter 与 原生混合开发的支持方式</p></li><li><p>如何在混合开发时，更好的利用hot reload机制</p></li><li><p>Flutter和原生组件的组合使用可行性介绍</p></li><li><p>Flutter 渲染原理层介绍<br><img src="/image/flutter_draw.png" alt="Flutter渲染原理图"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Flutter相关：<a href="https://yq.aliyun.com/articles/643698" target="_blank" rel="noopener">https://yq.aliyun.com/articles/643698</a></p><p>AI视频：<a href="https://live.iqiyi.com/s/19rqqzqp9v.html" target="_blank" rel="noopener">https://live.iqiyi.com/s/19rqqzqp9v.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 方法设计</title>
      <link href="/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="检验参数的有效性"><a href="#检验参数的有效性" class="headerlink" title="检验参数的有效性"></a>检验参数的有效性</h2><ul><li><p>应该在方法开头就检验参数的有效性，及时报出参数错误。</p><blockquote><p>传递无效参数给方法，这个方法在执行之前先对参数进行检验，那么他很快就会失败，并且清楚地呈现出适当的异常。如果这个方法没有检查他的参数，就有可能发生以下几种情景。该方法可能在处理过程中失败，并且产生令人费解的异常。更糟糕的是，该方法可以正常方法，但是会悄悄地计算出错误结果。最糟糕的是，该方法可以正常返回，但是却使得某个对象处于被破坏的状态，将来在某个不确定的时候，在某个不相关的点上会引发错误。</p></blockquote></li><li><p>public方法的参数校验直接抛出异常，包内方法则使用assert断言校验参数。</p><blockquote><p>对于未被导出方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。因此，非公有的方法通常应该使用断言来检查它们的参数。</p></blockquote></li></ul><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><ul><li><p>方法的入参和出参都需要考虑保护性拷贝。防止外部方法对其进行破坏性操作。这里的外部方法是指使用类的第三方方法。保护性拷贝不是必须的，但是每次在代码的时候，都应该考虑到这一步操作。尤其是写底层库的时候。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">newClass</span><span class="params">(List&lt;String&gt; args)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;String&gt;(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><ul><li><p>方法名称很重要，在设计方法名时，应该始终遵守标准的命名习惯。</p><blockquote><p>尽量让自己的方法名看起来像一句话一样。在定好自己的方法名之后，最后写伪代码调用自己的方法，验证方法的可读性。设计底层库时很重要。</p></blockquote></li><li><p>避免过长的方法参数列表。</p><blockquote><p>方法的参数最好不超过4个。如果方法参数真的很长，可以考虑Build模式，让使用者优雅的设值，或者考虑外观类，给复杂的实现方法套一层简单的壳。</p></blockquote></li><li><p>boolean类型参数最好用枚举替代。</p><blockquote><p>这是boolean类型参数的小小建议。如果要在参数中使用boolean类型，最好用枚举类型进行替代。首先枚举更具有可读性，其次枚举更利于以后的扩展。</p></blockquote></li></ul><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><ul><li><p>Java语言要调用哪个重载方法是在编译时做出决定的。这一点不符合Java语言的运行时特性。一般情况下，我们认为覆盖操作比较符合Java标准的运行时特性。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载了classify方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection&lt;?&gt;[] collections = &#123; <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, String&gt;().values() &#125;;</span><br><span class="line"><span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</span><br><span class="line">System.out.println(classify(c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期是打印出Set，List，Unknown Collection。但是实际上是打印出Unknown Collection，</span></span><br><span class="line"><span class="comment">// Unknown Collection，Unknown Collection。因为重载是根据编译时决定要调用的是哪个方法。</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于重载容易引起编程时的想法和运行结果不一致。所以，在使用重载编写设计API的时候，应该尽量避免使用。防止API使用者引起误会。如果重载方法的参数的类型有继承关系，例如parse(String content)和parse(Object content)，最好用方法名区分开，paeseString(String content)和parseObject(Object content)。<strong>总之，方法参数数目相同的方法，应该尽量避免重载。</strong></p></blockquote></li></ul><h2 id="返回零长度的集合，而不是null"><a href="#返回零长度的集合，而不是null" class="headerlink" title="返回零长度的集合，而不是null"></a>返回零长度的集合，而不是null</h2><ul><li><p>方法返回集合时，如果集合内容为空，则返回一个空的集合对象，而不是null。</p><blockquote><p>因为对于返回null而不是零长度集合的方法来说，每次调用该方法时都需要判断下返回对象是都为null，从而防止NullPointerException，对于方法使用者很不友好。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>建站初衷</title>
      <link href="/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/"/>
      <url>/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>工作角色逐渐从客户端开发者转变为独立开发者。之前读大学的时候，还有写博客的习惯，后来慢慢转变为做笔记，最近变成了只看书不做笔记了。感觉在学习过程中，缺乏了深度思考的过程。于是，打算搭建个人博客，逼着自己做些深度思考的事情吧。将博客产出作为学习的考核标准。贵在坚持，持之以恒~</p><blockquote><p>博客地址: <a href="http://blog.daiyibo.cn">http://blog.daiyibo.cn</a></p></blockquote><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>Hexo搭建，算是比较简单了。在安装好git开发环境和node开发环境的情况下。需要做的事情如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 安装Hexo</span><br><span class="line"></span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">// 新建博客目录</span><br><span class="line"></span><br><span class="line">mkdir blog</span><br><span class="line"></span><br><span class="line">// 初始化Hexo模板</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">// 启动4000端口，运行博客，主要是本地测试用</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新建博客，下面命令会新建一个XXX.md的文件</span><br><span class="line"></span><br><span class="line">hexo new XXX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
