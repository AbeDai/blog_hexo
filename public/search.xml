<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Effective Java 同步</title>
      <link href="/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/10/03/Effective-Java-%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="同步访问共享的可变数据"><a href="#同步访问共享的可变数据" class="headerlink" title="同步访问共享的可变数据"></a>同步访问共享的可变数据</h2><p>当多线程共享可变数据时，每个读或者写数据的线程都必须执行同步。同步方式可以是加锁，也可以是volatile。如果没有同步，就无法确保一个线程所做的修改可以被另一个线程获知。</p><h2 id="避免过度同步"><a href="#避免过度同步" class="headerlink" title="避免过度同步"></a>避免过度同步</h2><ul><li>在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。过度的帮助类进行同步操作，会带来性能上的损耗</li><li><p>为了避免不可控性，千万不要在同步区域中调用外来方法。要把同步操作的控制权牢牢抓在自己手中</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">added</span><span class="params">(ObservableSet set, Object element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&gt; observers</span><br><span class="line">                        = <span class="keyword">new</span> ArrayList&lt;SetObserver&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(SetObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误通知示范：</span></span><br><span class="line">    <span class="comment">// 如果在SetObserver的added()方法中调用复杂的addObserver()方法，</span></span><br><span class="line">    <span class="comment">// 会导致ConcurrentModificationException异常，相当于外部调用方法</span></span><br><span class="line">    <span class="comment">// 来影响同步代码块中的操作逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SetObserver observer : observers)</span><br><span class="line">                observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确通知示范：</span></span><br><span class="line">    <span class="comment">// 将外来调用方法放到同步块外面，同步块中只做极少的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyElementAdded</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        List&lt;SetObserver&gt; tempObservers;</span><br><span class="line">        <span class="keyword">synchronized</span> (observers) &#123;</span><br><span class="line">            tempObservers = <span class="keyword">new</span> ArrayList(observers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SetObserver observer : tempObservers)</span><br><span class="line">            observer.added(<span class="keyword">this</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加数据步骤省略</span></span><br><span class="line">        <span class="comment">// 通知所有观察者对象</span></span><br><span class="line">        <span class="keyword">if</span> (added)</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="executor和task优先于线程"><a href="#executor和task优先于线程" class="headerlink" title="executor和task优先于线程"></a>executor和task优先于线程</h2><p>Executor Framework提供了灵活的任务执行工具，支持各种类型的线程池。引导开发者将线程工作拆分成了独立任务单元(Runnable)。因此，推荐开发者使用Executor解决问题，而不是自己创建线程。</p><h2 id="慎用延迟初始化"><a href="#慎用延迟初始化" class="headerlink" title="慎用延迟初始化"></a>慎用延迟初始化</h2><ul><li>大多数域应该正常地进行初始化，而不是延迟初始化。延迟初始化会带来同步问题，产生不必要的错误</li><li><p>某些场景必须要使用延迟初始化，有如下建议：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于静态作用域，建议使用Class Holder初始化模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> FieldHolder.field;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于实例域，则建议使用双重检查模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function">FieldValue <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">    field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于可以接受重复初始化的实例域，则考虑使用单重检测模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">FieldType result = field;</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">field = result = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="不要依赖于线程调度器"><a href="#不要依赖于线程调度器" class="headerlink" title="不要依赖于线程调度器"></a>不要依赖于线程调度器</h2><p>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移殖的。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 异常</title>
      <link href="/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/10/01/Effective-Java-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="只针对异常情况才使用异常"><a href="#只针对异常情况才使用异常" class="headerlink" title="只针对异常情况才使用异常"></a>只针对异常情况才使用异常</h2><p>控制正常流程时不应该使用异常，只有当程序发生异常时才应该抛出Exception。Exception就是来描述程序发生异常的，不要职责不清地让异常来处理非异常的事情。例如下面的for-each循环，不应该用异常来控制循环，而应该用状态测试来控制循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范，通过异常来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.next()的NoSuchElementException来判断循环是否结束</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line">    <span class="comment">// 终止循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示范，通过状态测试方法来控制for-each循环流程</span></span><br><span class="line"><span class="comment">// 通过Iterator.hasNext()方法来判断循环是否结束</span></span><br><span class="line">Iterator&lt;Foo&gt; i = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">Foo foo = i.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"><a href="#对于可恢复的情况使用受检异常，对于编程错误使用运行时异常" class="headerlink" title="对于可恢复的情况使用受检异常，对于编程错误使用运行时异常"></a>对于可恢复的情况使用受检异常，对于编程错误使用运行时异常</h2><ul><li>受检异常：如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常。例如文件操作后，文件流的关闭操作。</li><li>非受检异常：如果程序抛出未受检异常或者错误，往往就属于不可恢复的情形，继续执行下去有害无益。例如List.get()的数据越界操作。</li></ul><h2 id="避免不必要地使用受检异常"><a href="#避免不必要地使用受检异常" class="headerlink" title="避免不必要地使用受检异常"></a>避免不必要地使用受检异常</h2><p>当方法存在受检异常时，会给API调用者增加使用成本，例如每次调用该方法时，都要加try-catch代码块。应当少用受检异常。</p><p>使用受检异常的原则</p><ul><li>正确地使用API并不能阻止这种异常条件的产生。参考文件操作，无法保证文件操作不会抛出异常。</li><li>产生异常后，API调用者可以立即采用有效操作。参考文件操作，文件操作抛出异常后，马上关闭文件，然后执行文件处理失败逻辑。</li></ul><h2 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h2><p>利用Java提供的标准异常，相当于站在了巨人的肩膀上。可以使你的API更加易于学习，易于使用，更加可读。</p><h2 id="抛出与抽象相对应的异常"><a href="#抛出与抽象相对应的异常" class="headerlink" title="抛出与抽象相对应的异常"></a>抛出与抽象相对应的异常</h2><p>方法抛出的异常，应该与当前方法有联系。上层实现应该捕获下层异常，同时抛出符合上层语义的异常。例如集合中的异常处理示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将NoSuchElementException改为IndexOutOfBoundException</span></span><br><span class="line"><span class="comment">// 使方法抛出的异常更符合语义，提高了代码的可读性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">ListIterator&lt;E&gt; i = listIterator(index);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.next();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundException(<span class="string">"Index:"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常中包含能捕获失败的信息"><a href="#异常中包含能捕获失败的信息" class="headerlink" title="异常中包含能捕获失败的信息"></a>异常中包含能捕获失败的信息</h2><p>异常面向的用户是开发者，异常信息的内容，应该提供异常堆栈信息，异常信息描述的详细内容等。因为异常面向开发者，所以描述信息最好为英文。</p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 通用程序设计</title>
      <link href="/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/29/Effective-Java-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h2><p>将局部变量的作用域最小化，使代码减少出错，更加可读。</p><ul><li><p>降低出错的可能性</p><blockquote><p>如果变量在它的目标使用区域之前或者之后被意外地使用的话，会产生意想不到的错误。示例如下：</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">Iterator&lt;Element&gt; i = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">Iterator&lt;Element&gt; i2 = c2.iterator();</span><br><span class="line"><span class="comment">// BUG，误将i2写成了i，导致不必要的错误</span></span><br><span class="line"><span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line">doSomethingElse(i2.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供作用域的最小范围，可以避免此类错误的发生</span></span><br><span class="line">;</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Element&gt; i = c2.iterator(); i.hasNext(); )&#123;</span><br><span class="line">doSomethingElse(i.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增强可读性</p><blockquote><p>将变量放在使用之前声明，会分散读者注意力。等到用到该变量的时候，读者可能已经记不起该变量的类型和初始值了。</p></blockquote></li></ul><h2 id="for-each循环优先于传统的for循环"><a href="#for-each循环优先于传统的for循环" class="headerlink" title="for-each循环优先于传统的for循环"></a>for-each循环优先于传统的for循环</h2><p>能用for-each循环实现功能的情况下，尽量使用for-each循环。</p><ul><li>for-each循环内部帮你维护了迭代器，降低了自己维护迭代器产生错误的风险。</li><li>for-each循环让代码变得尽量简洁，提高代码可读性。</li></ul><h2 id="如果需要精确的数值，请避免使用float和double"><a href="#如果需要精确的数值，请避免使用float和double" class="headerlink" title="如果需要精确的数值，请避免使用float和double"></a>如果需要精确的数值，请避免使用float和double</h2><ul><li>float和double类型，并没有提供完全精确的结果。所以不应该被用于需要精确结果的场合。尤其不适合用于货币计算，最好用int，long或BigDecimal代替。</li></ul><h2 id="基本类型优先于装箱基本类型"><a href="#基本类型优先于装箱基本类型" class="headerlink" title="基本类型优先于装箱基本类型"></a>基本类型优先于装箱基本类型</h2><p>能用基本类型就尽量使用基本类型。装箱基本类型存在以下缺点：</p><ul><li>两个装箱基本类型，存在相同的数值，却只想不同的内存对象。进行比较时，需要调用equil，同时还需考虑NullPointException异常。提高了使用的成本，加大了在开发中出错的风险。</li><li>基本类型比装箱基本类型更节省内存空间，在进行运算操作时也更节省运行时间。装箱基本类型可能会存在频繁的装箱和拆箱。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-规划与迭代</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E8%A7%84%E5%88%92%E4%B8%8E%E8%BF%AD%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第八章 成长：规划与迭代》的内容摘要。</p><p>规划是战略布局，是定方向，做正确的事；迭代是战术实施，是定走法，正确地做事。规划的重点在于想，迭代的重点在于动手实现。</p><ul><li>规划，是以自我为中心，以公司为中心的，是生产驱动的。</li><li>迭代，是需求驱动的，是对用户反馈的不断响应，需要根据市场信息的变化一步步的调整。</li></ul><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>由于互联网处于快速变化的大环境中，因此会存在规划更不上变化的情况。最好只做两个规划，最长规划和最短规划。最短规划指最近1个月到3个月，最多6个月的时间段里，要做什么，其实更像是一个项目计划。长计划是这个产品的终极目标，比如3到5年，甚至10年以后会是什么样子，要思考那个时候我们能处于产业链的什么位置。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代的重点在于实现，建议使用敏捷开发的方式，敏捷开发有一下几个关键点。</p><ul><li>沟通，团队之间要进行快速沟通，建立相互信任相互认可的团队氛围。</li><li>简单，做最简单的事，实现想要的目的。</li><li>反馈，拥抱变化，用包容的心态去面对多方反馈，来自同事，用户等。</li><li>勇气，不怕犯错，用于尝试新事物，用于创新。</li><li>谦逊，承认自己的片面性，虚心接受来自多方的建议，善于借助多方的优势。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品-确定功能的价值</title>
      <link href="/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/"/>
      <url>/2018/09/24/%E4%BA%A7%E5%93%81-%E7%A1%AE%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在看《人人都是产品经理》，帮助程序员提升全局意识，还是蛮有用的。本次主要记录了《第六章 功能：细化与打包》的内容摘要。</p><h2 id="功能评估"><a href="#功能评估" class="headerlink" title="功能评估"></a>功能评估</h2><p>在动手之前，应该先对功能进行评估。功能的评估，主要从价值，成本，功能定位三个角度进行考量。参考一个性价比公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 价值最好分为6个等级（1，2，3，4，5，无限高） 成本最好按照 人/天 为单位</span></span><br><span class="line">性价比 = 价值/成本</span><br></pre></td></tr></table></figure><p>从理论上讲，性价比高的功能优先级也就高，应该先做。不过还应该考虑功能的定位，如果是基础功能，例如支付宝的支付功能，不管代价多大都要做了。</p><h2 id="功能的价值判断"><a href="#功能的价值判断" class="headerlink" title="功能的价值判断"></a>功能的价值判断</h2><p>从三个角度来判断功能的价值，分别是广度，频度，强度。</p><ul><li>广度：潜在用户数 * 单用户价值 可以用来判断功能对应的市场容量及广度。<ul><li>例如打车软件，潜在用户可能是几亿人的打车需求，因为用户使用基数大，所以价值高。</li><li>例如私人银行业务，虽然潜在用户比较少，但每个潜在用户都会有几个亿的存款，因为单用户价值高，所以价值高。</li></ul></li><li>频度：用户使用功能的频率 * 每次使用的转化率。<ul><li>例如外卖软件，用户可能一天要用好几次，每次可以从中转化几元钱，因为用户使用频度大，所以价值高。</li><li>例如结婚软件，用户可能一辈子用一次，但每次可以从中转化几万甚至是几十万，因为使用转化率大，所以价值高。</li></ul></li><li>强度：强度可以理解为用户刚需。可以从不可替代性，紧急程度，持久程度这几方面来看功能的强度。<ul><li>例如，当前功能是否可以被其他功能间接替代。</li><li>例如当前功能是否十分紧急，可能是政府要求等。</li><li>例如当前功能做出来之后是否可以长久投入使用，广告页需求不能持久投入使用。</li></ul></li></ul><h2 id="功能的实现成本"><a href="#功能的实现成本" class="headerlink" title="功能的实现成本"></a>功能的实现成本</h2><p>确定功能之后，粗粒度的评估出完成该功能需要花费的人力成本为多少，以 人/天 为单位。</p><h2 id="功能的定位"><a href="#功能的定位" class="headerlink" title="功能的定位"></a>功能的定位</h2><p>确定一个功能的定位，同样是非常重要的。帮助我们在评估功能的时候，了解该功能的重要程度。</p><ul><li>基础功能：基础功能是每个软件的核心功能，是必不可少的功能。例如支付宝的支付功能，淘宝的购物功能等。</li><li>亮点功能：亮点功能是提升用户忠诚度和口碑传播的功能。一个没有亮点的产品，用户也许偶尔会用，但不会建立正向感情连接，更不会主动帮我们传播。算是应用吸引客户的加分项。例如Chrome的404页面，iPhone5s的指纹识别</li><li>期望功能：期望功能是部分用户期望实现的功能。这类功能属于有则更好的类型，锦上添花。例如网易云音乐的音乐闹钟。</li><li>反向功能：反向功能是出现了会让用户讨厌但是又有利可图的功能。例如，软件广告，迅雷非会员限速功能等。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在确定功能时，首先应该确定功能定位；然后从广度，频度和强度三个方面进行评估功能的价值；最后确定开发成本。最后根据性价比公式，把功能的性价比算出来。然后参考性价比来实现优先实现简单且重要的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>人人都是产品经理 第二版</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Google I/O&#39; 2018 摘要</title>
      <link href="/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/"/>
      <url>/2018/09/22/Google-I-O-2018-%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是了解下未来的趋势，开阔眼界。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>今年大会的重点之一，感觉这方面是未来的大势所趋。降低生产力成本，改善生活。</p><ul><li><p>Google为了推广TensorFlow，作出了很多努力。在社区上积极帮助开发者解决机器学习遇到的各种问题，希望将TensorFlow推广到各个领域。</p></li><li><p>介绍了TensorFlow应用于医学的案例，希望通过机器学习为更多人提供医疗支持。举例在糖尿病眼球病变检测专业，已经做到了专家级的准确率。</p></li><li><p>介绍TensorFlow高层API，帮助开发者快速高效的搭建和训练模型。</p></li><li><p>TensorFlow支持Swift和JavaScript语言。JavaScript支持浏览器和Node环境。希望将TensorFlow和更多的开发体系相融合。</p></li><li><p>移动端的TensorFlow Lite方案，TensorFlow在移动设备上运行机器学习的终端解决方案，具备低延迟，runtime和小体积的特点。通过利用移动端硬件，提升解析速度。</p></li></ul><h3 id="闲鱼TensorFlow-Lite的应用："><a href="#闲鱼TensorFlow-Lite的应用：" class="headerlink" title="闲鱼TensorFlow Lite的应用："></a>闲鱼TensorFlow Lite的应用：</h3><ul><li><p>从节省人工成本角度：做了视频封面的抽取功能，做到自动提取视频预览页</p></li><li><p>从缓解服务端计算压力角度：做了视频指纹，去除重复上传的视频</p></li><li><p>从交互智能化角度：做了AI版房租信息发布页面，提供了用户操作的AI交互方式</p></li></ul><h3 id="端侧AI优势"><a href="#端侧AI优势" class="headerlink" title="端侧AI优势"></a>端侧AI优势</h3><ul><li><p>无网络延时</p></li><li><p>更高稳定性</p></li><li><p>数据隐私性</p></li><li><p>响应实时性</p></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>因为Flutter介绍，找不到视频，所以摘录了闲鱼的总结</p><ul><li><p>Flutter 与 原生混合开发的支持方式</p></li><li><p>如何在混合开发时，更好的利用hot reload机制</p></li><li><p>Flutter和原生组件的组合使用可行性介绍</p></li><li><p>Flutter 渲染原理层介绍<br><img src="/image/flutter_draw.png" alt="Flutter渲染原理图"></p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Flutter相关：<a href="https://yq.aliyun.com/articles/643698" target="_blank" rel="noopener">https://yq.aliyun.com/articles/643698</a></p><p>AI视频：<a href="https://live.iqiyi.com/s/19rqqzqp9v.html" target="_blank" rel="noopener">https://live.iqiyi.com/s/19rqqzqp9v.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Effective Java 方法设计</title>
      <link href="/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/09/20/Effective-Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="检验参数的有效性"><a href="#检验参数的有效性" class="headerlink" title="检验参数的有效性"></a>检验参数的有效性</h2><ul><li><p>应该在方法开头就检验参数的有效性，及时报出参数错误。</p><blockquote><p>传递无效参数给方法，这个方法在执行之前先对参数进行检验，那么他很快就会失败，并且清楚地呈现出适当的异常。如果这个方法没有检查他的参数，就有可能发生以下几种情景。该方法可能在处理过程中失败，并且产生令人费解的异常。更糟糕的是，该方法可以正常方法，但是会悄悄地计算出错误结果。最糟糕的是，该方法可以正常返回，但是却使得某个对象处于被破坏的状态，将来在某个不确定的时候，在某个不相关的点上会引发错误。</p></blockquote></li><li><p>public方法的参数校验直接抛出异常，包内方法则使用assert断言校验参数。</p><blockquote><p>对于未被导出方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。因此，非公有的方法通常应该使用断言来检查它们的参数。</p></blockquote></li></ul><h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><ul><li><p>方法的入参和出参都需要考虑保护性拷贝。防止外部方法对其进行破坏性操作。这里的外部方法是指使用类的第三方方法。保护性拷贝不是必须的，但是每次在代码的时候，都应该考虑到这一步操作。尤其是写底层库的时候。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">newClass</span><span class="params">(List&lt;String&gt; args)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;String&gt;(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出参的保护性拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="谨慎设计方法签名"><a href="#谨慎设计方法签名" class="headerlink" title="谨慎设计方法签名"></a>谨慎设计方法签名</h2><ul><li><p>方法名称很重要，在设计方法名时，应该始终遵守标准的命名习惯。</p><blockquote><p>尽量让自己的方法名看起来像一句话一样。在定好自己的方法名之后，最后写伪代码调用自己的方法，验证方法的可读性。设计底层库时很重要。</p></blockquote></li><li><p>避免过长的方法参数列表。</p><blockquote><p>方法的参数最好不超过4个。如果方法参数真的很长，可以考虑Build模式，让使用者优雅的设值，或者考虑外观类，给复杂的实现方法套一层简单的壳。</p></blockquote></li><li><p>boolean类型参数最好用枚举替代。</p><blockquote><p>这是boolean类型参数的小小建议。如果要在参数中使用boolean类型，最好用枚举类型进行替代。首先枚举更具有可读性，其次枚举更利于以后的扩展。</p></blockquote></li></ul><h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><ul><li><p>Java语言要调用哪个重载方法是在编译时做出决定的。这一点不符合Java语言的运行时特性。一般情况下，我们认为覆盖操作比较符合Java标准的运行时特性。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载了classify方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection&lt;?&gt;[] collections = &#123; <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, String&gt;().values() &#125;;</span><br><span class="line"><span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</span><br><span class="line">System.out.println(classify(c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期是打印出Set，List，Unknown Collection。但是实际上是打印出Unknown Collection，</span></span><br><span class="line"><span class="comment">// Unknown Collection，Unknown Collection。因为重载是根据编译时决定要调用的是哪个方法。</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>由于重载容易引起编程时的想法和运行结果不一致。所以，在使用重载编写设计API的时候，应该尽量避免使用。防止API使用者引起误会。如果重载方法的参数的类型有继承关系，例如parse(String content)和parse(Object content)，最好用方法名区分开，paeseString(String content)和parseObject(Object content)。<strong>总之，方法参数数目相同的方法，应该尽量避免重载。</strong></p></blockquote></li></ul><h2 id="返回零长度的集合，而不是null"><a href="#返回零长度的集合，而不是null" class="headerlink" title="返回零长度的集合，而不是null"></a>返回零长度的集合，而不是null</h2><ul><li><p>方法返回集合时，如果集合内容为空，则返回一个空的集合对象，而不是null。</p><blockquote><p>因为对于返回null而不是零长度集合的方法来说，每次调用该方法时都需要判断下返回对象是都为null，从而防止NullPointerException，对于方法使用者很不友好。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 客户端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>建站初衷</title>
      <link href="/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/"/>
      <url>/2018/09/19/%E5%BB%BA%E7%AB%99%E5%88%9D%E8%A1%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>工作角色逐渐从客户端开发者转变为独立开发者。之前读大学的时候，还有写博客的习惯，后来慢慢转变为做笔记，最近变成了只看书不做笔记了。感觉在学习过程中，缺乏了深度思考的过程。于是，打算搭建个人博客，逼着自己做些深度思考的事情吧。将博客产出作为学习的考核标准。贵在坚持，持之以恒~</p><blockquote><p>博客地址: <a href="https://blog.daiyibo.cn">https://blog.daiyibo.cn</a></p></blockquote><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>Hexo搭建，算是比较简单了。在安装好git开发环境和node开发环境的情况下。需要做的事情如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 安装Hexo</span><br><span class="line"></span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">// 新建博客目录</span><br><span class="line"></span><br><span class="line">mkdir blog</span><br><span class="line"></span><br><span class="line">// 初始化Hexo模板</span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">// 启动4000端口，运行博客，主要是本地测试用</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新建博客，下面命令会新建一个XXX.md的文件</span><br><span class="line"></span><br><span class="line">hexo new XXX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
