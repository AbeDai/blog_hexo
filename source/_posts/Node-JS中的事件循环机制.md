---
title: Node-JS中的事件循环机制
date: 2018-12-31 20:32:40
categories: 后台
---

## 简介
Node.js的单线程含义，实际上说的是执行同步代码的主线程。一个Node程序的启动，不止是分配了一个线程，而是我们只能在一个线程执行代码。当出现I/O资源调用，TCP连接等外部资源申请的时候，不会阻塞主线程，而是委托给I/O线程进行处理，并且进入等待队列。一旦主线程执行完成，将会消费事件队列(Event Queue)。因为只有一个主线程，只占用CPU内核处理逻辑计算，因此不适合在CPU密集型进行使用。EventLoop 是一种常用的机制，通过对内部或外部的事件提供者发出请求，如文件读写，网络连接 等异步操作，完成后调用事件处理程序。整个过程都是异步阶段。

## 事件循环机制

```
   ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
   
注：模型中的每一个方块代表事件循环的一个阶段
```

- timers 阶段: 这个阶段执行通过setTimeout(callback)和setInterval(callback)设置的callback;
- i/o 阶段: 执行除了close事件，和setTimeout，setInterval，setImmediate方法设定的callbacks之外的callbacks;
- idle, prepare 阶段: 仅node内部使用;
- poll 阶段: 轮询，不断检查有没有新的I/O事件，事件环可能会在这里阻塞;
- check 阶段: 执行setImmediate(callback)设置的callbacks;
- close 阶段: 执行close事件的callback，例如socket.on('close', callback)的callbacks;

## 各阶段详细介绍
下面，我们来针对Node事件循环的每个阶段进行详细说明。

#### timers 阶段
这个阶段主要用来处理定时器相关的回调，当一个定时器超时后，一个事件就会加入到队列中，事件循环跳转至这个阶段执行对应的回调函数。定时器的回调会在触发后尽可能早地被调用，这表示实际的延时可能会比定时器规定的时间要长。如果事件循环，此时正在执行一个比较耗时的callback，例如处理一个比较耗时的循环，那么定时器的回调只能等到当前回调执行结束了才能被执行，即被阻塞。事实上，timers阶段的执行受到poll阶段的控制，后面会讲到。

#### IO callbacks 阶段
Nodejs官网文档对这个阶段的解释为：除了timers、setImmediate，以及close操作之外的大多数的回调方法都位于这个阶段执行。但是，一些常见的回调，例如fs.readFile的回调是放在poll阶段来执行的。根据libuv的文档，一些应该在上轮事件循环poll阶段执行的callback，因为某些原因不能执行，就会被延迟到这一轮的事件循环的I/O callbacks阶段执行。换句话说这个阶段执行的callbacks是上轮残留的。

#### poll 阶段
poll阶段的主要任务是等待新的事件的出现（该阶段使用epoll来获取新的事件），如果没有，事件循环可能会在此阻塞。这些事件对应的回调方法可能位于timers阶段（如果定义了定时器），也可能是check阶段（如果设置了setImmediate方法）。poll阶段主要有两个步骤如下：

（1）如果有到期的定时器，那么就执行定时器的回调方法。
（2）处理poll阶段对应的事件队列（以下简称poll队列）里的事件。
当事件循环到达poll阶段时，如果这时没有要处理的定时器的回调方法，则会进行下面的判断：
（1）如果poll队列不为空，则事件循环会按照顺序遍历执行队列中的回调函数，这个过程是同步的。
（2）如果poll队列为空，会接着进行如下的判断：①如果当前代码定义了setImmediate方法，事件循环会离开poll阶段，然后进入check阶段去执行setImmediate方法定义的回调方法。②如果当前代码并没有定义setImmediate方法，那么事件循环可能会进入等待状态，并等待新的事件出现，这也是该阶段为什么会被命名为poll（轮询）的原因。此外，还会不断检查是否有相关的定时器超时，如果有，就会跳转到timers阶段，然后执行对应的回调。

#### check 阶段
setImmediate是一个特殊的定时器方法，它占据了事件循环的一个阶段，整个check阶段就是为setImmediate方法而设置的。一般情况下，当事件循环到达poll阶段后，就会检查当前代码是否调用了setImmediate，但如果一个回调函数是被setImmediate方法调用的，事件循环就会跳出poll阶段而进入check阶段。

#### close 阶段
如果一个socket或者一个句柄被关闭，那么就会产生一个close事件，该事件会被加入到对应的队列中。close阶段执行完毕后，本轮事件循环结束，循环进入到下一轮。

