---
title: 算法-红黑树的思考
date: 2019-01-03 20:12:15
categories: 基础
---

## 简介
红黑树，一种自平衡的 二叉查找树，但在每个节点上有一个额外的存储位表示节点的颜色，可以是Red或者Black。这些颜色位用来确保红黑树在插入和删除操作后仍能近乎平衡。
## 红黑树的应用场景
到此，我们可能已经对红黑树有了一点初步的认识了，但是我们却不知道为什么要有红黑树，红黑树是为了解决什么问题被提出来的呢？
我们知道，二叉查找树在大多数情况下查找和插入在效率上是没有问题的，但是在最坏的情况下效率比较低，但是平衡二叉树能够保证在最坏的情况下也能达到lgN，要实现这一目标，我们就要保证在插入完成后始终保持平衡状态。在一棵具有N个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以就出现一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。而我们所讲的红黑树就属于此新的数据结构之一，除此之外还有B树等数据结构。

## 红黑树与其他结构对比
**红黑树 vs 普通二叉树**
红黑树再插入或者删除节点后，会对操作后的树进行重新平衡操作。使得最坏情况下，对节点的查询效率还是高。而普通二叉树，有可能会引起树倾斜的问题，这时在查找树中节点，效率可能变成了O(1)。
**红黑树 vs AVL平衡二叉树**
AVL树需要严格维护二叉树平衡。而红黑树通过节点颜色来维护一个相对平衡的二叉树。
- 在搜索上，AVL效率为log(O)，而红黑树平均效率为log(O)，最大情况下是2log(O)。
- 在插入上，红黑树和AVL树，节点旋转次数都是O(1)。
- 在删除上，红黑树在删除时节点旋转次数是O(1)，AVL树在删除时节点旋转次数是O(logn)。

红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。
RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。

## 红黑树特性
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

## 关于时间复杂度的证明
> 红黑树的时间复杂度为: O(lgn)
下面通过“数学归纳法”对红黑树的时间复杂度进行证明。
定理：一棵含有n个节点的红黑树的高度至多为2log(n+1).
证明：
"一棵含有n个节点的红黑树的高度至多为2log(n+1)" 的逆否命题是 "高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个"。
我们只需要证明逆否命题，即可证明原命题为真；即只需证明 "高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个"。
从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x's black height)，记为bh(x)。关于bh(x)有两点需要说明：
第1点：根据红黑树的"特性(5) ，即从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点"可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。这也就意味着，bh(x)的值是唯一的！
第2点：根据红黑色的"特性(4)，即如果一个节点是红色的，则它的子节点必须是黑色的"可知，从节点x出发达到叶节点"所经历的黑节点数目">= "所经历的红节点的数目"。假设x是根节点，则可以得出结论"bh(x) >= h/2"。进而，我们只需证明 "高度为h的红黑树，它的包含的黑节点个数至少为 2bh(x)-1个"即可。
到这里，我们将需要证明的定理已经由
"一棵含有n个节点的红黑树的高度至多为2log(n+1)"
转变成只需要证明
"高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个"。
下面通过"数学归纳法"开始论证高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个"。
(01) 当树的高度h=0时，
内节点个数是0，bh(x) 为0，2bh(x)-1 也为 0。显然，原命题成立。
(02) 当h>0，且树的高度为 h-1 时，它包含的节点个数至少为 2bh(x)-1-1。这个是根据(01)推断出来的！
下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2bh(x)-1”。
当树的高度为 h 时，
对于节点x(x为根节点)，其黑高度为bh(x)。
对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。
根据(02)的已知条件，我们已知 "x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2bh(x)-1-1 个"；
所以，节点x所包含的节点至少为 ( 2bh(x)-1-1 ) + ( 2bh(x)-1-1 ) + 1 = 2^bh(x)-1。即节点x所包含的节点至少为 2bh(x)-1。
因此，原命题成立。
由(01)、(02)得出，"高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)-1个"。
因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。

## 左旋和右旋
时间复杂度： O(1)
左旋和右旋是相互对称的
图示：
![](/image/base_rbtree_1.png)

## 红黑树插入节点后矫正情况
矫正的时间复杂度为O(1)。在单次矫正情况中，旋转从不超过2次，因为只要执行了情况2和情况3，while循环就结束了。插件节点，插入的是红色节点。并且是插入到树的叶节点上的。因此只会破坏（“如果一个节点是红色的，则它的子节点必须是黑色的”）特性。处理逻辑如下：

### 情况1
当前节点的父节点是红色，且叔叔节点也是红色

#### 目的
通过调整颜色，在不改变红黑树5个特性的情况下，将红色节点上移。

#### 处理策略
- 将“父节点”设为黑色
- 将“叔叔节点”设为黑色
- 将“祖父节点”设为“红色”
- 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作
![](/image/base_rbtree_2.png)


### 情况2
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是父节点的右孩子

#### 目的
通过旋转，在不改变当前树原有特点的情况下（红节点的子节点还是红色），将情况2转变成情况3

#### 处理策略
- 将“父节点”作为“新的当前节点”
- 以“新的当前节点”为支点进行左旋
![](/image/base_rbtree_3.png)


### 情况3
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子

#### 处理策略
- 将“父节点”设为“黑色”。
- 将“祖父节点”设为“红色”。
- 以“祖父节点”为支点进行右旋。
![](/image/base_rbtree_4.png)


## 红黑树删除节点后矫正情况
矫正的时间复杂度为O(1)。单次矫正，旋转从不超过3次。到情况2或者情况4就终止了。移除节点，如果移除的是红色节点，则直接删除即可。如果移除的是黑色节点，会破坏（“如果一个节点是红色的，则它的子节点必须是黑色的”和“每个节点或者是黑色，或者是红色”）特性。处理逻辑如下：

### 情况1
x是"黑+黑"节点，x的兄弟节点是红色。

#### 目的
将当前模式转化为后续三种模式

#### 处理策略
- 将x的兄弟节点设为“黑色”。
- 将x的父节点设为“红色”。
- 对x的父节点进行左旋。
- 左旋后，重新设置x的兄弟节点。
![](/image/base_rbtree_5.png)


### 情况2
x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。

#### 目的
将“黑+黑”节点，中的其中一个黑色属性消除，并上移。

#### 处理策略
- 将x的兄弟节点设为“红色”。
- 设置“x的父节点”为“新的x节点”，原来为红色，现在就是“黑+红”节点，将红色移除后，“新的x节点”为黑色，平衡结束。如果原来是黑色，现在就是“黑+黑”节点，根据情况执行处理策略。
![](/image/base_rbtree_6.png)


### 情况3
x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。

#### 目的
将当前状态转化为情况4

#### 处理策略
- 将x兄弟节点的左孩子设为“黑色”。
- 将x兄弟节点设为“红色”。
- 对x的兄弟节点进行右旋。
- 右旋后，重新设置x的兄弟节点。
![](/image/base_rbtree_7.png)


### 情况4
x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。
#### 目的
为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother's Left Son)，“兄弟节点的右孩子”为BRS(Brother's Right Son)，“父节点”为F(Father)。
我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：
- 第一，“同时经过根节点和S的分支的黑色节点个数不变”。
    - 若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。
- 第二，“同时经过根节点和BLS的分支的黑色节点数不变”。
    - 若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色"黑色"，赋值给了F)。至此，我们算是调换了F和B的颜色。
- 第三，“同时经过根节点和BRS的分支的黑色节点数不变”。
    - 在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。

经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。

#### 处理策略
- 将x父节点颜色 赋值给 x的兄弟节点。
- 将x父节点设为“黑色”。
- 将x兄弟节点的右子节设为“黑色”。
- 对x的父节点进行左旋。
- 设置“x”为“根节点”。
![](/image/base_rbtree_8.png)

## 参考
https://tech.meituan.com/redblack_tree.html
https://zhuanlan.zhihu.com/p/34840762